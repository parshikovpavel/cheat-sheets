Сегодня написание Web-приложения с нуля требует много времени и ресурсов, при том что многие типовые задачи уже многократно реализовывались. Поэтому очевидным является переход к сборке приложений из готовых совместимых пакетов (*package*).

При сборке приложения возникают следующие задачи:

* управление пакетами – описание подключаемых пакетов и их загрузка с git-хостинга. Осуществляется с помощью *Composer*.

* обеспечение совместимости пакетов. Для обеспечения совместимости пакетов разрабатываются рекомендации *PSR*. Для PHP эта проблема особенно актуальна, т.к. в отличии от других языков (*Java, Python, Ruby*) в *PHP* нет глобально используемого фреймворка. Популярны много фреймворков: *YII, Symfony, Laravel*... 

# Packagist

Packagist ([https://packagist.org/](https://packagist.org/)) –официальный каталог *Composer* пакетов PHP-сообщества. Каталог помогает искать пакеты по ключевым словами, и хранит информацию о пакетах, в т.ч. ссылку на *Github*. 

Имя каждого пакета имеет вид:

```
имя_производителя/имя_пакета
yiisoft/yii2
```

Имя пакета должно быть уникальным на *Packagist*.

Пространство имен, используемое в файлах пакета, НЕ ДОЛЖНО!!! быть как-то связано с *vendor-name* и *package-name* (например, в пакете `parshikovpavel\FinalKeyword`  используется пространство `PPFinal`).

# Организация пакета

Как правило, пакет содержит следующие папки:

·      src/ — папка, содержащая исходный код пакета;

·      tests/— папка с тестами пакета.

·      composer.json — конфигурационный файл пакета, описывающий пакет, его зависимости и схему автозагрузки классов;

·      README.md — описание пакета (Markdown);

·      CONTRIBUTING.md — условия распространения пакета (Markdown)

·      LICENSE — лицензия;

·      CHANGELOG.md — список версий пакета и изменений в версиях.

# Composer

Composer – это менеджер зависимостей (dependency manager) для PHP, утилита, которая в соответствии с конфигурацией автоматически загружает пакеты-зависимости. 

При этом он не является менеджером пакетов (package manager), как apt-get в Debian, т.к. не устанавливает никакого программного обеспечения. 

Аналогичные утилиты разработаны для языков программирования, связанных с Web: 

·      Ruby  – Bundler

·      Python – pip

·      Node.js  – npm.

До распространения Composer установка библиотеки выглядела так:

·      скачивание библиотеки вручную

·      размещение библиотеки в папке проекта вручную

·       загрузку файлов библиотеки в коде вручную:

require **"..."**

require_once **"..."**

## composer.json

В конфигурационном  файле composer.json указываются пакеты, требуемые для работы приложения (зависимости приложения). Файл composer.json следует располагать в корне проекта.

### Корневой (root) и не корневой composer.json

Корневой (*root*) *composer.json* – размещенный в корне текущего проекта. Корневой *composer.json* определяет конфигурацию разрабатываемого проекта. Разрабатываемый проект с этой точки зрения следует рассматривать, как корневой пакет (*root package*).

В момент разработки пакет является корневым. Но, если он загружается как зависимость в другом проекте, то он уже не корневой (*no root*) пакет.

Некоторые свойства в *composer.json* имеют значение только когда пакет является корневым (например, `autoload-dev`). Если пакет загружен как зависимость, то эти свойства игнорируются.

#### Примеры

Если разрабатываемый проект не является пакетом, который потом будет загружаться в другие проекты в качестве зависимости. 

Файл composer.json для такого проекта (не пакета) очень простой и содержит только описание зависимостей. Файл composer.json и проект будут использоваться только как корневые.

{
     "require": {
         "yiisoft/yii2": "~2.0.14"
     },
     "require-dev": {
         "yiisoft/yii2-debug": "~2.0.0"
     }

}

Если разрабатываемый проект будет позже использован как пакет в других проектах, то composer.json  для такого пакета более подробно описывает проект. Файл composer.json и проект в момент разработки являются root, а в момент подключения как зависимости – не root.

{

​     "name”: "igorsimdyanov/pager",

​     "description": "A library to split results into multiple pages",

​     "keywords": ["pager", "paginator", "pagination"],

​     "homepage": "https://github.com/igorsimdyanov/pager",

​     "license": "MIT",

​     "authors": [

​          {

​              "name": "Igor Simdyanov",

​              "email": "igorsimdyanov@gmail.com"

​          },

​          {

​              "name": "Dmitry Koterov",

​              "email": "dmitry.koterov@gmai1.com"

​          }

​     ],

​     "support": {

​          "emai1": "igorsimdyanov@gmail.com"

​     },

​     "require": {

​          "php": ">=7.0.0"

​     },

​     "autoload": {

​          "psr-4": {

​              "ISPager": "src/"

​          }

​     }

}

 

Ниже перечислены основные свойства конфигурационного файла

### Свойства для указания зависимостей

#### require

В этом свойстве указывается список пакетов, которые требуются во всех окружениях. 

Для проекта эти пакеты будут загружаться командами composer install/update. 

Пакет будет установлен только после того как будут установлен ВСЕ требуемые зависимости. 

Значением является объект, элементы которого сопоставляют «имя пакета» à «ограничение версии пакета». 

Пример конфигурационного файла:

{

​     "require": {

​          "monolog/monolog": "1.17.*" # Версия не ниже 1.17.0

​     )

}

Важно!!! также указать в этом свойстве требуемую версию PHP и необходимые расширения PHP. Нужно указывать все требуемые расширения PHP, т.к. PHP под разные ОС включает по умолчанию разные расширения. 

{

​    "require" : {

​        "php" : "^5.5 || ^7.0",

​        "ext-mbstring": "*"

}

#### require-dev

Имеет смысл только для *root*. В этом свойстве указывается список пакетов, которые необходимы только для *dev*-окружения (например, `phpunit`). 

При обычных:

```bash
composer install
composer update
```

*dev*-зависимости устанавливаются.

Чтобы исключить dev-зависимости, нужно использовать флаг --no-dev:

composer install --no-dev

composer update --no-dev

### Свойства для описания пакета

* `name` (обязательный для пакетов)

  Название пакета. Структура:

  ```
  vendor-name/package-name
  parshikovpavel/final-keyword
  ```

  `name` нечувствительно к регистру. 

* `description` (обязательный для пакетов)

  Краткое описание проекта в виде одной строки. Используется для описания при публикации пакета на сайте *Packagist*.

* `keywords`

  Массив со списком ключевых слов, предназначенный для поиска пакета на сайте *Packagist*

* `homepage` – официальный Web-сайт пакета

* `license` – лицензия

* `type` – тип пакета

  Из коробки доступны:

  - `library` (по умолчанию) – библиотека. Файлы библиотеки копируются в `vendor`. Установка выполняется через `composer require`.
  - `project` – полноценный проект. Например, *YII application* или *Symfony application*. Установка выполняется через `composer create-project`
  - и другие...

* `authors` (настоятельно рекомендуется) 

  Массив с перечислениями всех авторов пакета

  ```json
  "authors": [
  	{
  		"name": "Nils Adermann",
  		"email": "naderman@naderman.de",
  		"homepage": "http://www.naderman.de",
  		"role": "Developer"
  	},
  ]
  ```

* `support`

  Объект с контактной информацией для технической поддержки пакета.

  ```json
  "support": {
  	"email": "support@example.org",
  	"docs": "https://habr.com/..."
  }
  ```

* `autoload` – описание того, как должна происходить автозагрузка пакета. Смотреть [autoload](#свойство-autoload-управление-автозагрузкой) 

### Свойство autoload (управление автозагрузкой)

Свойство autoload управляет, каким образом автозагрузчик vendor/autoload.php будет загружать пакеты. Это свойство является объектом, ключами объекта могут быть PSR-0, PSR-4, classmap, files.

#### psr-4

Отображение пространств имен PHP на пути файловой системы в соответствии со стандартом PSR-4 (см. PSR-4. Автозагрузка классов). Пути отсчитываются относительно корня проекта. 

Пространство имен, используемое в файлах пакета, НЕ ДОЛЖНО!!! быть как-то связано с vendor-name и package-name (например, в пакете parshikovpavel\FinalKeyword  используется пространство PPFinal).

{

​    "autoload": {

​        "psr-4": {

​            "Namespace1\\": "src/",

​            "Namespace1\\Namespace2\\": "test/",

​            "Namespace3\\": "",

​        }

​    }

}

Это значит:

| Правило composer                 | Полное имя класса                  | Загружаемый файл   |
| -------------------------------- | ---------------------------------- | ------------------ |
| Namespace1\:   src/              | \Namespace1\ClassName              | src/ClassName.php  |
| Namespace1\   Namespace2 : test/ | Namespace1\   Namespace2\ClassName | test/ClassName.php |
| Namespace3\:                     | Namespace3\ClassName               | ClassName.php      |

Префикс из правила composer (например, Namespace1\) не включается в путь к файлу (в PSR-0 префикс включается в путь).

Префиксы пространства имен должны заканчиваться \\, т.к. при поиске просто происходит сопоставление с началом строки. Иначе Foo будет соответствовать и Foo и FooBar.

Composer сканирует папки, указанные в правилах, отыскивает файлы с классами и формирует файлы vendor/composer/autoload_XXX.php с картой (отображением) namespace => path.

Также есть дополнительные способы:

{ 

​     "Monolog\\": ["src/", "lib/"], # префикс ищется в нескольких каталогах

​     "": "all/" # каталог для любого префикса

}

#### psr-0

Префикс из правила composer (например, Namespace1\) включается в путь к файлу (в PSR-4 префикс не включается в путь).

Namespace из правила Composer PSR-0 может быть задан вплоть до класса. Это может быть полезно, чтобы указать правило для загрузки конкретного класса из корня пакета:

{

​    "autoload": {

​        "psr-0": { 

​             "NameSpace\\ClassName": "" 

​        }

​    }

}

| Правило composer     | Полное имя класса    | Загружаемый файл         |
| -------------------- | -------------------- | ------------------------ |
| Namespace\ClassName: | \Namespace\ClassName | /NameSpace/ClassName.php |

#### classmap

Используется для классов, имена и namespace которых не соответствуют PSR. В свойстве перечисляются каталоги/файлы. Composer сканирует указанные каталоги/файлы и найденные в них классы записывает в карту namespace => path  по адресу vendor/composer/autoload_classmap.php. 

{

​    "autoload": {

​        "classmap": ["src/", "lib/", "Something.php"]

​    }

}

#### files

Используется для автоматической загрузки на каждый запрос файлов с какими-то функциями (не классов). В свойстве перечисляются файлы, которые будут грузиться на каждом запросе. Т.е. любой проект, который будут включать этот пакет, на каждый запрос будет грузить эти файлы!!!

{

​    "autoload": {

​        "files": ["src/MyLibrary/functions.php"]

​    }

}

 

#### autoload-dev

Свойство, аналогичное autoload. Только эти правила используются в автозагрузке, когда composer.json является корневым. Когда пакет с composer.json загружен в качестве зависимости в папку vendor, это свойство игнорируется.

Используется для описания правил автозагрузки модульных тестов, которые должны работать, когда проект является корневым, и не должны работать, когда проект используется как зависимость. 

{

​    "autoload": {

​        "psr-4": { "MyLibrary\\": "src/" }

​    },

​    "autoload-dev": {

​        "psr-4": { "MyLibrary\\Tests\\": "tests/" }

​    }

}

### Версии пакетов

Версия – это «*ref*» или конкретный *commit*, в каком-то *branch* системы контроля версий *Git*. Номер версии указывается в теге *commit*.

Composer выбирает из репозитория полный список доступных версий, а затем находит самую высокую версию, которая соответствует всем ограничениям версии. При этом ограничения просматриваются сразу для всех пакетов, т.к. компонент может использоваться сразу несколькими пакетами. 

#### Теги

Обычно *Composer* имеет дело с тегами (а не ветками). При указании ограничения версии, это ограничение соотносится с определенным тегом или диапазоном тегов. 

Возможные способы указать ограничение версии:

| Пример                                    | Описание                                                     | Аналог                          |
| ----------------------------------------- | ------------------------------------------------------------ | ------------------------------- |
| `1.0.2`                                   | Конкретный   номер версии                                    |                                 |
| `>1.0` `>=1.0` `<1.0` `<=1.0` `!=1.0` | Ограничение в   виде одиночного условия. Неограниченные диапазоны вверх очень опасны, т.к.   более новые версии могут нарушить совместимость. |                                 |
| `>=1.0` `<2.0`                    | Ограничение в виде нескольких условий. Пробел между условиями рассматривается как логическое AND                                                             |                                 |
| `1.0 - 2.0` `1.0.0 - 2.1.0`    | Диапазон версий                                              | `>=1.0.0 <2.1` `>=1.0.0 <=2.1.0`  |
| `1.0.*`                         | Звездочка `*` для подстановки любого номер версии          | `>=1.0 <1.1`                     |
| `~1.2` `~1.2.3`     | `~` задает  минимальную версию и позволяет последней указанной цифре возрастать   неограниченно | `>=1.2 <2.0.0` `>=1.2.3 <1.3.0`   |
| `^1.2.3` `^0.3`     | `^` задает минимальную версию и позволяет брать версии до следующей мажорной (для версий   до `1.0.0` – до следующей минорной) | `>=1.2.3 <2.0.0` `>=0.3.0 <0.4.0` |

#### Ветка

Для извлечения ветки (*branch*), а не тега, необходимо перед именем ветки использовать специальный префикс `dev-`. Например, чтобы извлечь ветку *master* нужно в  качестве ограничения версии в `require` указать `dev-master`

```json
"require": {
     "ipfedor/email-check": "dev-master"
 }
```

#### Стабильность пакетов

Существует уровни стабильности пакетов (в порядке повышения): `dev`, `alpha`, `beta`, `RC` и `stable`.

![Уровни стабильности](https://parshikovpavel.github.io/img/stability-levels.jpg?1)

Опции для указания разрешенного уровня стабильности пакетов:

- `minimum-stability` (*root-only*) – минимально возможный для загрузки уровень стабильности пакетов. По умолчанию `stable`, т.е. пакеты без тегов с версией `dev-master` грузиться не будут.
- `prefer-stable` (*root-only*) – предпочитать более стабильные пакеты.

## Другие файлы и папки

Пакеты устанавливаются локально, в корне проекта в папку vendor. Эта папка всегда исключается из репозитория через .gitignore, т.к. пакеты в любой момент могут быть загружены заново.. Это позволяет иметь разные зависимости и разные версии одной зависимости для разных проектов.

Исполняемые файлы всех пакетов размещаются вместе в папке vendor/bin. 

Файл composer.lock – содержит дерево зависимостей пакетов и источники загрузки, а также точные версии установленных пакетов. Файл composer.lock, напротив, включается в репозиторий Git. Он позволяет зафиксировать комбинацию версий всех используемых пакетов. Поэтому, после загрузки кода из репозитория мы можем выполнить команду composer install и получить те же версии пакетов, что были зафиксированы разработчиком.

## Установка стороннего кода

### Создание нового проекта из существующего пакета

Используется для:

- взять готовый шаблон проекта (например, YII2) и дорабатывать его


**Вручную**

- скачать проект (вручную) или склонировать через git

  ```
  git clone git://github.com/pqr/superhelloworld.git
  ```


- в корне проекта выполнить команду: 

  ```bash
  composer install
  ```
  
  После этого будут созданы:
  
  - папка `vendor` с пакетами, 
  - файл `vendor/autoload.php`.
  
  Если файла `composer.lock` нет, то он создается и будут скачены свежие версии зависимостей и зафиксированы в нем.
  
  Если файл `composer.lock` есть, то будут скачены указанные в нем версии зависимостей.

**Автоматически**

Используя команду `create-project`. Этот вариант используется всеми фреймворками (*Symfony, Laravel, YII2*) для инициализации своих «*skeleton*» приложений.

```bash
composer create-project vendor/package dir/
```

Создает новый проект из пакета `vendor/package` в каталоге `dir/`. 

Эквивалентно последовательности команд, которая выше описана **Вручную**.

### Установка пакета

**Вручную.**

Это метод более трудоемкий и выше вероятность ошибки.

Надо вручную включить зависимость в `composer.json`:

```json
"require": {
	"yiisoft/yii2": "~2.0.14"
},
```

а потом выполнить:

```bash
composer install
```

**Автоматически**

Командой `require`:

```bash
composer require vendor/package # в блок require
composer require vendor/package --dev # в блок require-dev
composer require vendor/package2:dev-master # с указанием версии
```

В результате:

- будет изменен `composer.json`


- установлены или обновлены зависимости


- обновлён `composer.lock`.


### Обновление пакетов

Если разработчик хочет обновить ВСЕ используемые пакеты до новой версии, то он должен вызвать команду:

```bash
composer update
```

Команда изменяет файл `composer.lock` и вносит туда новые версии пакетов.

Если требуется обновить только некоторые пакеты, то их можно указать через пробел:

```bash
composer update monolog/monolog [...]
```

Команда для обновления самого *composer*:

```bash
composer self-update
```

### Глобальная установка

Команды с ключом `global` запускаются не в текущей директории, а в *COMPOSER_HOME* директории. Это глобальная директория, загруженные в нее инструменты *CLI*  (пакеты?) будут доступны из любой директории.

С ключом `global` могут запускаться такие команды:

- `install`
- `remove`
- `require`
- `update`.

Глобальная установка пакета:

```bash
composer global require vendor/package
```

Теперь `vendor/package` установлен в глобальную директорию и *CLI* инструменты могут использоваться глобально. (Как пакеты использовать глобально не разобрался?).

Узнать местоположение глобальной директории и `bin` директории в нем:

```bash
$ composer global config home
C:/Users/Pavel/AppData/Roaming/Composer
$ composer global config bin-dir --absolute
C:\Users\Pavel\AppData\Roaming\Composer/vendor/bin
```

Запустить глобальное обновление:

```bash
composer global update
```

### Репозитории

Репозиторий – это то место, где лежит пакет. Для того чтобы пакет мог быть загружен через require (или require-dev), должен быть доступен репозиторий с этим пакетом.

В зависимости от того, где лежит пакет, требуются разные определения репозиториев. Всего есть 4 типа репозиториев: Composer, VCS, PEAR, Package. Репозитории добавляются через опцию repositories.

Когда Composer ищет пакет при require, он просматривает репозитории из массива repositories и использует первый репозиторий, где найден пакет.  Т.е. репозитории из repositories напрямую никак не связаны с пакетами из require. Репозиторий packagist просматривается последним и пользовательские репозитории могут переопределять пакеты из него. 

Директива repositories – root only, т.е. репозитории не подключаются рекурсивно (из-за технической сложности процесса).Поэтому нужно:

·      репозитории нужно вручную переопределить в корневом composer.json.

·      зависимость нужно вписать в корневой composer.json.

#### Пакет зарегистирован на packagist

Репозиторий Packagist, по умолчанию, уже зарегистрирован в Composer (как репозиторий с типом composer). Поэтому никаких репозиториев больше определять не надо. Просто подключаем пакет в опции require.

#### Пакет размещен в git, оформлен как Composer-пакет, но не зарегистрирован на packagist

Варианты использования:

·      почему-то пакет не зарегистрирован на packagist

·      собственный fork стороннего пакета.  Если в проекте используется сторонний пакет и в нем необходимо сделать какую-то правку, то делаешь fork этого пакета и правишь его у себя в fork. Если требуется загрузить какую-то конкретную ветку, то эта ветка указывается в том месте, где указывается версия, с префиксом dev-. Переименовывать пакет не требуется, т.е. так как пользовательский репозиторий, описанный в repository,  имеет приоритет над репозиторием в packagist.

В этом случае, необходимо определить репозиторий с типом vcs (или git).

{ 

​     "repositories": [ 

​          { 

​              "type":"vcs", 

​              "url":"https://github.com/igorw/monolog" 

​          } 

​     ],

​     "require": { 

​          "monolog/monolog" : "dev-master" 

​     }

}

#### Пакет не оформлен как Composer-пакет

Необходимо определить репозиторий с типом package.

В свойстве package репозитория нужно полностью самому описать пакет. Так, как это должно было сделать автор пакета в файле composer.json. Обязательно указываются name, version, autoload и dist или src. 

Указывать источник пакета можно в двух полях:

·      dist (distribution) – стабильный релиз

·      source – исходники, как правило ссылка на репозиторий в git.

Если указаны и dist и src, то приоритет выбора зависит от разных опций.

Пример репозитория из git. В опции autoload описаны правила автозагрузки – искать классы в файле timer.php.

{

​    "require":{

​        "pqr/superlib":"1.2.3"

​    },

​    "repositories":[

​        {

​            "type":"package",

​            "package":{

​                "name":"pqr/superlib",

​                "version":"1.2.3",

​                "source":{

​                    "type":"git",

​                    "url":"http://github.com/pqr/superlib",

​                    "reference":"master"

​                },

​                "autoload":{

​                    "classmap":["timer.php"],

​                }

​            }

​        }

​    ]

}

Пример репозитория из zip файла:

{

​    "repositories": [

​        {

​            "type": "package",

​            "package": {

​                "name": "smarty/smarty",

​                "version": "3.1.7",

​                "dist": {

​                    "url": "https://www.smarty.net/files/Smarty-3.1.7.zip",

​                    "type": "zip"

​                },

​                "source": {

​                    "url": "http://smarty-php.googlecode.com/svn/",

​                    "type": "svn",

​                    "reference": "tags/Smarty_3_1_7/distribution/"

​                },

​                "autoload": {

​                    "classmap": ["libs/"]

​                }

​            }

​        }

​    ],

​    "require": {

​        "smarty/smarty": "3.1.*"

​    }

}

## Readme.md

Файл [README.md](https://vk.com/away.php?to=http%3A%2F%2FREADME.md&cc_key=) выводится в качестве индексной страницы на github.com. Использует формат Markdown.

В файл помещают:

·      имя и описание пакета

·      инструкцию по установке и использованию

·      контактную информацию и сведения о лицензии

 

 

## Подключение автозагрузчика

Composer после установки пакетов генерирует файл vendor/autoload.php. В этом файле содержится автозагрузчик Composer, который автоматически подключает пакеты в проект. Этот файл нужно включить в проект вручную. 

require_once(__DIR__ . '/vendor/autoload.php');

 

 