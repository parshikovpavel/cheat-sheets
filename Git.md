https://guides.github.com/introduction/git-handbook/

https://git-scm.com/book/en/v2/Getting-Started-What-is-Git%3F

[https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%9E%D1%81%D0%BD%D0%BE%D0%B2%D1%8B-Git](https://git-scm.com/book/ru/v2/Введение-Основы-Git)

https://tproger.ru/translations/beginner-git-cheatsheet/

https://habr.com/ru/post/432420/

https://habr.com/ru/post/106912/

# Клонирование *github repo*

- Создать ключи:

  ```bash
  ssh-keygen -t rsa
  ```

  После это создаются файлы:

  ```
  ~/.ssh/id_rsa
  ~/.ssh/id_rsa.pub
  ```

- скопировать публичный ключ в буфер обмена

  ```bash
  pbcopy < ~/.ssh/id_rsa.pub
  ```

- вставить ключ на github

- клонировать репозиторий

  ```bash
  git clone git@github.com:AmirGhahrai/Rima.git
  ```

# Настройка

Настройка выполняется командой `git config`.

### Уровни настроек

Можно задавать три уровня настроек (*level*), которые сохраняются в трёх разных местах.

| Уровень      | Описание                                                     | Файл настроек    | Команда                                      |
| ------------ | ------------------------------------------------------------ | ---------------- | -------------------------------------------- |
| *System*     | Общие настройки для всех пользователей системы и для всех их репозиториев | `/etc/gitconfig` | `git config --system`                        |
| *User*       | Настройки для конкретного пользователя и для всего его репозиторием | `~/.gitconfig`   | `git config --global`                        |
| *Repository* | Настройки конкретного репозитория                            | `/.git/config`   | `git config --local` или просто `git config` |

Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в `.git/config` перекрывают соответствующие значения в `~/.gitconfig`.

### Установка настроек

Команда:

```bash
git config [--<level>] <name> <value>
```

Опции:

- `--level` – установить настройку на этом уровне

### Чтение конкретной настройки

```bash
git config [--<level>] <name>
```

Опции:

- `--level` – чтение настройки на этом уровне

### Чтение списка настроек

Команда:

```bash
git config --list [--<level>] [--show-origin]
```

Опции:

- `--level` – вывести настройки только этого уровня

- `--show-origin` – вывести файл, из которого взята настройка:

  ```
  file:/Users/pavelparshikov/.gitconfig   user.name=pavelparshikov
  file:.git/config        core.repositoryformatversion=0
  ```

### Стандартные настройки

#### `user.name`, `user.email`

Имя и адрес электронной почты. Они будут включены в каждый *commit*  и не могут быть изменены в нем.

```bash
git config --global user.name "pavelparshikov"
git config --global user.email "paw-p@yandex.ru"
```

#### `core.autocrlf`, `core.safecrlf`

Возможные значения: `core.autocrlf`

- `core.autocrlf = false` — значение по умолчанию (если `git config` ничего не возвращает). Git не изменяет окончания строк. Там могут быть разные окончания строк: `LF`, `CRLF`, `CR` или микс из всех них, но Гиту это будет безразлично. У большинства пользователей Unix/Linux установлено именно это значение, потому что у них нет проблем с `CRLF` и им не нужно, чтобы Гит делал дополнительную работу каждый раз при записи файлов в базу данных или в рабочую папку.
- `core.autocrlf = true` — значит, что Git обработает все текстовые файлы и убедится, что все `CRLF` заменены на `LF` перед записью в базу данных. При обратном процессе он преобразует все `LF` в `CRLF`. Такая установка гарантирует, что ваш репозиторий можно будет использовать на других платформах, сохраняя `CRLF` в вашем рабочей папке. Поэтому параметр `core.autocrlf = true` рекомендовано для Windows.
- `core.autocrlf = input` — значит, что Git обработает все текстовые файлы и убедится, что все `CRLF` изменены на `LF` при записи файлов в базу данных. Однако обратной замены не произойдёт. При записи файлов в рабочую папку из базы данных, для обозначения конца строки останутся `LF`. Этот параметр рекомендуется в Unix / Linux / OS X для предотвращения записи `CRLF` в репозиторий. Идея заключается в том, что если вы вставили код из браузера и случайно записали `CRLF` в один из ваших файлов, Git удостоверится, что произойдёт замена на `LF` при записи в базу данных.

Как же Гит определяет, что файл текстовый? У *Git*'а есть внутренний эвристический метод, который проверяет, двоичный ли файл. Если файл не двоичный, то *Git* считает его текстовым. Но *Git* иногда может ошибаться. Параметр `core.safecrlf` был создан на тот случай, если *Git* ошибётся и изменит окончания строк там, где лучше было бы оставить их в покое.

- `core.safecrlf = true` – перед записью в базу данных при подготовке к замене `CRLF` на `LF`, *Git* убедится, что сможет успешно прервать операцию. Он проверит, что можно откатить изменения (из `LF` в `CRLF`), а если нет, то отменит операцию.
- `core.safecrlf = warn` – сделает то же, что и предыдущий параметр, но вместо того, чтобы прервать операцию, Гит просто предупредит вас о том, что может случиться что-то нехорошее.

Рекомендуемые для Mac:

```
git config --global core.autocrlf input
git config --global core.safecrlf warn
```

# Commit

*Commit Id* (SHA-1 Id, Hash) – строка из 40 шестнадцатеричных цифр, например, `6f6b5997506d48fc6267b0b60c3f0261b6afe7a2`.

# Специальные файлы

## `.gitkeep`

В *Git* невозможно добавить пустую папку (директорию), поэтому среди разработчиков существует правило добавлять в пустые папки пустой файл с расширением `.gitkeep`.

Эта методика не является возможностью системы хранения (как, например, `.gitignore`), а лишь простой хак. 

# Branch

*Branch* может использоваться, если нужно развивать несколько релизов параллельно.





# Tag

*Tag* – идентифицирует *commit*, это как псевдоним для *hash*'а *commit*'а. Т.е. *tag* привязан к *commit*'у и не имеет прямой привязки какому-то *branch*'у. 

*Tag* часто создаются, чтобы пометить релизы. При этом *tag*'и могут создаваться в разных *branch*'ах, но *tag*'и не должны совпадать. Часто старой версией (например `php 7.0`),  кто-то пользуется и не горит желанием переходить на новые версии (например, потому что не проверил ее на совместимость со своим кодом). Но в старой версии обнаруживаются уязвимости и проблемы. Поэтому происходят изменения сразу в нескольких *branch*'ах, и сразу в нескольких *branch*'ах появляются новые релизы.

Например:

- в *branch*'е `7.0.1` – *tag*'ами помечаются релизы `7.0.1`, `7.0.2`, `7.0.3`, 
- а в другом *branch*'е `7.1` – *tag*'и помечают релизы `7.1.1`, `7.1.2`, ...

В *git* не принято думать о релизах. Вместо этого думают о фичах и багах. Под каждый баг/каждую фичу - свой *branch*. Как работа над ними заканчивается - *branch* вливается в основной *branch*.

В тот момент, как в *branch*'е появилась нужная функциональность и нет критических багов - создается *tag*.

Читать подробнее https://habr.com/ru/post/106912/

Поэтому не имеет смысла создавать нескольких *commit*'ов с одним *tag*'ом в разных *branch*'ах, это приведет к проблемам с их различением. Если необходимо использовать один и тот же *tag*-версию в разных *branch*'ах (например, `1.0.0`), необходимо в каждом *branch*'е использовать свой префикс (например, `prod-`)

Можно создать теги двух видов:

- аннотированные тег (*annotated tag*) – содержит сообщение, и имя и почту автора тега, как при *commit*

  ```bash
  git tag -a <tagname> -m <message>
  git tag -a 0.0.1 -m "initial version 0.0.1"
  ```

- легковесный тег (*lightweight tags*) – тег без дополнительной информации.

  ```bash
  git tag <tagname>
  git tag 0.0.1
  ```

При этом *tag* будет присвоен к самому последнему *commit*'у текущего *branch*'а. Если нужно присвоить *tag* *commit*'у в другом *branch*'е, то нужно на этот *branch* переключиться. 

Можно присвоить *tag* *commit*'у в любом *branch*'е, напрямую ссылаясь на его SHA1:

```bash
git tag v1.0 <sha1>
```



Просмотр уже созданных тегов:

```bash
$ git tag
0.0.1
```

Просмотр информации о теге:

```bash
$ git show <tagname>
$ git show 0.0.1
tag 0.0.1
Tagger: pparshikov <paw-p@yandex.ru>
...
```

По умолчанию, `git push` не отправляет метки в удаленный репозиторий. Необходимо явно  сделать *push* меток. Возможны два варианта:

- *push* конкретного тега в удаленный репозиторий:

  ```bash
  git push origin <tagname>
  git push origin 0.0.1
  ```

- push всех тегов в удаленный репозиторий:

  ```bash
  git push origin --tags
  ```

# `git checkout`

https://ru.stackoverflow.com/questions/431520/%D0%9A%D0%B0%D0%BA-%D0%B2%D0%B5%D1%80%D0%BD%D1%83%D1%82%D1%8C%D1%81%D1%8F-%D0%BE%D1%82%D0%BA%D0%B0%D1%82%D0%B8%D1%82%D1%8C%D1%81%D1%8F-%D0%BA-%D0%B1%D0%BE%D0%BB%D0%B5%D0%B5-%D1%80%D0%B0%D0%BD%D0%BD%D0%B5%D0%BC%D1%83-%D0%BA%D0%BE%D0%BC%D0%BC%D0%B8%D1%82%D1%83

Обозначим начальную ситуацию на следующей схеме:

```
               (i) (wt)
A - B - C - D - ? - ?
            ↑
          master
          (HEAD)
```

`A`, `B`, `C`, `D` — *commits* в ветке `master`.
`(HEAD)` — местоположение указателя HEAD.
`(i)` — состояние индекса Git. Если совпадает c `(HEAD)` - пуст. Если нет - содержит изменения, подготовленные к следующему *commit*.
`(wt)` — состояние рабочей области проекта (*working tree*). Если совпадает с `(i)` — нет неиндексированных изменений, если не совпадает — есть изменения.
`↑` обозначает *commit*, на который указывает определенная ветка или указатель.

## Временно откатиться на некоторое состояние

Чтобы просмотреть файлы в состоянии, на которое указывает некоторый *tag* или *commit*, то можно временно откатиться к некоторому *tag* или *commit*, с помощью команды:

```
git checkout <tagName>
git checkout 0.0.1
git checkout <commitHash>

 (wt)
 (i)
  A - B - C - D
  ↑           ↑
(HEAD)    master
```

После этой команды репозиторий находится в состоянии *«detached HEAD»*. Чтобы переключиться обратно, используйте имя ветки (например, `master`):

```
git checkout master
```

## Создать новую ветку в некотором состоянии

Чтобы создать новую ветку в состоянии, на которое указывает некоторый *tag* или *commit*, используем команду:

```
git checkout -b <branchName> <tagName>
git checkout -b testBranch 0.0.1
git checkout -b <branchName> <commitHash>

  (wt)
  (i)
   A - B - C - D
   ↑           ↑
newBranch   master
 (HEAD)
```

 

Еще есть по ссылке





## Создание локальной ветки и привязка ее к удаленной

git checkout -b pparshikov_6374 remotes/origin/pparshikov_6374

 

https://habr.com/ru/post/157175/

# `git cherry-pick`

Перенести *commit* из одной *branch* в другую.

Применить последний *commit* из ветки `<branch>` в текущую ветку:

```bash
git cherry-pick <branch>
```

Применить *commit* с указанным `<hash>` в текущий *branch*:

```bash
git cherry-pick <hash>
```

Можно аналогично применить несколько *commit*'ов c  `<hash_1>`, `<hash_2>`,...

```bash
git cherry-pick <hash_1> <hash_2> ...
```

Применить несколько подряд идущих *commit*'ов от  `<hash_begin>`, `<hash_end>`,...

```bash
git cherry-pick <hash_begin>..<hash_end>
```



# `git log`

История *commit*'ов.

# `git merge` и `git rebase`

`git merge` и `git rebase` предназначены для одной задачи – для интеграции изменений из одной *branch* в другую. Но используют разные алгоритмы.

## `git merge`

Команда принимает содержимое *source branch* и объединяет их с *target branch*. В этом процессе изменяется только *target branch*. Все *commit*'s *source branch*  крепятся в конец *target branch*. История *source branch* остается неизменной.

Будет создан новый «*Merge commit*» в *target branch*, который содержит историю обеих *branch*'es.

Пример: *merge* `master` *branch* в `feature` *branch*.

```bash
$ git checkout feature
$ git merge master
```

![merge](https://parshikovpavel.github.io/img/git/merge.png)

<u>Плюсы</u>:

- простота;
- сохраняет полную историю и хронологический порядок;
- поддерживает контекст ветки.

<u>Минусы</u>:

- история коммитов может быть заполнена (загрязнена) множеством коммитов;

Use case:

- `git merge` используется для мержа фич и фиксов в `master` ветку

## `git rebase`

Интегрирует *source branch* в *target branch*. Как собачка на молнии, "сшивает" *commit*'s по дате их создания
(*source branch* "растворяется" в *target branch*). Сжимает *source branch* в один *patch* (???).

*Rebase* перезаписывает историю, потому что он передает *commit*'s из одной *branch* в другую. В процессе устраняется нежелательная история.

Если вы сделаете *rebase* неправильно, история изменится, а это может привести к серьезным проблемам, поэтому убедитесь в том, что делаете!

Пример: *Rebase* `feature` *branch* в `master` *branch*. Создаются новые *commit*'s для каждого *commit* в `master` *branch*..

```bash
$ git checkout feature
$ git rebase master
```

![merge](https://parshikovpavel.github.io/img/git/rebase.png)

<u>Плюсы</u>:

- Упрощает потенциально сложную историю
- Исключение многих *merge commit* в перегруженных *branch*.

<u>Минусы</u>:

- Сжатие фич до нескольких коммитов может скрыть контекст.

<u>Use case</u>:

- Для синхронизации с *master branch*, в которую коммитят все разработчики проекта, Это полезно когда кто-то изменил участок кода с которым ты сейчас работаешь в своей *branch*, дабы через неделю ты смог без проблем сделать *merge* с *master branch*. Обычно делается каждое утро перед началом рабочего дня и в конце когда фича готова.

# `git squash`

????



# Подмержить мастер

```
git checkout BX-12345
git pull origin master
```

Если открывается vim, то нужно:

1. Нажать `i` (*insert*)
2. Напечатать message (возможно не обязательно???)
3. Нажать `esc` (*escape*)
4. Напечатать `:wq` (*write & quit*)
5. Нажать `Enter`







# Откат *commit*'а

Алгоритм:

- Сделать `reset --hard` до нужного *commit*'а:

  ```bash
  git reset --hard e9c99799095
  ```

  или в PHPStorm в `Git log → Reset current branch to Here`

- Сделать `push --force`:

  ```bash
  git push --force origin <branchName>
  ```

- при необходимости снова подмержить `master`:

  ```bash
  git ...
  ```

  

#  Просмотр Тегов в логах

Вы также можете посмотреть теги в логе.

#### ВЫПОЛНИТЕ:



```
git hist master --all
```

#### РЕЗУЛЬТАТ:



```
$ git hist master --all
* fa3c141 2011-03-09 | Added HTML header (v1, master) [Alexander Shvets]
* 8c32287 2011-03-09 | Added standard HTML page tags (HEAD, v1-beta) [Alexander Shvets]
* 43628f7 2011-03-09 | Added h1 tag [Alexander Shvets]
* 911e8c9 2011-03-09 | First Commit [Alexander Shvets]
```

Вы можете видеть теги (`v1` и `v1-beta`) в логе вместе с именем ветки (`master`). Кроме того `HEAD` показывает коммит, на который вы переключились (на данный момент это `v1-beta`).



# TODO

- Посмотреть как работает `git rebase` и как через него исправить историю *commit*'ов

 





Котеров

пример команд для инициализации git-репозитория компонента ISPager:

$ git add .

$ git oosssit -am "Initialize ISPager"

$ git ranote add origin gitegithub.ooe:igorsimdyanov/pager .git $ git push -u origin master

 

 

Теперь любой желающий может клонировать проект при помощи команды $ git clone https://github.ocn/igorsiaclyanov/pager.git

Версия пакета назначается автоматически, путем выставления метки или тега в системе контроля версий Git (см. главу 54). Например, назначить версию 1.0.0 можно при помощи следующего набора команд:

$ git tag -a vl.0.0 -v 'Version 1.0.0'

$ git push origin vl.0.0

 

 

Разобраться как:

перенести коммит из одной ветки в другую?

