# Конфигурирование

Go – компилирующий язык.

Запуск сервера с документацией:

```bash
godoc -http=:8000
```

Сборка программ на языке Go выполняется в два этапа: 

- компиляция
- компоновка.

Стандартный компилятор языка Go называется `gc`, в состав его инструментов входят программы: 

- `5g`, `6g` и `8g` – для компиляции
- `5l`, `6l` и `8l` – для компоновки 
- `godoc` – для просмотра документации.

Инструмент сборки программ `go` автоматически выбирает нужный компилятор и компоновщик и выполняет:

- собирает локальные программы и пакеты
- загружает, собирает и устанавливает сторонние программы и пакеты.

Программы записываются в виде текста на UTF-8. Все ключевые слова и операторы языка Go записываются символами ASCII, однако идентификаторы в языке Go могут начинаться с любых алфавитных символов *Unicode* и содержать любые алфавитные символы *Unicode* или
цифры. Поэтому идентификаторы могут определяться на любом языке (в том числе русском).

## Создание сценариев на Go

Существует возможность создания сценариев на Go, начинающихся со строки `#!` ([shebang]()). Для этого необходимо использовать инструмент для
компиляции и запуска программ. Возможные варианты:

- `gonow` (`github.com/kless/gonow`)
- `gorun` (`wiki.ubuntu.com/gorun`)

Чтобы создать сценарий на Go необходимо:

- добавить строку `#!/usr/bin/env gonow` или `#!/usr/bin/env gorun` в начало файла с расширением `.go`, содержащем функцию `main()` (в пакете `main`). 
- дать файлу права на выполнение (`chmod +x`).

При первом запуске команда `gonow` или `gorun` скомпилирует файл с расширением `.go` и запустит его. 

При последующих запусках перекомпиляция будет выполняться, только если исходный файл `.go` изменился с момента предыдущей компиляции.

Такие сценарии удобны для решения задач системного администрирования.

## Environment variable's

### `GOROOT`

Если инструмент для сборки программ `go` выдает ошибку:

```bash
go version
```

то необходимо в файле `~/.bash_profile`:

```bash
export GOROOT=/usr/local/opt/go/libexec # 1. Создать environment variable, содержащую путь 
                                        #    к каталогу установки Go
export PATH=$PATH:$GOROOT/bin           # 2. В переменную PATH включить путь $GOROOT/bin
```

### `GOPATH`

Чтобы обеспечить сборку локальных программ и пакетов с помощью инструмента `go`, необходимо:

- каталог `bin` с инструментами языка Go (`$GOROOT/bin`) должен находиться в `PATH`.
- в дереве каталогов должен существовать каталог `src` для хранения исходных текстов локальных программ и пакетов. Например, `goeg/src/hello`. 
- Путь к каталогу, вмещающему каталог `src`, должен быть включен в `GOPATH` *environment variable* .

```bash
export GOPATH=$HOME/repos/goeg
```

Если нужно хранить программы в нескольких каталогах, то в `GOPATH` *environment variable* можно вписать несколько путей к каталогам, разделенных двоеточием:

```bash
export GOPATH=$HOME/app/go:$HOME/goeg
```



## Сборка программы

### `go build`

Сборка программы и размещение исполняемого файла в каталоге с исходным кодом. По умолчанию, выполняемый файл получает имя каталога, в который он помещается (например, `hello`)

```bash
$ cd ~/repos/goeg
$ go build
```

### `go install`

*Compile* и *install* программу. При этом программа помещается в каталог:

- по пути `GOBIN` *environment variable*
- если `GOBIN` не установлена, то по пути `$GOPATH/bin`. Если в `GOPATH` вписано несколько каталогов, то будет найден соответствующий каталог в `GOPATH` и программа будет сохранена в соответствующем каталоге `bin`.

Таким образом, различные скомпилированные программы помещаются в один и тот же каталог. Можно включить путь к этому каталогу в `PATH`:

 ```bash
export PATH=$PATH:$GOPATH/bin
 ```

### `go run`

запуск программы с компиляцией во временную папку

```
go run <package>
```

Компилирует и исполняет указанный *main* (?) пакет `<package>`. 

- `package` – может задаваться, как:
  - список исходных файлов `.go` из одного каталога
  - *import path* (?)
  - путь в файловой системе
  - шаблон, соответствующий одному известному пакету (?). Например, , как в случае «иди, беги». или «запустите мой / cmd».

## Запуск программы

Запуск программы:

```bash
./hello
```

# Типизация

Язык Go использует строгую типизацию. Это не позволяет, например, сложить значения типов `int32` и `int16` без явного их преобразования.

# Declarations и scope

## Объявление *variable*

Виды объявлений:

- *Short variable declaration* (сокращенное объявление переменной). Одновременно объявляет и инициализирует переменные. 

  ```go
  a := "b"; // Без указания типа
  a := string("b") // С указанием типа
  ```

- Полная форма объявления.

  ```go
  var a = "b"; // Без указания типа
  var a string = "b" // С указанием типа
  ```

Указание типа переменной:

- можно не указывать, в этом случае компилятор Go автоматически определит его по присваиваемому значению. 

  В этом случае переменная `a` будет иметь тип `string`:

  ```go
  a := "b"; // Сокращенная форма
  ```

- можно указывать:

  ```go
  a := string("World!") // Сокращенная форма
  ```



После объявления переменной (с указанием типа или автоматическим определением типа), в следствие строгой типизации, ей могут присваиваться значения только того же типа.



## Объявление *type*

В Go отсутствуют такие понятия, как классы и наследование (отношение IS-A). В языке Go поддерживается
возможность определения пользовательских *type*'s и чрезвычайно простой способ агрегации типов (отношение Has-A).




# Literal и constant

Literal (литерал) – это представление *constant*'ы (константы). 

*Constant*'e можно явно присвоить тип при объявлении *constant*, объявлении *variable*, как *operand* в *expression* и т.д. Если *constant*'а не может быть представлена с помощью указанного типа, то выбрасывается ошибка.

У *constant*'ы есть тип *by default*, в который *constant*'а неявно преобразуется, когда требуется значение с явно определенным типом, например *short variable declaration*  `i := 0`. 

Типы *constant* *by default*:

- *boolean* – `bool`
- *rune* – `rune`
- *integer* – `int`
- *floating-point* – `float64`
- *complex* – `complex128`
- *string* – `string`

### Rune literal

Rune literal (строковый литерал) – *integer value*, которое задает *Unicode code point*. Записывается в *single quote*'s, например, `'x'`или `'\n'`. 

По умолчанию, *rune literal* приводится к типу `rune` (псевдоним для `int32`).

```go
tst := 'a'
fmt.Println(reflect.TypeOf(tst)) // int32
```

Однако может быть приведено к любому *integer type*, необходимо чтобы значение поместилось в этот integer type:

```go
var a byte

a = 'w'  // OK
a = 'ц'  // constant 1094 overflows byte
```





## Типы данных

### `string`

Строки – *immutable* (неизменяемы): после создания невозможно изменить содержимое строки.

Строки хранятся в кодировке UTF-8 и символы строки могут быть представлены двумя и более байтами. 

При обращении к определенной позиции в строке по индексу `str[1]` возвращается байт (тип `byte`), хранящийся в этой позиции. 



### Числовые типы

```
uint8       the set of all unsigned  8-bit integers (0 to 255)
uint16      the set of all unsigned 16-bit integers (0 to 65535)
uint32      the set of all unsigned 32-bit integers (0 to 4294967295)
uint64      the set of all unsigned 64-bit integers (0 to 18446744073709551615)

int8        the set of all signed  8-bit integers (-128 to 127)
int16       the set of all signed 16-bit integers (-32768 to 32767)
int32       the set of all signed 32-bit integers (-2147483648 to 2147483647)
int64       the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807)

float32     the set of all IEEE-754 32-bit floating-point numbers
float64     the set of all IEEE-754 64-bit floating-point numbers

complex64   the set of all complex numbers with float32 real and imaginary parts
complex128  the set of all complex numbers with float64 real and imaginary parts

byte        alias for uint8
rune        alias for int32

uint     either 32 or 64 bits
int      same size as uint
uintptr  an unsigned integer large enough to store the uninterpreted bits of a pointer value
```

## Operator

### `++`, `--`

В отличие от C++, операторы `++` и `—` могут использоваться только как оператор, но не как выражение. 

```go
a++
```

Они могут применяться лишь в постфиксной форме. Это предотвращает появление проблем, связанных с неправильным порядком вычислений.

### Конкатенация `string`

`string` можно конкатенировать с помощью оператора `+` или оператора присваивания `+=`:

```
s := "hi" + " "
s += "and good bye"
```

В результате будет создана новая строка (т.к. строки *immutable*).

## Statement

Блоки программного кода заключаются в фигурные скобки:

- тело функций 

  ```go
  func main() {
  	// ...
  }
  ```

- тело управляющих конструкций:

  ```go
  if ... { 
      //...
  }
  ```

Отступы используются исключительно для удобства человека.

При разделении операторов:

- можно использовать точку с запятой `;`. Обязательно, если в одной строке располагается несколько инструкций

  ```go
  a := 1;
  ```

- можно не использовать точку с запятой `;`. Тогда они автоматически будут добавлена компилятором.

  ```go
  a := 1
  ```

### `if`

Условное выражение в инструкции `if` можно не заключать в круглые скобки:

```go
if a > 1 { 
	// ...    
}
```



### `for`

Формы цикла `for`:

- c `range` *clause*. Итерирует все элементы *array*, *slice*, *string* или *map* или значений, полученных по *channel*. Для каждого элемента присваивает *variable*'s (может быть несколько переменных в `IdentifierList`) некоторые *value*'s, зависящие от типа `Expression`, а затем выполняет блок.

  ```go
  RangeClause = [ ExpressionList "=" | IdentifierList ":=" ] "range" Expression .
  for a := range slice {
      // ...
  }
  ```

  Значения *value*'s зависящие от типа `Expression` следующим образом:

  ```
  Range expression                          1st value          2nd value
  
  array or slice  a  [n]E, *[n]E, or []E    index    i  int    a[i]       E
  string          s  string type            index    i  int    see below  rune
  map             m  map[K]V                key      k  K      m[k]       V
  channel         c  chan E, <-chan E       element  e  E
  ```

  

- с *for clause*. Стандартная форма для C++ и PHP:

  ```go
  ForClause = [ InitStmt ] ";" [ Условие ] ";" [ PostStmt ].
  for i := 0; i < 10; i++ {
  	// ...
  }
  ```

  





## Область видимости

Область видимости при использовании оператора сокращенного объявления переменной `:=`  – ограничена блоком. 

Например, здесь область видимости переменной ограничена телом инструкции `if`:

```go
if <condition> {
    variable := "value"
}
```





## Комментарии

Комментарии оформляются в стиле языка C++: 

```go
// Однострочные комментарии, заканчивающиеся в конце строки

/* Блочные комментарии, занимающие несколько
строк 
*/
```

## Package

### Определение package

Любой фрагмент программного кода должен быть включен в *package* (пакет).

Каждая программа должна иметь `main` *package* с функцией `main()` , которая является точкой входа в программу:

```go
package main

func main() {
	// ...    
}
```

Функция `main()` всегда не имеет аргументов и ничего не возвращает. Когда функция `main.main()` завершается, одновременно с ней
завершается выполнение программы, и она возвращает операционной системе значение 0.

Также можно использовать функцию `init()`, которая выполняется перед функцией `main()`.

Язык Go оперирует в терминах *package*'s, а не файлов. То есть *package* можно разбить на любое количество файлов, и если все они будут иметь одинаковое объявление `package`, то все они будут являться частями одного и того же *package*, как если бы все их содержимое находилось в единственном файле.

### Import package

Импортирование package: 

```go
import (
    "fmt"
    "os"
    "strings"
)
```

Импортируемые пакеты можно не отделять друг от друга запятыми.





## Пользовательские типы данных

Имеется возможность определять пользовательские типы данных, опираясь на фундаментальные типы. А также определять функции для работы с ними.



## Функции

Функции и методы в языке Go определяются с помощью ключевого слова `func`. 

```go
func a() {
	//...
}
```



## Коллекции

Типы коллекций:

- *array* (массив)
- *slice* (срез)



### Slice

Определение одномерного *slice*:

```go
[]Тип        // без инициализации
[]Тип{1,2,3} // с инициализацией
```

```go
a := []string{"1", "2", "3"} // сокращенная форма
var b = []int{2, 3, 5}       // полная форма
```

Размер *slice* указывать не нужно, компилятор сам может подсчитать количество элементов.

Чтобы определить многомерную коллекцию, необходимо в качестве `Тип` указать коллекцию:

```go
[][]Тип
```

```go
var bigDigits = [][]string{
    {"1","2","3"},
    {"4","5","6"},
}
```







### Функции

#### `len()`

Возвращает длину среза:

```go
len(os.Args)
```

### Обращение к элементам

Аналогично другим языкам, получение n-го элемента среза:

```go
slice[n]
```

Получение среза, содержащего с `n`-го по последний элемент.

```go
slice[n:]
```



## Инициализация программы и исполнения

### Инициализация пакета

Порядок объявлений и определений в общем случае не имеет большого значения. 

Переменная может быть объявлена:

- как до ее использования:

  ```go
  var a = 1
  
  func main() {
      fmt.Print(a)
  }
  ```

- так и после ее использования:

  ```go
  func main() {
      fmt.Print(a)
  }
  
  var a = 1
  ```

  







# Standard library

Фундаментальные типы данных в языке Go поддерживают привычные операторы (`+`, `-`,...), а стандартная библиотека Go добавляет дополнительные пакеты функций для работы с фундаментальными типами (например, `string`). 

При использовании в коде *package*, который логически включен в другой *package* (например, `path/filepath`) необходимо указывать только последний компонент их имени (например, `filepath`).

## `builtin`

Встроенные функции, которые являются частью языка.

### `len`

Возвращает длину `v`:

```go
func len(v Type) int
```

Результат:

```
Array: число элементов в v.
Pointer to array: число элементов в *v (даже если v = nil).
Slice, or map: число элементов в v; если v = nil, len(v) - 0.
String: число byte's в v.
Channel: the number of elements queued (unread) in the channel buffer;
         if v is nil, len(v) is zero.
```





## `fmt`

`fmt` – *formatted* (форматированный). 

*Package* реализует форматированный I/O по аналогии с функциями `printf()` и `scanf()` в Си. 

Некоторые функции принимают `format`, в котором можно использовать спецификаторы формата `%`, напоминающие спецификаторы функций `printf()` и `scanf()` в Си.



### `fmt.Println()`

```go
func Println(a ...interface{}) (n int, err error)
```

Делает вывод операндов в *standart output* в *default* формате. Между операндами всегда добавляются *space* и *newline*. 

- `n` – количество записанных байтов
- `err` – все обнаруженные ошибки записи.

### `fmt.Printf()`

```go
func Printf(format string, a ...interface{}) (n int, err error)
```

Делает вывод операндов в *standart output* в соответствии с форматом `format`. 

- `n` – количество записанных байтов
- `err` – все обнаруженные ошибки записи.



## `log`

*Package* `log`  реализует функции логгирования. Функции пишут в *standart error* и печатают дату и время каждого сообщения. Каждое сообщение выводится в отдельной строке: если сообщение не заканчивается *newline*, функции ее добавят. 

Функции *Fatal* вызывают `os.Exit (1)` после вывода сообщения.

### `log.Fatal()`

```go
func Fatal (v ... interface {})
```

`log.Fatal()` эквивалентен `log.Print()` + вызов `os.Exit (1)`.

### `log.Fatalf()`

```go
func Fatalf(format string, v ...interface{})
```

`log.Fatalf()` эквивалентен `log.Printf()` + вызов `os.Exit (1)`.

### `log.Print()`

```
func Print(v ...interface{})
```

`log.Print()` вызывает `log.Output` для печати в стандартном *logger*'е (?). 

## `os`

*Package* содержит функции для выполнения различные действия в операционной системе. Эти функции устраняют различия платформ (Unix, MacOS, ...).

### `os.Args`

Хранит аргументы командной строки, начиная с имени программы

```go
var Args []string
```



## `strings`

Содержит функции для работы со строками.





## `path`

*Package* включает функции для управления путями, разделенными *slash* `/`. *Package* следует использовать для путей в URL-адресах.

Этот *package* не следует использовать для работы с путями файловой системы (в первую очередь, разделенными *backslash* `\` и содержащими букву диска `C:\`, как в Windows). Для управления ими необходимо использовать пакет `path/filepath`.

### `path/filepath`

*Package* включает функции для управления путями файловой системы. При этом учитываются особенности файловой системы (какие слэши используются для разделения).

*Package* не следует использовать для путей в URL-адресах.

#### `filepath.Base()`

Возвращает последний (базовый) элемент пути (имя файла или имя директории) в пути файловой системы.

```go
func Base(path string) string
```

## `reflect`

### `TypeOf()`

Возвращает тип `i`. 

```go
func TypeOf(i interface{}) Type
```

```go
tst := 'a'
fmt.Println(reflect.TypeOf(tst))
```









Go

* компилируемый язык
Павел
Павел 13:20

* имеет сборщик мусора

но он съедает в момент работы 1мс

* CSP-style, асинхронная модель, возможность в процессе выделять потоки и писать параллельные программы (аналог OpenMP)
Павел
Павел 19:26

* на выходе получаем готовый бинарник без зависимостей, которые надо было бы скачивать менеджером зависимостей


Павел
Павел 19:54

* указывается тип переменной, типы переменных не динамические, и поэтому нет оверхеда по памяти на хранение типа.
Павел
Павел 20:32

обеспечивается возможность полного отделения
типов данных от их поведения и поддерживается динамическая
(или так называемая утиная) типизация. Динамическая (утиная)
типизация – мощный механизм абстракций, позволяющий обраба-
тывать значения (например, передаваемые функциям) с помощью
предоставляемых ими методов, независимо от их фактических ти-
пов.

встроен-
ных фундаментальных типов, обозначаемых такими ключевыми
словами, как bool, int и string, или составных типов, обозначаемых
ключевым словом struct1.

именованные, так и неименованные поль-
зовательские типы
. Неименованные типы с одинаковой структурой
можно использовать взаимозаменяемо, однако они не могут иметь
методы. (Более подробно эта тема обсуждается в §6.4.) Любой име-
нованный пользовательский тип может иметь методы, и эти методы
составляют интерфейс типа. Именованные пользовательские типы,
даже с одинаковой структурой, не могут использоваться взаимо-
заменяемо. (Далее в этой книге под термином «пользовательские
типы» будут подразумеваться именованные пользовательские типы,
если явно не будет указано иное.)