# `io`

*Package* `io` предоставляет базовые *interface*'s для I/O примитивов. Его основная задача – обернуть существующие реализации таких примитивов, например *package* `os`, в общие *interface*'s, которые абстрагируют функциональность. 

Также доступны некоторые связанные с ними примитивы (например, `Copy()`)

Поскольку эти *interface*'s и примитивы оборачивают в себе операции низкого уровня с различными реализациями, клиенты не должны предполагать, что они безопасны для параллельного выполнения, если не проинформированы об этом явно.



# Структура

## Function

### `ReadAll()`

```go
func ReadAll(r Reader) ([]byte, error)
```

`ReadAll()` читает от `r` до *error* или `EOF` и возвращает прочитанные данные. Успешный вызов возвращает `err == nil`, а не `err == EOF`. Поскольку `ReadAll()` предназначен для чтения из `src` до `EOF`, он не считает `EOF` из `Read()` ошибкой, о которой нужно сообщить.

### `WriteString()`

```go
func WriteString(w Writer, s string) (n int, err error)
```

`WriteString()` пишет содержимое `s` в `w`, который принимает *slice of byte*'s. Если `w` реализует `type StringWriter`, его метод `WriteString()` вызывается напрямую. Иначе `w.Write()` вызывается ровно один раз.

```go
package main

import (
	"io"
	"log"
	"os"
)

func main() {
	if _, err := io.WriteString(os.Stdout, "Hello World"); err != nil {
		log.Fatal(err)
	}

}
```



## Type

### `type Reader`

```go
type Reader interface {
	Read(p []byte) (n int, err error)
}
```

`type Reader` – это *interface*, который оборачивает базовый метод `Read()`.

`Read()` читает до `len(p)` *byte*'s в `p`. Он возвращает количество прочитанных *byte*'s (`0 <= n <= len(p)`) и любую обнаруженную *error*. Даже если `Read()` возвращает `n < len(p)`, он может использовать весь `p` как временное пространство во время вызова. Если доступны некоторые данные, но нет полного количества *byte*'s `len(p)` для заполнения `p` целиком, `Read()` обычно возвращает те *byte*'s, которые доступны сейчас и не ждет дополнительных.

Когда `Read()` обнаруживает *error* или EOF (end-of-file) состояние после успешного чтения `n > 0` *byte*'s, он возвращает количество прочитанных *byte*'s. Он может вернуть *(non-nil) error* из того же вызова или вернуть *error* (и `n == 0`) из последующего вызова. 

В частности, если `Reader` возвращает ненулевое количество *byte*'s в конце входного потока, то:

- может возвращать `err == EOF`

- либо `err == nil`. Следующее чтение должно вернуть `0, EOF`.

  Пример этого поведения:

  ```go
  func main() {
  	a := "1"
  	b := []byte(a)
  	c := bytes.NewReader(b)
  
  	d := make([]byte, 5)
  
  	var err error
  
  	for err == nil {
  		var n int
  		n, err = c.Read(d)
  
  		fmt.Println(d, n, err)
  	}
  }
  
  // Output:
  // [49 0 0 0 0] 1 <nil>
  // [49 0 0 0 0] 0 EOF
  ```

*Caller* должен всегда обрабатывать возвращенные `n > 0` *byte*'s, прежде чем обрабатывать *error* `err`. Это позволяет корректно обрабатывать *I/O error*, которые возникают после чтения некоторого количества *byte*'s, а также оба допустимых поведения `EOF`.

Реализациям `Read()` не рекомендуется возвращать нулевое количество *byte* с `err = nil`, кроме случаев, когда `len(p) == 0`. *Caller* должен рассматривать возврат `0, nil` как указание на то, что ничего не произошло; в частности, это не указывает на `EOF`.

Реализации не должны сохранять (??? куда-то к себе) `p`.

`Discard` — это `Writer`, такой что все вызовы `Discard.Write()` завершаются успешно, ничего не делая.

```go
var Discard Writer = discard{}
```



### `type Writer`

```go
type Writer interface {
	Write(p []byte) (n int, err error)
}
```

`Writer` — это *interface*, который оборачивает базовый метод `Write()`.

`Write()` записывает `len(p)` байтов из `p` в *underlying data stream*. Он возвращает *number of bytes*, записанных из `p` (`0 <= n <= len(p)`) и любую возникшую `error`, из-за которой *write* была остановлена досрочно. `Write()` должен вернуть *non-nil error*, если он возвращает `n < len(p)`. `Write()` не должен модифицировать *slice data*, даже временно.

Реализации не должны сохранять (????наверно, куда-то к себе) `p`.