# Консоль

Основная папка `/usr/local/opt/mysql@5.7/`

## Сервер

- Старт –`/usr/local/opt/mysql@5.7/bin/mysql.server start`
- Стоп – `/usr/local/opt/mysql@5.7/bin/mysql.server stop`
- Рестарт – `/usr/local/opt/mysql@5.7/bin/mysql.server restart`

https://habr.com/ru/post/217245/





## Термины

### CRUD

*CRUD* (*create, read, update, delete*) — акроним, обозначающий четыре базовые функции, используемые при работе с персистентными хранилищами данных.

Функциям *CRUD* в языке *SQL* сопоставляются базовые операторы, в протоколе *HTTP* и интерфейсах *RESTfull API* – *HTTP methods*.

| Операция                | Оператор в языке SQL | Метод  в протоколе HTTP | Метод в архитектурном стиле REST |
| ----------------------- | -------------------- | ----------------------- | -------------------------------- |
| Создание (create)       | INSERT               | PUT / POST              | POST                             |
| Чтение (read)           | SELECT               | GET                     | GET                              |
| Редактирование (update) | UPDATE               | PUT / POST / PATCH      | PUT / PATCH                      |
| Удаление  (delete)      | DELETE               | DELETE                  | DELETE                           |

Методы *HTTP* не совсем точно ложаться на операции *CRUD*. Например, метод `PUT` можно отнести к функциям *create* и *update*, т.к. сервер создает новый ресурс по заданному *URI*, либо обновляет его – если ресурс по заданному *URI* уже существует. Т.е. метод `PUT` - это скорее функция *replace*.

## Установка

Установка MySQL:

```bash
brew install mysql[@5.7]
```

После установки MySQL можно выполнить постинсталляционную настройку с целью повышения безопасности сервера. Производится настройка пользователя `root`, анонимного пользователя и т.д.

```bash
sudo mysql_secure_installation
```



## Архитектура

Общие принципы:

·   MySQL - это приложение, запускаемое в один процесс. Процесс называется mysqld (от MySQL Daemon).

·   Он многопоточен.

·   Он выступает в качестве сервера, принимая соединения.

·   Каждое соединение получает выделенный поток.

·   Эти потоки иногда называются процессами, а иногда они называются соединениями.

На самом верхнем уровне содержатся службы, обеспечивают поддержку соединений, идентификацию, безопасность и т. п.

​                                

На втором уровне сосредоточена значительная часть интеллекта MySQL: синтаксический анализ запросов, оптимизация, кэширование и все встроенные функции (например, функции работы с датами и временем, математические функции, шифрование). На этом уровне реализуется любая независимая от подсистемы хранения данных функциональность, например хранимые процедуры, триггеры и представления.

Третий уровень содержит подсистемы хранения данных. Они отвечают за сохранение и извлечение всех данных, хранимых в MySQL. Подобно различным файловым системам

GNU/Linux, каждая подсистема хранения данных имеет свои сильные и слабые стороны. Сервер взаимодействует с ними с помощью API подсистемы хранения данных. Этот интерфейс скрывает различия между подсистемами хранения данных и делает их почти прозрачными на уровне запросов. Кроме того, данный интерфейс содержит пару десятков низкоуровневых функций, выполняющих операции типа «начать транзакцию» или «извлечь строку с таким первичным ключом». Подсистемы хранения не производят синтаксический анализ.

В системах, которые имеют дело с совместным доступом на чтение/запись, обычно реализуется набор блокировок, делящихся на два типа. Эти блокировки обычно называют разделяемыми блокировками и монопольными блокировками или блокировками чтения и блокировками записи. MySQL запрещает одному клиенту считывать данные, когда другой клиент их изменяет.

Основной стратегией блокировки в MySQL, дающей наименьшие накладные расходы (получение, проверка, освобождение), является табличная блокировка . Блокировки таблицы READ LOCAL разрешают некоторые типы одновременных операций записи. Также блокировки записи имеют более высокий приоритет, чем блокировки чтения, поэтому запрос блокировки записи бу

дет помещен в очередь перед уже имеющимися запросами блокировки чтения. СУБД MySQL также использует для различных целей разные блокировки, например, для таких команд, как ALTER TABLE, сервер применяет табличную блокировку вне зависимости от подсистемы хранения данных. Блокировка на уровне строк доступна в подсистемах InnoDB и Falcon. Блокировки строк реализуются подсистемами хранения данных, а не сервером.

## Транзакции

Транзакцией называется атомарная группа запросов SQL, т. е. которые рассматриваются как единое целое. Если подсистема базы данных может выполнить всю группу запросов, она делает это, но если любой из запросов не может быть выполнен в результате сбоя или по какой-то другой причине, не будет выполнен ни один запрос группы. Все или ничего.

Основные команды:

START TRANSACTION` `или` `BEGIN` – `начать новую транзакцию.

COMMIT` – `фиксирует текущую транзакцию, делая ее изменения постоянными.

ROLLBACK – Отменяет текущую транзакцию, отменяет ее изменения.

Режим AUTOCOMMIT

Режима AUTOCOMMIT оказывает влияние только на транзакционные таблицы. MySQL по умолчанию работает в режиме AUTOCOMMIT=1 – каждый запрос автоматически выполняется в отдельной транзакции, если этот запрос сам не является частью большой транзакции. Отключить режим AUTOCOMMIT можно:

·   START TRANSACTION отключает режим AUTOCOMMIT неявно для операторов внутри транзакции. После COMMIT или ROLLBACK autocommit возвращается в прежнее состояние.

·   вручную через команду AUTOCOMMIT=0. Выполнение любого запроса начинает транзакцию, которая завершается только вручную командой COMMIT или ROLLBACK. 

Опции START TRANSACTION:

·   READ WRITE и READ ONLY разрешают или запрещают изменения таблиц, используемых в транзакции. READ ONLY позволяет оптимизировать запросы для InnoDB таблиц.

ACID расшифровывается как Atomicity, Consistency, Isolation и Durability (атомарность, непротиворечивость, изолированность и долговечность). 

Атомарность Транзакция должна функционировать как единая неделимая единица работы таким образом, чтобы вся транзакция была либо выполнена, либо отменена. Когда транзакции являются атомарными, не существует такого понятия, как частично выполненная транзакция: все или ничего.

Непротиворечивость. База данных должна всегда переходить из одного непротиворечивого состояния в последующее.

Изолированность Результаты транзакции обычно невидимы другим транзакциям, пока она не закончена. При этом слишком дорого обеспечить полную невидимость, поэтому говорят обычно.

Долговечность Будучи зафиксированы, внесенные в ходе транзакции изменения становятся постоянными. 

### Уровни изоляции

Стандарт SQL определяет четыре уровня изоляции. 

С ростом уровня изоляции:

·   ¯ степень совместного доступа (concurrency) и количество проблем совместного доступа

·   ­ количество блокировок и накладные расходы на ожидание их освобождения

Возможны следующие проблемы:

·     потерянное обновление ([англ.](https://ru.wikipedia.org/wiki/Английский_язык) *lost update*) — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;

·     «грязное» чтение ([англ.](https://ru.wikipedia.org/wiki/Английский_язык) *dirty read*) — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не подтвердится (откатится);

·     неповторяющееся чтение ([англ.](https://ru.wikipedia.org/wiki/Английский_язык) *non-repeatable read*) — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;

·     фантомное чтение ([англ.](https://ru.wikipedia.org/wiki/Английский_язык) *phantom reads*) — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк. результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.

MySQL позволяет устанавливать уровень изоляции для всего сервера в конфигурационном файле или на уровне отдельного сеанса:

SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL READ COMMITTED;

 

Read uncommitted (чтение незафиксированных данных)

Низший уровень изоляции. Обеспечивает решение только проблемы «потерянных обновлений». На практике используется редко, поскольку его производительность ненамного выше, чем уровня выше.

Read committed (чтение фиксированных данных)

Уровень изоляции по умолчанию для большинства СУБД (но не для MySQL!). Обеспечивает решение тех же проблем, что и предыдущий уровень, плюс проблемы «грязное чтение».  

В InnoDB на этом уровне:

·   неблокирующее чтение (SELECT) – чтение производится из consistent snapshot, однако snapshot создается не на всю транзакцию, а только на один SELECT, т.е. возможна проблема «неповторяющееся чтение».

·   блокирующее чтение (SELECT ... LOCK IN SHARE MODE и SELECT ... FOR UPDATE) и изменения (UPDATE, DELETE) – блокируются только выбранные и измененные строки через record-lock. gap-lock и next-key lock не применяется.

Применяется, если нужно повысить concurrency за счет возможных проблем совместного доступа.

Repeatable read (повторяемость чтения)

Уровень изоляции по умолчанию для MySQL. Обеспечивает решение тех же проблем, что и предыдущий уровень, плюс проблемы «неповторяющееся чтение». В InnoDB также на этом уровне решена проблема «фантомного чтения».

В InnoDB это достигается с помощью:

·   неблокирующее чтение (SELECT) – чтение производится из consistent snapshot, неизменного на протяжении всей транзакции (MVCC). Такое чтение не ставит никаких блокировок.

·   блокирующее чтение (SELECT ... LOCK IN SHARE MODE и SELECT ... FOR UPDATE) и изменения (UPDATE, DELETE) – на прочитанные данные ставятся блокировки разных типов: record-lock, gap lock, next-key lock (смотреть Блокировки). gap lock, next-key lock позволяют избежать проблемы «фантомного чтения».

Serializable (упорядочиваемость)

Самый высокий уровень изоляции. Транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Соответственно большое количество блокировок и низкая степень concurrency. 

В InnoDB реализует все, что и предыдущий уровень. Плюс отстутствует неблокирующее чтение, запросы SELECT преобразуются в SELECT ... LOCK IN SHARE MODE с shared-lock.

Применяется, чтобы быстро превратить все запросы SELECT в SELECT ... LOCK IN SHARE MODE без изменения приложения (пример когда нужно чтение с shared-lock ниже).

### Блокировки

Все базы данных поддерживают механизм двухфазной блокировки (2PL) — это метод управления параллелизмом (Concurrency control), который гарантирует сериализуемость (serializability).

Выделяется две фазы:

·   Получение блокировок (acquire) – осуществляется в транзакции при выполнении блокирующих операций.

·   Освобождение/снятие блокировок (release) – осуществляется в транзакции при выполнении COMMIT или ROLLBACK.

Блокировка – системный объект, связанный с общим ресурсом (строка в базе данных, таблица), который:

·    применяется транзакцией 

·   НЕ блокирует доступ к этому ресурсу для других транзакций, А!!! блокирует другую транзакцию от приобретения другой блокировки на этом ресурсе. 

Блокировки могут быть:

·   совместимыми (compatible) – одна блокировка допускает другую одновременно

·   несовместимыми – одна блокировка не допускает другую одновременно. 

Типы блокировок:

·   разделяемая блокировка (shared lock). 

·   эксклюзивная блокировка (exclusive lock).

Таблица совместимости блокировок (где X – блокировки несовместимы):

| Lock type      | shared-lock | exclusive-lock |
| -------------- | ----------- | -------------- |
| shared-lock    |             | Х              |
| exclusive-lock | Х           | Х              |

Т.е. одновременно допускаются только две блокировки exclusive-lock.

Если запрашиваемая блокировка несовместима с уже существующей, то транзакция ставится в очередь ожидания для запрашиваемого объекта. Как только существующая блокировка снимается с объекта, то ставится следующая блокировка из очереди.

Устанавливаемые блокировки зависят от:

·   выполняемой операции:

o  просто SELECT

o  блокирующие варианты SELECT ... LOCK IN SHARE MODE и SELECT ... FOR UPDATE

o  UPDATE, DELETE, INSERT

·   уровня изоляции (REPEATABLE READ – по умолчанию)

·   просматриваемых в операции строк, которые зависят от установленных индексов. Поэтому правильный выбор индексов напрямую влияет на количество блокировок. Если выполняется блокирующий SELECT без индексов, то в REPEATABLE READ это приводит к блокировке всех строк в таблице.

Размеры блокировки индекса

InnoDB накладывает блокировки не на сами строки с данными, а на строки индексов. Возможные варианты блокировок индекса:

·   блокировка строки индекса ( createMock) –  блокирование только этой строки в индексе. Применяется если statement затрагивает только одну строку и она найдена с помощью уникального индекса. Например, в таблице существует строка с c1=10 и есть уникальный индекс по этому полю, этот запрос наложит блокировку только на одну строку в индексе:

SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;

·   блокировка интервала (gap lock). Интервал – это диапазон между проиндексированными записями. Используется, чтобы избежать проблемы «фантомное чтение».

Например, имеется таблица:

| с1   |
| ---- |
| 10   |
| 20   |

для этой таблицы существуют gaps (не включающие граничные значение):

|      |
| ---- |
|      |
|      |

Запрос:

SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;

блокирует gap    и значение 15 вставить нельзя. Граничные строки не блокируются и их можно даже их удалить. 

В пустой таблице существует только один интервал   , т.е. при при lock reading таблица блокируется целиком.

·   блокировка следующего ключа (next-key lock) – блокировка строк индекса (record lock) и интервалов (gap lock) одновременно (возможно нескольких). 

Запрос:

SELECT c1 FROM t WHERE c1>15 FOR UPDATE;

выполняет такие блокировки:

| gap-lock          |
| ----------------- |
| record-lock  [20] |
| gap-lock          |

 

Чтение и блокировки

Возможно два вида чтения:

·   консистентное неблокирующее чтение (non-lock reading) – по умолчанию, оператор `SELECT` выполняется из consistent snapshot, не запрашивает никаких блокировок и игнорирует любые существующие блокировки. Однако, при уровне изоляции  [SERIALIZABLE](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable) запросы SELECT преобразуются в SELECT ... LOCK IN SHARE MODE с shared-lock

·   блокирующее чтение (locking reading) – с явной установкой блокировок на считываемые данные. При этом данные для запроса читают уже не из snapshot, как простой SELECT, т.е. они увидят изменения зафиксированные другой транзакцией после начала текущей (проблема «неповторяющееся чтение»). Так происходит потому, что InnoDB может заблокировать только последнюю версию строки, а в snapshot она не обязательно будет последней. Чтобы избежать этого, не надо делать non-lock reading перед locking reading.

Варианты:

o  •SELECT ... LOCK IN SHARE MODE – пытается взять shared блокировку. Т.е. допускаются другие shared lock, но не допускается exclusive lock. Используется, если нужно запретить изменение данных во время транзакции. Например, нужно прочитать значение для foreign key из родительской таблицы, а потом вставить строку с ним в дочернюю таблицу. Чтобы запретить изменение строки в родительской таблице во время транзакции нужно поставить shared блокировку.

o  SELECT ... FOR UPDATE — пытается взять exclusive lock, как обычный UPDATE. Используется, когда заранее известно, что эти строки нужно будет обновить и нужно сразу получить exclusive lock:

BEGIN;

SELECT ... FOR UPDATE;

...

UPDATE ...;

COMMIT;

MySQL также поддерживает команды LOCK TABLES и UNLOCK TABLES, которые осуществляют блокировки на уровне таблицы и реализуются сервером, а не подсистемой хранения.

Операции изменения и блокировки

UPDATE и DELETE устанавливают exclusive lock на затронутые строки, какого-то из трех размеров (record-lock, gap-lock, next key lock).

INSERT устаналивает exclusive lock размером record-lock на вставленную строку.

Deadlock (взаимоблокировки)

Для разрешения взаимоблокировок InnoDB обнаруживает циклические зависимости и немедленно возвращает ошибку без таймаута. Происходит откат той транзакции, которая захватила меньше всего монопольных блокировок строк (приблизительный показатель легкости отката).

Некоторые системы в подобных ситуациях откатывают транзакцию по истечении тайм-аута, что приводит к задержкам в работе.

 

### Ускорение группы операций через транзакции

Ускорение группы операций

Допустим выполняется группа команд в режиме по умолчанию AUTOCOMMIT=1:

SELECT like FROM post WHERE...     # Прочитать количество лайков к посту

UPDATE post SET like=like+1 WHERE...   # Обновить количество лайков к посту

UPDATE user SET rating=rating+1 WHERE...# Обновить рейтинг поста

INSERT like_log SET date = NOW(), ...  # Записать событие в лог

Каждый запрос заворачивается в отдельную транзакцию, поэтому при фиксации каждого запроса будет выполнена дисковая операция для записи в журнал транзакций (для обеспечения durability). 

Способ решения проблемы: завернуть пакет запросов в одну транзакцию. Возможные варианты:

·    отключить режим AUTOCOMMIT=0 и сделать в конце пакета запросов COMMIT

·   вручную стартовать транзакцию

START TRANSACTION

...

COMMIT

В результате изменения будут выполняться в памяти и только в момент COMMIT будут сброшены за одну дисковую операцию:

Особенно заметен прирост производительности при загрузке в базу больших объемов данных (например, загрузка из файла SQL-дампа), когда выполняются пачки INSERT. 

### Multiversion Concurrency Control (MVCC)

InnoDB реализует технологию MVCC (multiversion concurrency control, многоверсионное управление конкурентным доступом). 

Принцип работы: в момент первого запроса в транзакции создается мгновенный снимок (snapshot, снэпшот) данных БД, на который не влияют изменения в параллельных транзакциях, но влияют изменения в текущей. Можно потребовать сделать снэпшот в момент старта транзакции и до первого запроса:

START TRANSACTION WITH CONSISTENT SNAPSHOT.

Чтение из такого снэпшота называют неблокирующим (т.к. для чтения не требуются блокировки) согласованным (т.к. вне зависимости от длительности транзакции – транзакция видит согласованное представление данных) чтением (consistent read). Это также означает, что различные транзакции могут видеть разные данные в одних и тех же таблицах в одно и то же время! 

InnoDB реализует MVCC путем сохранения с каждой строкой двух дополнительных скрытых значений (номеров версий):

·   создание этого варианта строки:  через INSERT (создание новой строки) или UPDATE (изменение на это состояние)

·   устаревание этого варианта строки: через UPDATE (изменение на другое состояние) или DELETE (удаление строки). 

Эти моменты времени хранятся в виде системного номер версии. Данное число увеличивается на единицу в начале каждой транзакции. 

Т.е. UPDATE создает еще один вариант строки с новыми значениями и указывает:

·   текущую версию в качестве версии создания новой строки. 

·   текущую версию в качестве версии удаления старой строки. 

Преимущество:

·   уменьшение количества блокировок,

·   повышения степени конкурентности запросов 

Недостаток:

·   дополнительные накладные расходы.

  

## Типы систем хранения

Файловая структура баз данных и таблиц:

·   Каждая база данных (также именуемая схемой) хранится в отдельном подкаталоге, внутри каталога данных (параметр datadir в my.cfg) . 

·   Определение каждой таблицы (поля, типы полей…) хранится  в файле с расширением .frm и именем, совпадающим с именем таблицы (например, MyTable.frm). Определение таблиц сервер обрабатывает самостоятельно, файлы .frm не зависят от используемой подсистемы хранения.

·   Данные таблиц и индексы в каждой подсистеме хранения записываются на диск по разному. 

Определить параметры любой таблицы (подсистему хранения, кодировку, …) можно с помощью команды SHOW TABLE STATUS (подробнее Show table status)

### MyIsam

MyISAM используется для хранения системных данных в таблице mysql. 

Особенности MyISAM:

·   отсутствует поддержка транзакций. Т.е. MyISAM не гарантирует Durability – даже одна команда может быть выполнена частично. Если, например, ошибка произойдет в процессе выполнения команды UPDATE, обновляющей несколько строк, то некоторые строки будут обновлены, а некоторые нет. 

·   движок быстрый, по причине отсутствия транзакций.

·   блокировка на уровне таблицы, но не строки. Поэтому запросы на запись приводят к монопольной блокировке всей таблицы на запись. Однако выборки в момент вставки новых строк допускаются (конкурентные вставки)

·   хранит счетчик количества строк в таблице, поэтому запросы COUNT(*) без условий выполняются мгновенно.

·   отсутствие автоматического восстановления данных. При сбое питания требуется ручная проверка таблиц.

·   Можно создавать сжатые неизменяемые таблицы.

·   пространственные функции (для геоинформационных систем – ГИС).

Хранение данных и индексов 

MyISAM хранит каждую таблицу в двух файлах: 

·   файле данных с расширением .MYD (MYData)

·   файле индексов с расширением .MYI (MYIndex)

Особенности применения

·   движок быстрый, эффективен на чтение.

·   не эффективен в задачах, где большое количество записи, т. к. для записи блокируется вся таблица;

#### Конфигурирование

Движок MyISAM самостоятельно кэширует в памяти только индексы. Поэтому наиболее важный параметр в настройке MyISAM – это директива key_buffer_size в файле my.cfg – объем памяти, выделяемый под кэш индексов для MyISAM Под кэш индексов рекомендуется выделять 25-50% оперативной памяти сервера.

Если таблицы типа MyISAM не используются в приложении, все равно следует выделить с помощью параметра key_buffer_size хотя бы небольшой объем памяти, скажем, 32M. MySQL использует MyISAM-таблицы для внутренних целей – для системных таблиц, для временных таблиц.

Остаток памяти будет отведен под кэши операционной системы, в которых будут хранятся данные, считанные из MYD-файлов с данными. Естественно, что данных значительно больше, чем индексов. Важно, чтобы в операционной системе оставалась доступная свободная память под кеши операционной системы (столбцы free и cached в отчете утилиты free или vmstat). Извлечение данных из кеша операционной системы является более дорогим, чем извлечение индекса, т.к. требуется дорогостоящий вызов операционной системы.

Оценить эффективность кэша индексов можно, запросив переменные состояния, начинающиеся с префикса Key_%:

mysql> SHOW STATUS LIKE 'Key_%';

+------------------------+-------------+

| Variable_name     | Value    |

+------------------------+-------------+

| Key_blocks_not_flushed | 0      |

| Key_blocks_unused   | 0      | Количество свободных блоков в кеше 
 |            |       | ключей

| Key_blocks_used    | 107171    | Количество занятых блоков в кеше
 |            |       | ключей

| Key_read_requests   | 18472428924 | Количество чтений напрямую из кеша
 |            |       | ключей без использования диска

| Key_reads       | 381826182  | Количество чтений ключей с диска в
 |            |       | обход кеша ключей

| Key_write_requests   | 4483957   | Количество записей в кеш изменений
 |            |       | ключей

| Key_writes       | 77799    | Количество записей измененных ключей
 |            |       | из кеша ключей на диск

+------------------------+-------------+

Особенности конфигурирования:

·   Не имеет смысла делать кеш индексов key_buffer_size больше, чем общий объем файлов с индексами .MYI в базе данных

·    Если количество свободных блоков в кеше Key_blocks_unused стабильно держится выше 0, то можно уменьшить объем памяти под кеш индексов key_buffer_size

·  Соотношение должно   , т.е. попадание в кеш   .

·   Если примерно известна скорость I/O в единицах   , то можно сравнить эту величину с   

·   Индексы организованы эффективно, если   , т.е. чтений из индекса гораздо больше изменений индекса при вставке/обновлении данных.

С помощью данной команды можно заранее загрузить индексы из таблиц MyISAM в кэш (прогреть кеш):

LOAD INDEX INTO CACHE table1, table2;

 

### MyISAM Merge

Объединение нескольких структурно одинаковых таблиц MyISAM в одну виртуальную таблицу. Подробнее Объединенные таблицы и секционирование

### InnoDB

Особенности InnoDB:

·   поддерживает транзакции

·   блокировка данных на уровне строк. Поэтому эффективен в случае большого количества записи.

·   уровень изоляции по умолчанию – REPEATABLE READ + предотвращает проблему «фантомное чтение» через блокировки диапазонов (подробнее Блокировки Блокировки)

·   автоматическое восстановление после сбоя – через журнал транзакций

·   реализует MVCC

·   данные хранятся в порядке кластерного индекса. Поэтому данные очень быстро находятся и перебираются по первичному ключу.

·   поддерживает ограничения целостности типа «внешний ключ»

·   адаптивный хеш-индекс

·   не хранит информацию о количестве строк в таблице, т.е. запросы COUNT(*) без фразы WHERE требуют сканирования таблицы или индекса.

#### Хранение данных InnoDB

InnoDB сохраняет данные, индексы и различные внутренние структуры вместе, в одном или нескольких файлов .ibdata, которые называются *табличным пространством (tablespace).* 

Файлы, помещаемые в табличное пространство, перечисляются в конфигурационном параметре innodb_data_file_path. Все они будут находиться в каталоге, который задается параметром innodb_data_home_dir.

innodb_data_home_dir = /var/lib/mysql/

innodb_data_file_path = ibdata1:1G;ibdata2:1G;ibdata3:1G

Табличное пространство в сущности является черным ящиком, которым полностью управляет сама InnoDB. InnoDB может располагать табличные пространства на «сырых» (неформатированных) разделах диска. 

##### Параметр `innodb_file_per_table`

Параметр `innodb_file_per_table` указывает размещать каждую таблицу в отдельном табличном пространстве, файле с именем вида `tablename.ibd`. При этом главное табличное пространство продолжает использоваться для файлов отмены и других системных данных. Этот параметр не позволяет делать резервные копии и восстанавливать таблицы путем простого копирования файлов. 

Преимущества: 

- проще освобождать место при удалении таблицы


- удобное распределение таблиц по разным дискам. 


- делает структуру базы более наглядной. 


- позволяет гораздо быстрее определить размер таблицы, взглянув на соответствующий файл, вместо команды `SHOW TABLE STATUS`


Недостаток:

- больше места растрачивается впустую, т.к. появляется неиспользуемое место в IBD-файлах, что особенно плохо для маленьких таблиц, т.к. размер страницы в InnoDB составляет 16 Кбайт, и даже если в таблице хранится всего 1 Кбайт данных, на диске она все равно будет занимать 16 Кбайт.


#### Параметр innodb_buffer_pool_size

Директива innodb_buffer_pool_size определяет объем памяти, выделяемой под кэш InnoDB (пул буферов). Т.к. пул буферов включает данные, индексы и все служебные данные, документация рекомендует для выделенных серверов БД отдавать под кеш 50-80% оперативной памяти.

#### Мониторинг и конфигурирование

Оценить эффективность кэша индексов можно, запросив переменные состояния, начинающиеся с префикса Innodb_buffer_pool_%:

mysql> SHOW STATUS LIKE 'Innodb_buffer_pool_%';

+----------------------------------+----------------+

| Variable_name          | Value     |

+----------------------------------+----------------+

| Innodb_buffer_pool_pages_data  | 4259278    | Количество занятых
 |                 |        | страниц в кеше

| Innodb_buffer_pool_bytes_data   | 69784010752  | то же в байтах

|                 |        |

| Innodb_buffer_pool_pages_dirty  | 53550     | Количество «грязных» 
 |                 |        | страниц в кеше

| Innodb_buffer_pool_bytes_dirty  | 877363200   | то же в байтах

|                 |        |

| Innodb_buffer_pool_pages_free  | 1362417    | Количество свободных
 |                 |        | страниц в кеше

|                 |        |

| Innodb_buffer_pool_pages_total  | 5898232    | Общее количество
 |                 |        | страниц в кеше

|                 |        |

| Innodb_buffer_pool_read_requests | 11594798923377 | Количество чтений из
 |                 |        | кеша

|                 |        |

| Innodb_buffer_pool_reads     | 3628278    | Количество чтений с 
 |                 |        | диска в обход кеша

|                 |        |

| Innodb_buffer_pool_write_requests| 1451780634   | Количество записей в
 |                 |        | кеш

+---------------------------- -----+----------------+

Также можно посмотреть Buffer pool hit rate в выводе (наверное рассчитывается как   ):

mysql> SHOW ENGINE InnoDB STATUS\G ...

 —------------------— BUFFER POOL AND MEMORY —------------------— 

... Buffer pool hit rate 994 / 1000, young-making rate 6 / 1000 not 0 / 1000 ...

Особенности конфигурирования:

·   Не имеет смысла делать пул буферов innodb_buffer_pool_size больше, чем полный размер базы данных+служебные данные InnoDB

·   Можно выделить под пул буферов памяти столько, чтобы туда поместилась вся база данных. Однако это зачастую не эффективно, т.к. не все данные требуется грузить в кеш.

·    Если количество свободных блоков в кеше Innodb_buffer_pool_pages_free стабильно держится выше 0, то можно уменьшить объем памяти под пул буферов innodb_buffer_pool_size

·  Соотношение должно   , т.е. попадание в кеш   . Если   , то следует увеличить размер пула буферов innodb_buffer_pool_size. Если размер пула буферов вылезает за пределы доступной оперативной памяти, то стоит добавить памяти на сервер.

·   Если примерно известна скорость I/O в единицах   , то можно сравнить эту величину с   

·   Кеш используется эффективно, если   , т.е. чтений из кеша гораздо больше изменений кеша при вставке/обновлении данных.

Для таблиц типа InnoDB не существует аналога команды LOAD INDEX INTO CACHE. Если требуется «прогреть» сервер, то это нужно делать вручную – отправлять запросы, выполняющие полное сканирование таблицы или индекса.

#### Журнал транзакций

Для восстановления после падения сервера и уменьшения стоимости фиксации транзакций в InnoDB используется журнал транзакций (*redo* *log*). 

Изменения данных и индексов, произведенные внутри транзакции, часто относятся к разрозненным местам в табличном пространстве, поэтому для сброса потребуется помещать их в несмежные области диска. Вместо сброса пула буферов на диск после фиксации каждой транзакции InnoDB записывает транзакции в журнал (эти данные называются *redo*) – это называется *упреждающая запись в журнал*. Журнал используется для превращения произвольного ввода/вывода в последовательный. После того как запись в журнал произведена, транзакцию можно считать долговечной (D из ACID), пусть даже изменения еще не записаны в файлы пула буферов. 

Параллельно изменения в страницах пула буферов фиксируются в копии, находящейся в памяти. Разумеется, InnoDB в конечном итоге должна записать эти  изменения в файлы пула буферов на диске. В InnoDB имеется фоновый поток, который упорядочивает сброс изменений в файлы данных. Этот поток умеет группировать операции записи так, чтобы они выполнялись последовательно, с целью повышения его эффективности. Размер журнала транзакций фиксирован, запись в журнал производится циклически: по достижении конца журнала происходит переход в начало. 

Если случится какая-то авария (например, пропадет питание), то InnoDB сможет воспроизвести журнал и восстановить зафиксированные транзакции. Процесс восстановления после падения в InnoDB полностью автоматический и в обязательном порядке выполняется в момент запуска InnoDB. 

Полный размер файла журнала задается параметром innodb_log_file_size, а количество файлов журнала задается параметром innodb_log_files_in_group. По умолчанию InnoDB создает два файла журнала в каталоге данных MySQL ( datadir): ib_logfile0 и ib_logfile1. 

При модификации любых данных InnoDB помещает запись об изменении в *буфер журнала*, который хранится в памяти, позже он сбрасывается на диск. Размером буфера журнала управляет переменная innodb_log_buffer_size. 

##### Параметр innodb_flush_log_at_trx_commit

Параметр innodb_flush_log_at_trx_commit контролирует как часто сбрасывается буфер журнала. Возможные варианты:

·   0 – сброс буфера журнала на диск раз в секунду (самый быстрый режим)

·   1 –  сброс буфера журнала на диск при каждой фиксации транзакции (самый безопасный режим)

·   2 – аналогичен 0, только транзакции не теряются при аварийном останове сервера

##### Параметр innodb_flush_method

Параметр innodb_flush_method позволяет указать, как InnoDB сбрасывает на диск данные пула буферов и журнал транзакций. 

Часто используемые варианты:

·   fsync (значение по умолчанию). Для сброса используется системный вызов fsync() fsync() копирует на диск все части файла, находящиеся в памяти, и ожидает пока устройство скажет, что все эти части сохранены. При этом операционная система буферизует, по крайней мере, некоторые данные в собственном кэше. Возникает двойная буферизация данных: операционной системой и подсистемой InnoDB. Однако двойная буферизация – это необязательно плохо, некоторые ОС умеют накапливать процедуры записи и выполнять их одним пакетом, выполнять упреждающее чтение и другие оптимизации. 

·   O_DIRECT  – часто рекомендуется для включения. ОС дается указание не кэшировать данные и не прибегать к опережающему чтению. Все операции чтения и записи направляются напрямую устройству хранения во избежание двойной буферизации. Задание флага O_DIRECT в случае, когда между InnoDB и физическим устройством нет никакого буфера, например при отключенном кэше записи на RAID-контроллере, может привести к серьезному падению производительности. Если нужные данные отсутствуют в пуле буферов, то InnoDB будет вынуждена читать их прямо с диска, что гораздо медленнее, чем из буфера.

#### MVCC в InnoDB

Если транзакция долгое время остается открытой (даже не делая ничего полезного), то InnoDB не может удалить старые версии строк, поскольку они должны быть видны незафиксированным транзакциям. InnoDB хранит старые версии в табличном пространстве. При большом количестве невычищенных транзакция табличное пространство быстро растет по мере накапливающихся изменений данных. 

Команда SHOW INNODB STATUS может показать текущий номер транзакции и номер транзакции, до который вычищено табличное пространство:

----------— 
 TRANSACTIONS 
 ----------— 
 Trx id counter 0 80157601             # Текущий номер транзакции


 Purge done for trx’s n:o <0 80154573 undo n:o <0 0 # Номер транзакции, до 
                           которой вычищено 
                           табличное пространство

 

 

 

 

### Memory

полезны, когда необходимо осуществить быстрый доступ к данным, которые либо никогда не изменяются, либо нет надобности в их сохранении после перезапуска. Обычно таблицы типа Memory обрабатываются примерно на порядок быстрее, чем таблицы MyISAM. Все их данные хранятся в памяти, поэтому запросам не нужно ждать выполнения операций дискового ввода/вывода. Структура таблицы Memory сохраняется после перезапуска сервера, но данные теряются, не сохраняются на диск. Применение: Для «справочных» таблиц или таблиц «соответствия», например для таблицы, в которой почтовым кодам соответствуют названия регионов•• Для кэширования результатов периодического агрегирования данных •• Для промежуточных результатов при анализе данных Таблицы Memory поддерживают индексы типа HASH, обеспечивающие очень большую скорость выполнения поисковых запросов. используют блокировку на уровне таблицы, что уменьшает конкуренцию при записи,. MySQL внутри себя использует подсистему Memory для хранения про межуточных результатов при обработке запросов. Отсутствуют динамические строки, т.е. поля типа BLOB и TEXT, тип VARCHAR(5000) превращается в CHAR(5000). Отсутствие статистика индексов, что иногда приводит к плохим планам выполнения.

### Archive

Подсистема хранения Archive позволяет выполнять только команды INSERT и SELECT. буферизует записываемые данные и сжимает все вставляемые строки с помощью библиотеки *zlib**.* Каждый запрос SELECT требует полного сканирования таблицы. По этим причинам таблицы Archive идеальны для протоколирования и сбора данных, когда анализ чаще всего сводится к сканированию всей таблицы

### Blackhole

Отсутствует система хранения. Запросы пишутся в журналы, они могут быть реплицированы на подчиненные серверы или просто сохранены в журнале. Необходимо для настройки предполагаемых репликаций и ведения журнала аудита.

### Falcon, solidDB, PBXT, Maria

Обычные система с MVCC и хранимыми в памяти транзакциями. Можно самому создать свою систему хранения.

### Выбор системы хранения

Критерии:

·     Определение необходимости транзакций.

·     Определение типа конкурентного доступа. Если основной объем операций это INSERT и SELECT то лучший вариант – MyISAM. Если требуется конкурентное изменение данных то лучше выбрать систему с блокировкой на уровне строки InnoDB.

·     Особенности резервного копирования (возможность останова сервера)

·     Скорость восстановления после сбоя (MyISAM часто повреждается)

·     Необходимость кластерных индексов, полнотекстовый поиск

### Примеры выбора типа

Протоколирование, логгирование

В оперативном режиме необходимо быстрый INSERT, наилучшие MyISAM и Archive. Данные можно реплицировать на подчиненный сервер, где выполнять аналитическую обработку, либо запускать ее в периоды спада нагрузок. Еще вариант – MyIsam Merge с отдельными таблицами по датам, и виртуальной таблицей для агрегирования.

Справочные таблица, практически только для чтения

MyISAM, с минусом в виде опасности повреждения.

  

Способы преобразования таблиц между форматами:

\1.   ALTER TABLE mytable ENGINE = Falcon Занимает много времени, блокирует таблицу на чтение

\2.   mysqldump

\3.    

mysql> CREATE TABLE innodb_table LIKE myisam_table;

mysql> ALTER TABLE innodb_table ENGINE=InnoDB;

mysql> INSERT INTO innodb_table SELECT * FROM myisam_table;

для транзакционных таблиц последняя команда приводит к большому журналу отмены, поэтому лучше частями:

mysql> START TRANSACTION;

mysql> INSERT INTO innodb_table SELECT * FROM myisam_table

-> WHERE id BETWEEN x AND y;

mysql> COMMIT;

## Кэш запросов MySQL

MySQL (и многие СУБД) умеет кэшировать планы выполнения, что позволяет серверу пропустить стадии разбора и оптимизации запросов, уже встречавшихся ранее. Однако у MySQL есть еще кэш запросов, в котором хранятся полные результирующие наборы, сгенерированные командами SELECT.

При попадании в кэш запросов (hits) сервер сразу же возвращает сохраненные итоги, пропуская стадии разбора, оптимизации и выполнения. Кэш запросов отслеживает, какие таблицы были использованы в запросе, и, если хотя бы одна из них изменилась, данные в кэше становятся недействительными, без разбора связано ли это изменение с данными в кеше. Такая грубая политика позволяет значительно снизить накладные расходы. Кэш прозрачен для приложений, однако может изменить семантику в одном аспекте – по умолчанию запрос может быть обслужен из кэша, если одна из участвующих в нем таблиц заблокирована.

Ключом таблицы кэшей является хеш, рассчитанный по тексту запроса, текущей базе данных, номеру версии клиентского протокола (от них зависят результаты обработки запроса). Любое различие (регистр символов, лишние пробелы или комментарии) приведет к тому, что новый запрос не совпадет с кэшированной версией.

Результат не кешируется, если сгенерирован недетерминированным запросом, (содержащим недетерминированную функцию, например NOW() или CURRENT_DATE()), если запрос содержит ссылки на определенные пользователем функции, хранимые процедуры, пользовательские переменные, временные таблицы, таблицы в базе данных Mysql. 

MySQL помечает запрос как некэшируемый, как только обнаруживает конструкцию, препятствующую кэшированию, и результаты такого запроса не сохраняются. Что бы избежать этого, стоит избавить запрос от недетерминированных функций, например, записать дату в виде литерала: 

*-- не кешируется
\* **SELECT** *** **FROM table WHERE** DATE_SUB(*CURRENT_DATE*, **INTERVAL** 1 **DAY**)

 *-- кешируется
\* **SELECT** *** **FROM table WHERE** DATE_SUB(**'2018-05-05'**, **INTERVAL** 1 **DAY**)

Поиск в кэше производится до разбора запроса и сервер лишь проверяет, что запрос начинается с букв SEL (без учета регистра) перед поиском в хэш-таблице. 

При включении кеша добавляются накладные расходы как при чтении, так и при записи:

·   Перед началом обработки запроса на чтение нужно проверить, есть ли он в кэше 

·   Если запрос допускает кэширование, но еще не помещен в кэш, то нужно потратить время на запись в кэш сгенерированных результатов;

·   При обработке любого запроса на запись необходимо сделать недействительными все записи в кэше, в которых встречается измененная таблица

Эти издержки сравнительно невелики, поэтому в целом кэш может дать выигрыш. Пул памяти, выделенной под кэш, состоит из блоков переменной длины. На этапе запуска сервер инициализирует память, выделенную для кэша запросов. Первоначально пул памяти состоит из одного свободного блока размером с выделенную под кеш память. Когда сервер кэширует результат запроса, он выделяет блок для хранения этого результата. Минимальный размер блока составляет query_cache_min_res_unit байтов. Сервер не в состоянии создать блок в точности подходящего размера, так как первоначальное выделение производится еще до того, как результирующий набор полностью сгенерирован, т.к. строки отправляются клиенту по мере их порождения.

Сервер выделяет блок минимального размера и начинает помещать в него результаты, затем новый и т.д. Когда результат полностью сгенерирован, сервер усекает последний блок и объединяет оставшуюся область с соседним свободным блоком. 

  

Память под кэш выделяется только один раз, при создании кэша. Затем сервер только просматривает список блоков и либо находит место, где собирается разместить новый блок, либо при необходимости удаляет самый старый кэшированный запрос, чтобы освободить. Сервер MySQL самостоятельно управляет своей памятью, не полагаясь на операционную систему.

Образование зазоров называется фрагментацией. Ее причины: параллельно выполняемые кеширования, объявление записей в кэше недействительными (инвалидиция).

Выигрывают от наличия кэша те запросы, которые долго выполняются, но занимают в кэше немного места, так что их хранение, возврат клиенту и инвалидация обходятся дешево. В эту категорию попадают, агрегирующие запросы, например, с функцией COUNT() для больших таблиц. 

### Конфигурационные параметры

·   query_cache_type – включен ли режим кэширования запросов. 

Возможные варианты:

o  OFF – кэш запросов отключен

o  ON – кэш запросов включен. При помощи модификатора SQL_NO_CACHE можно помечать SQL-запросы, которые не должны подвергаться кэшированию:

SELECT SQL_NO_CACHE * FROM table WHERE ...;

o  DEMAND кэшируются только запросы с модификатором SQL_CACHE.

SELECT SQL_CACHE * FROM table WHERE ...;

·   query_cache_size – общий объем памяти, отведенной под кэш запросов.

·   query_cache_min_res_unit – минимальный размер выделяемого блока.

·   query_cache_limit – размер максимального результирующего набора, который разрешено кэшировать. 

Сервер кэширует результаты по мере их генерации, поэтому заранее не известно, поместится ли результат в кэш. Если размер результата превышает заданный порог, то MySQL увеличивает переменную состояния Qcache_not_cached и отбрасывает закэшированные к этому моменту строки. Если это происходит часто, то можно включить указание SQL_NO_CACHE в запросы, которые могут приводить к такой ситуации.

·   query_cache_wlock_invalidate – запрещать обслуживать из кэша результаты, которые относятся к таблицам, заблокированным другими соединениями. По умолчанию этот параметр равен OFF, что изменяет семантику запроса, поскольку позволяет серверу читать кэшированные данные из заблокированной таблицы, хотя обычно сделать это невозможно. Если установить параметр равным ON, то чтение данных будет запрещено.

### Мониторинг и конфигурирование

За кеш запросов отвечают переменные состояния, которые начинаются с Qcache_:

mysql> SHOW STATUS LIKE 'Qcache_%';

+-------------------------+--------+

| Variable_name      | Value  |

+-------------------------+--------+

| Qcache_free_blocks   | 154  | Свободных блоков в кеше

|             |    |

| Qcache_free_memory   | 576304 | Свободной памяти в кеше

|             |    |

| Qcache_hits       | 667873 | Число попаданий в кеш

|             |    |

| Qcache_inserts     | 166945 | Число вставок запросов в кеш

|             |    |

| Qcache_lowmem_prunes  | 32423 | Число запросов, удаленных из кеша из-за
 |             |    | недостатка памяти

|             |    |

| Qcache_not_cached    | 171807 | Число незакешированных запросов,
 |             |    | например, превышающих query_cache_limit

|             |    |

| Qcache_queries_in_cache | 6844  | Число запросов в кеше

|             |    |

| Qcache_total_blocks   | 14359 | Общее число блоков в кеше

+-------------------------+--------+

Для каждого приложения существует конечный потенциальный размер кэша – это объем памяти, необходимый для сохранения всех кэшируемых запросов, которые может выполнить приложение. Как правило он не так велик, т.к. большинство записей в кэше становятся недействительными. 

Правила определения оптимального размера кеша query_cache_limit: 

·    используется не вся память (что можно понять по числу свободных блоков в кеше Qcache_free_blocks и общему числу блоков Qcache_total_blocks) – необходимо его уменьшить

·   если  из-за нехватки памяти часто происходит вытеснение (prune) запросов из кеша и растет переменная Qcache_lowmem_prunes – необходимоувеличить его.

Опеределение hit/miss ratio. Когда сервер получает команду SELECT, он увеличивает одну из двух переменных состояния: Qcache_hits или Com_select, в зависимости от того, был запрос кэширован или нет. Поэтому коэффициент попаданий в кэш вычисляется по формуле   

Даже 30% попаданий может быть очень неплохим результатом, поскольку экономия от невыполненных запросов значительно превышает накладные расходы на объявление записей недействительными и на сохранение результатов в кэше.

Если количество непопаданий в кэш велико возможно кэш еще не «прогрелся». 

Если процент хитов маленький при этом свободных блоков много, фрагментация низкая, вытеснений из-за нехватки памяти мало, то, вероятно, кэш запросов вообще мало помогает при данной загрузке сервера. Например, большое количество обновлений, или запросы не допускают кэширования. Можно провести эталонное тестирование с кешем и без, отключив кеш:

query_cache_size = 0

Использование кэша может оказаться неэффективным, поскольку замедляет выполнение запросов на обновление. При обработке любого запроса на обновление приходится проверять, не нужно ли объявить недействительными какие-то кэшированные данные. Если закэшированный результат становится недействительным до того, как сервер снова получает ту же самую команду SELECT, то вся работа по сохранению была пустой тратой времени и памяти. Для оценки нужно сравнить Com_select и Qcache_inserts. Если почти все команды SELECT не попадают в кэш, т.е. все результирующие наборы кэшируются, то Qcache_inserts будет мало отличаться от Com_select. Желательно, чтобы значение Qcache_inserts было существенно меньше Com_select, по крайней мере, после «прогрева» кэша.

Выбор минимального размера блока query_cache_min_res_unit. Слишком маленькое значение приведет к частому выделению блок памяти, слишком большое –к возрастанию фрагментации. Оптимальное значение определяется по средней величине кэшированных запросов. определяется:

  

Если имеется смесь больших и маленьких результирующих наборов, то можно подавить кэширование больших результирующих наборов, уменьшив значение размера максимального кешируемого запроса query_cache_limit.

Фрагментация кеша. Кэш фрагментирован, если Qcache_free_blocks (количество свободных блоков) приблизительно равно Qcache_total_blocks / 2. а также если число преждевременно вытесненных запросов Qcache_lowmem_prunes увеличивается и при этом имеется много свободных блоков. Дефрагментировать кэш запросов можно с помощью команды FLUSH QUERY CACHE. Она уплотняет кэш, перемещая все блоки «вверх» и избавляясь от свободного пространства между ними, так что в итоге остается единственный свободный блок «внизу». На время выполнения команды, доступ к кэшу запросов блокирован, то есть, по существу, приостановлена работа всего сервера, но обычно, если кэш не слишком велик, дефрагментация быстро завершается. Несмотря на название, команда FLUSH QUERY CACHE не удаляет запросы из кэша. Для этой цели предназначена команда RESET QUERY CACHE.

В InnoDB, где реализована MVCC, кеша запросов знает для каждой таблицы, номер последней модифицирующей ее транзакции. Транзакции могут обращаться только к тем таблицам, которые не были модифицированными другими транзакциями с момента их начала. Например, если транзакция 5 установила блокировку на строки в таблице, а затем была зафиксирована, то транзакции с 1 по 4 никогда не смогут обратиться к кэшу запросов для чтения или записи, если в запросе участвует эта таблица.

# Эталонное тестирование

*Эталонное тестирование* (*benchmarking*) измеряет производительность системы. Эталонное тестирование отвечает на вопрос «Насколько хороша производительность?».

Эталонный тестирование используется: 

- для проверки полезности внесенных изменений
- для эмуляции гораздо большей нагрузки, чем та, которую испытывает система сейчас
- проверки необходимых ресурсов, узких мест при увеличении нагрузки
- тестировании различных конфигураций оборудования, программного обеспечения и операционной системы.

Существуют две основные стратегии тестирования производительности: тестировать приложение целиком или только аспекты, относящиеся к MySQL. Эти стратегии соответственно называются полным и покомпонентным тестированием.

При эталонном тестировании оценивают следующие показатели: количество транзакций в единицу времени (важно для OLTP систем), время отклика (латентность, часто в процентилях), уровень рабочей конкуренции (количеством потоков или соединений, выполняющих работу одновременно).

Самые распространенные ошибки: 

Использование набора данных, имеющего объем, несоизмеримый с рабочими объемами;

Использование данных с неправильным распределением, например равномерно распределенных, когда в реальных данных будут встречаться «горячие точки».

Тестирование распределенного приложения на единственном сервере.

Выполнение идентичных запросов в цикле. Реальные запросы неодинаковы, так что они могут запрашивать данные не из кэша.

Отсутствие контроля ошибок, т.к. при наличии ошибки в запросе будет замеряться время нахождения ошибки парсером. – 

«неразогретый» кэш.

Нужно решить, использовать ли стандартный тест или разработать свой собственный. Можно превратить комплект модульных тестов (unit test suite) в простейший эталонный тест, просто прогнав их несколько раз, но вряд ли это соответствует тому, как используется база данных на самом деле. Лучше записать все запросы на рабочей системе в течение репрезентативного отрезка времени. При этом необходимо воссоздать отдельные потоки, а не просто последовательно повторять запросы один за другим.

Необходимо убедиться в повторяемости результатов тестирования. При каждом прогоне теста следует менять как можно меньше параметров и использовать технику «разделяй и властвуй» (уменьшение или увеличение значения параметра вдвое на каждой последующей итерации тестирования).

Результатом тестирования являются утверждения типа «модернизация сервера до четырехпроцессорного увеличит производительность на 50% при той же задержке» или «использование индексов ускорило выполнение запросов».

Инструменты эталонного тестирования

**Инструменты полного тестирования**

**ab** для сервера HTTP Apache. Показывает, сколько запросов в секунду способен обслуживать HTTP-сервер. Просто обращается к одному адресу URL настолько быстро, насколько это возможно. ([http://httpd.apache.org/docs/2.0/programs/ab.html](https://vk.com/away.php?to=http%3A%2F%2Fhttpd.apache.org%2Fdocs%2F2.0%2Fprograms%2Fab.html&cc_key=)).

Утилита [ab](http://httpd.apache.org/docs/2.0/programs/ab.html) поставляется в комплекте с *Apache*, так что если он у вас установлен — у вас есть уже всё необходимое.

Для указания числа запросов используется опция *'-n'*. Номер порта можно не указывать, если он не отличен от 80-го:

$ ab -n 1000 http://aserver.ashep:80/test.html

тысяча запросов будет направлена к нему *одновременно*, указав это при помощи опции *'-c'*:

$ ab -n 1000 -c 1000 http://aserver.ashep:80/test.html

Для выполнения теста с Keep-Alive-соединениями просто добавьте опцию *'-k'*:

$ ab -k -n 1000 -c 1000 http://aserver.ashep:80/test.html

**http_load** использует входной файл, включающий много разных адресов URL. Выбирает их случайным образом. Можно настроить, чтобы запросы отправлялись с заданным интервалом, а не с максимально возможной скоростью ([www.acme.com/software/http_load/](https://vk.com/away.php?to=http%3A%2F%2Fwww.acme.com%2Fsoftware%2Fhttp_load%2F&cc_key=)).

**JMeter** (лучше) позволяет гибко эмулировать поведение реальных пользователей, управляя таким параметром, как время нарастания нагрузки. Имеет графический интерфейс с интегрированными средствами построения графиков, а также позволяет сохранять результаты и воспроизводить их в автономном режиме ([http://jakarta.apache.org/jmeter/](https://vk.com/away.php?to=http%3A%2F%2Fjakarta.apache.org%2Fjmeter%2F&cc_key=)).

**Инструменты покомпонентного тестирования**

**mysqlslap** эмулирует нагрузку на сервер и выдает данные хронометража. Является частью дистрибутива. Позволяет настроить количество одновременных соединений и передать программе либо команду SQL в командной строке, либо файл с командами SQL, которые нужно выполнить ([http://dev.mysql.com/doc/refman/5.1/en/mysqlslap.html](https://vk.com/away.php?to=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Frefman%2F5.1%2Fen%2Fmysqlslap.html&cc_key=)) 

mysqlslap -h127.0.0.1 -uroot -proot --create-schema=fishki --query="SELECT * FROM a" --concurrency=50 --iterations=200

mysqlslap --query="select user_name,.. from test.user where user_id=1" --number-of-queries=10000000 --concurrency=30 —host=xxx –uroot --create-schema=fishki

**sysbench** многопотоковый инструмент эталонного тестирования операционной сис темы. Позволяет измерить производительности ОС в терминах факторов, существенных для работы сервера базы данных. Например, можно измерить производительность операций файлового ввода/вывода, планировщика операционной системы, выделения памяти и передачи данных, потоков POSIX и самого сервера базы данных. Поддерживает сценарии на языке Lua ([http://sysbench.sourceforge.net](https://vk.com/away.php?to=http%3A%2F%2Fsysbench.sourceforge.net&cc_key=))

**Database** **Test** **Suite** dbt2 бесплатнаяреализацию теста TPC-C OLTP ([http://sourceforge.net/projects/osdldbt/](https://vk.com/away.php?to=http%3A%2F%2Fsourceforge.net%2Fprojects%2Fosdldbt%2F&cc_key=)).

**MySQL** **Benchmark** **Suite** **(****sql** **bench) С**обственный набор инструментов эталонного тестирования MySQL, измеряет скорость выполнения запросов сервером. Cодержит множество готовых тестов ([http://dev.mysql.com/doc/en/mysqlbenchmarks. ht..](https://vk.com/away.php?to=http%3A%2F%2Fdev.mysql.com%2Fdoc%2Fen%2Fmysqlbenchmarks.%26%238239%3Bhtml%2F&cc_key=).)

**Super Smack** ([http://vegan.net/tony/supersmack/](https://vk.com/away.php?to=http%3A%2F%2Fvegan.net%2Ftony%2Fsupersmack%2F&cc_key=))

В книге приведены примеры http_load, sysbench, Database Test Suite, MySQL Benchmark Suite.

# Мониторинг

Мониторинг – способ оценки производительности приложений , чтобы поддерживать ожидаемый уровень сервиса.

Обычно контролируют два вида показателей:

- производительность для конечных пользователей приложения. Пример: время загрузки и время отклика.
- вычислительные ресурсы, используемые приложением. Позволяется выявить узкие места приложений. 

# Профилирование

**Профилирование** — сбор характеристик работы программы, таких как время выполнения отдельных фрагментов (функций). Инструмент, используемый для анализа работы, называют профилировщиком или профайлером (*profiler*). Обычно выполняется совместно с оптимизацией программы.

Профилирование (*profiling*) – помогает найти места, где приложение тратит больше всего времени и потребляет больше всего ресурсов. Профилирование отвечает на вопрос «Почему производительность именно такова?».

## Профилирование приложений

Профилирование на уровне приложения помогает понять, как оптимизировать его наилучшим образом, и дает более точные результаты, поскольку они включают в себя работу, выполненную всей системой.

Узкие места приложений: 

- обращения к внешним ресурсам, например веб-сервисам или поисковым системам
- злоупотребление регулярными выражениями.

Время является подходящей метрикой при профилировании большинства приложений, поскольку конечного пользователя больше всего интересует именно время работы.

При протоколировании результатов работы приложения можно использовать `INSERT DELAYED`, который работает в фоновом режиме. 

Если осуществляется протоколирование результатов работы приложения за период (час, день), то удобнее:

- создать таблицу-шаблон для протоколирования результатов
- из таблицы-шаблона сделать через `CREATE TABLE LIKE` таблицу для протоколирования результатов конкретного периода.

## Логи

https://habr.com/sandbox/22772/

MySQL ведет следующие логи: 

- бинарный лог (*binary log*)


- лог ошибок (*error log*)


- лог медленный запросов (*slow query log*)


- общий лог запросов (*general query log*)


- лог репликаций (*relay log*)


### Error log

Содержит информацию об остановках, запусках сервера, а также сообщения о критических ошибках. Может содержать сообщения с предупреждениями (*warning*s).

Местоположение лога указывается в `my.cnf`:

```ini
log_error = /var/log/mysql/mysql.err
log_warnings = 1                     # если больше 0, то писать в лог
```

### General query log

Здесь регистрируются все запросы, а также некоторые события, например установление и разрыв соединения.

Включить лог и указать его местоположение можно в `my.cnf`:

```ini
general_log_file        = /var/log/mysql/mysql.log  # Местоположение
general_log             = 1                         # Включение лога
```

В общий журнал каждый запрос заносится в момент поступления серверу, поэтому там присутствуют даже те запросы, которые не были выполнены из-за возникших ошибок.  

Общий журнал не содержит сведений о времени выполнения и иной информации, доступной только после завершения запроса. 

### Slow query log

Журнал медленных запросов включает только данные о выполненных запросах. Точнее, здесь протоколируются запросы, выполнение которых заняло время, превышающее установленный порог. Для профилирования могут быть полезны оба журнала, но журнал медленных запросов является основным инструментом, позволяющим выявить проблемные запросы.

Конфигурирование журнала:

```conf
log-slow-queries = <имя_файла> # путь к лог файлу
long_query_time = 2            # регистрировать запросы, выполнение которых занимает больше двух секунд
log-queries-not-using-indexes  # регистрировать запросы, для обработки которых не были задействованы индексы
log-slow-admin-statements      # регистрировать медленные административные запросы, например `OPTIMIZE TABLE`
```

Можно  включать и выключать протоколирование во время исполнения и использовать для хранения журнала таблицы, к которым можно обращаться на языке SQL.

При профилировании имеет смысл протоколировать все запросы с параметром `long_query_time=0`. Если большая часть нагрузки приходится на очень простые запросы, то об этом надо знать. Протоколирование всех подобных запросов окажет некоторое влияние на производительность и потребует существенно больше места на диске – это еще одна причина, по которой не стоит регистрировать все запросы постоянно.

Появление в журнале просто говорит о том, что в тот  момент он обрабатывался долго, но отнюдь не означает, что это повторится сейчас или в будущем. Причины этого: 

- таблица могла быть заблокирована, поэтому запрос был вынужден ждать (можно проверить по `Lock_time`)
- сервер MySQL только запущен
- ночной процесс резервного копирования.

## Инструменты анализа логов

- `mysqldumpslow` поставляется с сервером MySQL. Умеет агрегировать журнал медленных запросов и показывать, сколько раз каждый запрос появляется в журнале.

- `mysql_slow_log_filter` извлечения запросов, которые исполняются дольше определенного порога или просматривают больше указанного количества строк. Хорош для «урезания» файла

  ```bash
  $ tail -f mysql-slow.log | mysql_slow_log_filter -T 0.5 -R 1000
  ```

- `mysql_slow_log_parser` может агрегировать журнал медленных запросов. Показывает минимальное и максимальное значения времени выполнения, количество проанализированных строк, выводит запрос.

- `mysqlsla` (*MySQL Statement Log Analyzer*, http://hackmysql.com/mysqlsla), может анализировать журнал медленных запросов, общий журнал, а также журналы, содержащие команды SQL с разделителями.

- `anemometr` 

##  Профилирование сервера MySQL

### `SHOW STATUS`

Для фильтрации вывода следует использовать `grep`. 

Некоторые параметры:

- `Bytes_received` и ` Bytes_sent` Количество байтов, соответственно полученных и отправленных сервером. 
- `Com_` Команды, которые сервер выполняет
- `Created_` Временные таблицы и файлы, созданные во время выполнения запроса

- `Handler_` Операции подсистемы хранения

- `Select_` Различные типы планов выполнения операции соединения

- `Sort_` Разнообразная информация о сортировке

Профилировать конкретные запросы можно так:

- сбросить счетчики:

  ```mysql
  FLUSH STATUS
  ```

- исполнить запросы

- посмотреть значения счетчиков сессий:

  ```mysql
  SHOW SESSION STATUS
  ```

### `SHOW PROCESSLIST`

### `SHOW PROFILE`

Начать сбор статистики: 

```mysql
SET profiling = 1;
```

Посмотреть запросы, которые были профилированы:

```mysql
SHOW PROFILES
```

Извлечь сохраненные данные профилирования:

```mysql
SHOW PROFILE
```

При запуске без аргументов она показывает каждое состояние (чтение таблицы, создание временной таблицы, удаление, сортировка) и время нахождения в нем для последней выполненной команды

## Профилирование системы

### OProfile

Позволяет посмотреть на что тратились ресурсы:

```
samples  %        app name                 symbol name
259130    4.5199  mysqld                   MYSQLparse(void*)
196841    3.4334  mysqld                   my_pthread_fastmutex_lock
106439    1.8566  libc-2.5.so              _int_malloc
```

### newrelic

### okmeter.io

# Особенности оптимизации

Менеджерам незнакомым с БД необходимо объяснять, что незначительная, на первый взгляд, функция удвоит требования к оборудованию. В этом случае они могут решить, что без нее вполне можно обойтись.

# Типы данных

Нужно стараться использовать типы данных минимального размера, т.к. они обычно быстрее, поскольку занимают меньше места на диске, в памяти и в кэше процессора, для их обработки требуется меньше процессорного времени. Следует выбирать верные типы данных: 

- для даты и времени – встроенные типы дат, а не строки
- для IP-адресов – целочисленные типы данных. 

## `NULL`

Желательно определять столбцы как `NOT NULL`. Оптимизация запросов, содержащих допускающие `NULL` столбцы, вызывает дополнительные сложности:

- из-за них усложняются индексы, статистика индексов и сравнение значений. 
- Столбец, допускающий `NULL`, занимает больше места на диске и требует специальной обработки внутри MySQL. 
- Когда такой столбец проиндексирован, ему требуется дополнительный байт для каждой записи
- в MyISAM даже может возникнуть ситуация, когда придется преобразовать индекс фиксированного размера (например, индекс по одному целочисленному столбцу) в индекс переменного размера. 

Даже когда требуется представить в таблице факт отсутствия значения, можно обойтись без использования `NULL`. Вместо этого можно использовать нуль, специальное значение или пустую строку.

## Числа

### Целые числа

Для хранения целых чисел используются: 

- `TINYINT` (8 бит)
- `SMALLINT` (16 бит)
- `MEDIUMINT` (24 бита)
- `INT` (32 бита)
- `BIGINT` (64 бита).

Могут иметь необязательный атрибут `UNSIGNED`. 

Можно указать «размер», например `INT(11)`. Для большинства приложений это не имеет значения: диапазон возможных значений этим не ограничивается. Однако данный параметр говорит некоторым интерактивным инструментам MySQL (например, клиенту командной строки), сколько позиций необходимо зарезервировать для вывода числа. С точки зрения хранения и вычисления `INT(1)` и `INT(20)` идентичны.

Для вычислений с целыми числами обычно используются 64-разрядные целые типа `BIGINT`, даже на машинах с 32-разрядной архитектурой. 

### Вещественные числа

#### Точные (exact) типы

Тип данных `DECIMAL`. 

Также можно хранить большие целые числа, не помещающиеся в типе `BIGINT`. 

`DECIMAL` предназначен для хранения точных дробных чисел. Для столбца типа `DECIMAL` вы можете указать максимально разрешенное количество цифр до и после десятичной запятой. `DECIMAL(18, 9)` будет хранить девять цифр с каждой стороны десятичной точки, используя в общей сложности девять байтов: четыре для цифр перед десятичным разделителем, один для самой десятичной точки и четыре для цифр после нее.

#### Неточные (inexact) типы

Типы данных:

- `FLOAT`
- `DOUBLE`

Допускают приближенные математические вычисления с плавающей точкой. Чем выше значение, тем меньше абсолютная точность. Например, для `FLOAT` максимальное значение мантиссы 2<sup>23</sup>  и с увеличение порядка точность хранения исходного числа падает.

Существуют способы указать желаемую точность так, что MySQL незаметно для пользователя выберет другой тип данных или будет округлять значения при сохранении. Эти спецификаторы точности нестандартны, поэтому желательно задавать тип, но не задавать точность.

Для вычислений используется тип DOUBLE (?).

## Строковые типы

### `VARCHAR`

Тип `VARCHAR` хранит символьные строки переменной длины и является наиболее общим строковым типом данных. Строки этого типа занимают меньше места, чем строки фиксированной длины. В типе `VARCHAR` используется один или два дополнительных байта для хранения длины строки: 

- один байт, если максимальная длина строки в столбце не превышает 255 байт
- два байта в случае более длинных строк.

`VARCHAR` увеличивает производительность за счет меньшего потребления места на диске. Однако поскольку строки имеют переменную длину, они способны увеличиваться при обновлении, что вызывает дополнительную работу.

Имеет смысл использовать тип `VARCHAR` при соблюдении хотя бы одного из следующих условий: 

- максимальная длина строки в столбце значительно больше средней
- обновление поля выполняется редко, так что фрагментация не представляет проблемы
- используется UTF-8, в которой для хранения одного символа используется переменное количество байтов.

Есть ли разница между `VARCHAR(5)` и `VARCHAR(200)` при хранении короткой строки? Для столбца большей размерности может потребоваться намного больше памяти, поскольку MySQL часто выделяет для внутреннего хранения значений участки памяти фиксированного размера. Это особенно плохо для сортировки или операций, использующих временные таблицы в памяти и на диске. 

### `CHAR`

Тип `CHAR` имеет фиксированную длину – MySQL всегда выделяет место для указанного количества символов. При сохранении значения `CHAR` MySQL удаляет все пробелы в конце строки.

Тип `CHAR` полезен, когда требуется сохранять очень короткие строки или все значения имеют приблизительно одинаковую длину. Например, `CHAR` является хорошим выбором для хранения MD5-сверток паролей пользователей. Однако для режима UTF8 под каждый символ выделяется по 3 байта.

### `BINARY` и `VARBINARY`

Родственными типами для `CHAR` и `VARCHAR` являются `BINARY` и `VARBINARY`, предназначенные для хранения двоичных строк. Двоичные строки очень похожи на обычные, но вместо символов в них содержатся байты. В строки типа `BINARY` добавляется нулевой байт `\0` вместо пробелов и не удаляются дополненные байты при извлечении. Необходимы для сохранения двоичных данных, и чтобы MySQL сравнивал значение как байты, а не как символы. Двоичное сравнение проще и быстрее символьного.

### `BLOB` 

Строковые типы `BLOB` и `TEXT` предназначены для хранения больших объемов двоичных или символьных данных соответственно. 

Символьные типы:

- `TINYTEXT`
- `SMALLTEXT` = `TEXT`
- `MEDIUMTEXT`
- `LONGTEXT`

Двоичные типы:

- `TINYBLOB`
- `SMALLBLOB` = `BLOB`
- `MEDIUMBLOB`
- `LONGBLOB`

В отличие от всех остальных типов данных, MySQL обрабатывает значения `BLOB` и `TEXT` как отдельные объекты. Подсис темы хранения зачастую взаимодействуют с ними особым образом; InnoDB может помещать их в отдельную «внешнюю» область хранения, если они имеют большой размер. Каждому значению такого типа требуется от 1 до 4 байтов в самой строке и достаточное место во внешнем хранилище для хранения фактического значения.

Единственное различие между семействами `BLOB` и `TEXT` заключается в том, что типы `BLOB` хранят двоичные данные без учета схемы упорядочения и кодировки, а с типами `TEXT` ассоциированы схемы упорядочения и кодировка. 

СУБД MySQL сортирует столбцы `BLOB` и `TEXT` иначе, чем столбцы других типов: вместо сортировки строк по всей длине хранимых данных, она сортирует только по первым `max_sort_length` байтам. Если нужна сортировка только по нескольким первым символам, то можно либо уменьшить значение серверной переменной `max_sort_length`, либо использовать конструкцию `ORDER BY SUBSTRING(column, length)`. MySQL не может индексировать данные этих типов по полной длине и не может использовать для сортировки индексы.

### `ENUM`

Иногда вместо обычных строковых типов можно использовать тип `ENUM`. В столбце типа `ENUM` можно хранить до 65 535 различных строковых значений. MySQL сохраняет их очень компактно, упаковывая в один или два байта в зависимости от количества значений в списке. MySQL воспринимает каждое значение как целое число, представляющее позицию значения в списке значений поля, и отдельно хранит в `frm`-файле «справочную таблицу», определяющую соответствие между числом и строкой. 

Пример:

```mysql
CREATE TABLE enum_test(e ENUM('fish', 'apple', 'dog') NOT NULL );
INSERT INTO enum_test(e) VALUES('fish'), ('dog'), ('apple'); 
```

Во всех трех строках таблицы в действительности хранятся целые числа, а не строки. Убедиться в двойственной природе значений можно, если извлечь их в числовом контексте:

```mysql
mysql> SELECT e + 0 FROM enum_test; 
+-------+ 
| e + 0 | 
+-------+ 
| 1     | 
| 3     |
| 2     | 
+-------+

```

Главным недостатком столбцов типа `ENUM` является то, что список строк фиксирован, а для их добавления или удаления необходимо использовать команду `ALTER TABLE`.

Поскольку MySQL сохраняет каждое значение как целое число и вынуждена выполнять просмотр таблицы соответствий для преобразования числа в строковое представление, то со столбцами типа `ENUM` связаны некоторые накладные расходы. В частности, соединение столбца типа `CHAR` или `VARCHAR` со столбцом типа `ENUM` может оказаться медленнее, чем с другим столбцом типа `CHAR` или `VARCHAR`.

## Даты

Минимальной единицей времени, которую может хранить MySQL, является одна секунда. 

### Типы данных для хранения части даты

- `YEAR`
- `DATE`

- ...

### Типы для хранения даты и времени

- `DATETIME`
- `TIMESTAMP`

Большинству приложений подходят оба, но в некоторых случаях один работает лучше, чем другой.

Тип `DATETIME` позволяет хранить значения в большом диапазоне, с 1001 до 9999 года, с точностью в одну секунду. Дата и время упаковываются в целое число в формате `YYYYMMDDHHMMSS` независимо от часового пояса. Под значение отводится 8 байт.

`TIMESTAMP` хранит количество секунд, прошедших с `1970-01-01 00:00:00`. Для хранения типа `TIMESTAMP` используется только 4 байта, поэтому он позволяет представить меньший диапазон дат, чем тип `DATETIME`: с 1970 года до некоторой даты в 2038 году. 

Имеются функции `FROM_UNIXTIME()` и `UNIX_TIMESTAMP()`, служащие для преобразования временной метки UNIX в дату и наоборот. 

При выводе значения типа `TIMESTAMP` форматируются точно так же, как значения `DATETIME`. 

Отображаемое значение типа `TIMESTAMP` зависит также от часового пояса. Часовой пояс определен для сервера MySQL, операционной системы и клиентского соединения. Таким образом, если в поле типа `TIMESTAMP` хранится значение `0`, то для часового пояса `Eastern Standard Time`, отличающегося от гринвичского времени на 5 часов, будет выведена строка `1969-12-31 19:00:00`. 

Если вы не указали значение для столбца, MySQL вставляет в первый столбец типа `TIMESTAMP` текущее время. 

Столбцы типа `TIMESTAMP` по умолчанию создаются в режиме `NOT NULL`. Рекомендуется пользоваться типом TIMESTAMP, если это возможно, поскольку с точки зрения занимаемого места на диске он гораздо эффективнее, чем `DATETIME`.

Если нужно сохранять значение даты и времени с точностью большей, чем одна секунда, нужно использовать свой собственный формат хранения, скажем, сохранять временную метку с микросекундной точностью в типе данных `BIGINT` либо воспользоваться типом `DOUBLE` и поместить дробную часть секунды после десятичной точки.

### Битовые типы данных

С технической точки зрения являются строковыми. Столбец типа **BIT** позволяет храненить один или нескольких значений true/false в одном столбце. BIT(1) определяет поле, содержащее один бит, BIT(2) – два бита и т. д. Максимальная длина столбца типа BIT равна 64 битам. Поведение типа BIT зависит от подсистемы хранения. MyISAM объединяет битовые столбцы, поэтому для хранения 17 отдельных столбцов типа BIT требуется только 17 бит (в предположении, что ни в одном из столбцов не разрешено значение NULL). При вычислении размера места для хранения MyISAM округлит это число до трех байтов. Memory и InnoDB, представляют каждый столбец как наименьший целочисленный тип, достаточно большой для размещения всех битов, поэтому сэкономить пространство не получится.

При извлечении значения типа BIT(1), результатом является строка, но ее содержимое представляет собой двоичное значение 0 или 1, а не значение «0» или «1» в кодировке ASCII. Однако если вы извлечете значение в числовом контексте, результатом будет число, в которое преобразуется битовая строка.

mysql> CREATE TABLE bittest(a bit(8)); 
 mysql> INSERT INTO bittest VALUES(b’00111001’); 
 mysql> SELECT a, a + 0 FROM bittest; 
 +------+-------+ 
 | a | a + 0 | 
 +------+-------+ 
 | 9 | 57 | 
 +------+-------+

Вариантом является создание столбца типа CHAR(0) с возможностью хранения NULL ((в INNO DB экономия 10%). Однако такой столбец нельзя индексировать. Для проверки значения нужно использовать:

```
'a' IS NULL     ==> 'a' <=> NULL
'a' IS NOT NULL ==> NOT('a' <=> NULL)
```

 

Если нужно сохранять много значений true/false, попробуйте объединить несколько столбцов в один столбец типа SET. В MySQL его внутренним представлением является упакованный битовый вектор, эффективно использующий пространство. MySQL содержит такие функции, как FIND_IN_SET() и FIELD(), которые можно легко использовать в запросах. Главным недостатком является стоимость изменения определения столбца: эта процедура выполняется с помощью команды ALTER TABLE, которая для больших таб лиц обходится очень дорого. В общем случае при поиске в столбцах типа SET не используются индексы.

Альтернативой типу SET является использование целого числа как упакованного набора битов. Главным преимуществом такого подхода по сравнению с использованием типа SET является то, что вы можете изменить «нумерацию» представляемого поля без обращения к команде ALTER TABLE.

mysql> CREATE TABLE acl ( 
 -> perms SET(‘CAN_READ’, ‘CAN_WRITE’, ‘CAN_DELETE’) NOT NULL 
 -> ); 
 mysql> INSERT INTO acl(perms) VALUES (‘CAN_READ,CAN_DELETE’); 
 mysql> SELECT perms FROM acl WHERE FIND_IN_SET(‘CAN_READ’, perms); 
 +---------------------+ 
 | perms | 
 +---------------------+ 
 | CAN_READ,CAN_DELETE | 
 +---------------------+

Выбор типа данных для столбца идентификатора имеет очень большое значение. т.к. этот столбец будет сравниваться с другими значениями (например, в соединениях) и использоваться для поиска чаще, чем другие столбцы.

Должен использоваться один и тот же тип во всех связанных таблицах. Типы должны совпадать в точности, включая такие свойства как UNSIGNED. 

Целые типы обычно лучше всего подходят для идентификаторов, поскольку они работают быстро и допускают автоматический инкремент (AUTO_INCREMENT). Следует избегать задания для идентификаторов строковых типов, поскольку они занимают много места и обычно обрабатываются медленнее, чем целочисленные типы.

Случайно сгенерированный ключи например md5 могут замедлить работу команд INSERT и некоторых типов SELECT: INSERT, поскольку вставленное значение должно быть помещено в случайное место в индексах. SELECT, так как логически соседние строки оказываются разбросаны по всему диску и весь набор данных одинаково «горячий», то не имеет смысла сохранять какие-то части информации в кэше, а если рабочее множество не помещается в памяти, то будут иметь место частые непопадания и вытеснения из кэша.

IP-адреса необходимо хранить как беззнаковые целые числа. В MySQL имеются функции INET_ATON() и INET_NTOA() для преобразования между двумя представлениями.

## Основы индексирования 

Индексы представляют собой структуры, которые помогают MySQL эффективно извлекать данные. 

Небольшие, слабо загруженные БД зачастую могут удовлетворительно работать даже без правильно построенных индексов, по следующим причинам:

·   количество запросов к БД и объем перебираемых данных при fullscan невелики

·   база данных влезает целиком в память. Операции последовательного и прозвольного I/O в памяти выполняются очень быстро. 

Как только база данных начнет вылезать за пределы оперативной памяти, начинает вырастать объем операций дискового I/O при fullscan, время выполнения запросов резко возрастает.

Способ решения проблемы – настроить индексирование, с целью сократить рабочее множество данных, чтобы оно сново начало помещаться в память. Сделать так, чтобы выполнялось не полное сканирование таблицы с использованием дискового I/O, а произвольный поиск по индексу в небольшом рабочем множестве в памяти. 

Индекс в MySQL аналог алфавитного указателя в книге. Индексы реализуются на уровне подсистем хранения, а не на уровне сервера. Не стандартизованы: в каждой подсис теме индексы работают немного по-разному, и далеко не все подсистемы допускают использование существующего разнообразия индексов.

### B-Tree

#### Теория

##### B-дерево

B-дерево – сбалансированное, сильно ветвистое дерево порядка   (обычно принимает значения от 50 до 2000 в зависимости от того сколько записей помещается на страницу). Предназначено для хранения данных во внешней памяти. Сбалансированность означает, что длина любых двух путей от корня до листьев различается не более, чем на единицу. Ветвистость дерева — это свойство каждого узла дерева ссылаться на большое число узлов-потомков. 

B-дерево обладает свойствами:

·  Ключи в каждом узле упорядочены для быстрого доступа к ним. Корень содержит от 1 до   ключей. Любой другой узел содержит от   до    ключей,.

·   Любой узел (кроме листа), содержащий ключи   имеет   потомков. При этом

\1.  Первый потомок и все его потомки содержат ключи из интервала   

\2.  Для   , i-й потомок и все его потомки содержат ключи из  интервала   

\3.    -й потомок и все его потомки содержат ключи из интервала   

·   Глубина всех листьев одинакова.

**Процесс поиска**: если ключ содержится в корне, он найден. Иначе определяем интервал и идём к соответствующему потомку. 

Преимущества:

·   снижение количества операций ввода-вывода при поиске элемента

·   операции над данными выполняются блоками, блок (страница) читается с диска и блоком размещается в памяти.

·   при поиске выполняется последовательное чтение элементов из узлов с большим количеством ключей, а не произвольное (в случае бинарного).

  

Высота B-дерева с   узлами не превышает   (намного меньше чем у бинарного), соответственно при поиске нужно выполнить   дисковых операций, сложность поиска   

##### B+ дерево

Отличие B+ дерева:

·   Все ключи хранятся только в листьях, там же хранится и информационная часть узла (в стандартных B-деревьях ключи хранятся также во внутренних узлах). Во внутренних узлах хранятся копии ключей – они помогают искать нужный лист.

·   Поскольку все ключи хранятся только в листьях, листья связываются последовательно, что позволяет быстро обходить дерево в порядке возрастания ключей

  

##### B* B+* деревья

B*-дерево — разновидность B-дерева, в которой каждый узел дерева заполнен не менее чем на ⅔ (в отличие от B-дерева, где этот показатель составляет 1/2). B+-дерево, удовлетворяющее таким требованиям называется B+*-деревом. Это свойство приводит к лучшему использованию места, занимаемого деревом, и чуть лучшей производительности.

Обычные индексы в MySQL B-Tree индексы. MyISAM использует технику сжатия префикса, позволяющая уменьшить размер индекса, а InnoDB не сжимает индексы, поскольку это снижает производительность. MyISAM ссылается на индексированные строки по их физическому адресу на диске, а InnoDB – по значениям первичного ключа.

InnoDB использует структуру данных B+Tree. Листовые страницы представляют собой особый случай, так как в них находятся указатели на индексированные данные, а не на другие страницы.

​    

На рисунке выше показана только одна узловая страница и соответствующие ей листовые страницы, но между корнем и листьями может быть много уровней узловых страниц. Глубина дерева зависит от того, насколько велика таблица.

B-Tree-индексы полезны: поиск по полному значению, поиск по самому левому префиксу, поиск по префиксу столбца, поиск по диапазону значений, поиск по  полному совпадению одной части и диапазону в другой части, запросы только по индексу (покрывающие индексы).

Поскольку узлы дерева отсортированы, их можно использовать как для поиска значений, так и в запросах ORDER BY. Если B-Tree индекс позволяет найти строку по определенному критерию, то его можно использовать и для сортировки строк по тому же критерию.

Подсистема хранения не может оптимизировать поиск по столбцам, находящимся правее первого столбца, по которому осуществляется поиск в заданном диапазоне. Например, для запроса WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’ будут использованы только первые два столбца индекса. Для столбца, имеющего ограниченное количество значений, вы можете применить обходной маневр, указав условия равенства вместо условия на диапазон.

### Хэш индексы

**Хеш индекс** строится на основе хеш-таблицы и полезен только для точного поиска с указанием всех столбцов индекса. Для каждой строки подсистема хранения вычисляет хеш код индексированных столбцов – сравнительно короткое значение, которое, скорее всего, будет различно для строк с разными значениями ключей. В индексе хранятся хеш- коды и указатели на соответствующие строки. В MySQL только подсистема хранения Memory поддерживает явные хеш-индексы.

При выполнении запроса 

mysql> SELECT lname FROM testhash WHERE fname=’Peter’; 
 MySQL вычислит хеш-код значения ‘Peter’ и использует его для поиска указателя в индексе. Поскольку f(‘Peter’)= 8784, MySQL будет искать в индексе значение 8784. Конечным шагом будет сравнение значения в строке с ‘Peter’, с целью убедиться, что это действительно искомая строка.

Поскольку в хеш-индексе хранятся только короткие хеш-коды, то такие индексы очень компактны. Длина хеш-кода не зависит от типа индексируемого столбца – хеш-индекс по столбцу TINYINT будет иметь такой же размер, как и хеш-индекс по большому текстовому столбцу. Поиск очень быстрый. Ограничения хеш-индексов: 

·   MySQL не может использовать данные в индексе, чтобы избежать чтения строк.

·   MySQL не может использовать хеш-индексы для сортировки, поскольку строки в нем не хранятся в отсортированном порядке.

·   Хеш-индексы не поддерживают поиск по частичному ключу, так как хеш-коды вычисляются для всего индексируемого значения.

·   Хеш-индексы поддерживают только сравнения на равенство, использующие операторы =, IN() и <=>

·   Доступ к данным в хеш-индексе очень быстр, если нет большого количества коллизий

Некоторые операции обслуживания индекса могут оказаться медленными, если количество коллизий велико. Например, если создан хеш-индекс по столбцу с очень маленькой селективностью, что означает много коллизий, то операции поиска в индексу будут очень медленными. 

Вариант применения: реализация NOSQL системы key-value типа Memcached, за счет быстрого поиска в HashTable по ключу в памяти. Аналогом команды SET является REPLACE.

Подсис тема хранения InnoDB поддерживает так называемые адаптивные хеш индексы, которые она строит сама при частои доступе к данным. Этот процесс полностью автоматический, и вы не можете ни контролировать, ни настраивать его.

Если подсистема хранения не поддерживает хеш-индексы, то вы можете эмулировать их самостоятельно. Для этого необходимо создать псевдохеш-индекс поверх стандартного B-Tree-индекса. Он не совсем идентичен настоящему хеш-индексу, поскольку для поиска по-прежнему будет использоваться B-Tree-индекс. Однако искаться будут хеш-коды ключей вместо самих ключей. От вас требуется лишь вручную указать хеш-функцию во фразе WHERE запроса. Это позволяет использовать некоторые достоинства хеш-индексов, например небольшие размеры при очень длинных ключах. Примером хорошей работы подобного подхода является поиск адресов URL. Необходимо добавить в таб лицу индексированный столбец url_crc, тогда запрос будет иметь вид:

mysql> SELECT id FROM url WHERE url=”[http://www.mysql.com](https://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.com&cc_key=)” AND url_crc=CRC32(“[http://www.mysql.com](https://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.com&cc_key=)”); 

оптимизатор запросов замечает, что существует небольшой высокоизбирательный индекс по столбцу url_crc. Одним из недостатков данного решения является необходимость обновлять хеш-значения. Вы можете делать это вручную или – в MySQL 5.0 и более поздних версиях – использовать триггеры. не следует использовать хеш-функции SHA1() или MD5(). Они возвращают очень длинные строки, которые требуют много пространства и приводят к замедлению сравнения. Простые хеш-функции могут дать приемлемый уровень коллизий с лучшей производительностью. Одним из способов реализации 64-разрядной хеш-функции является использование только части значения, возвращаемого функцией MD5().

mysql> SELECT CONV(RIGHT(MD5(‘[http://www.mysql.com/](https://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.com%2F&cc_key=)’), 16), 16, 10) AS HASH64;

При поиске значения по его хеш-коду следует включать во фразу WHERE и само искомое значение в связи с наличием коллизий (парадокс ДР): 
 mysql> SELECT id FROM url WHERE url_crc=CRC32(“[http://www.mysql.com](https://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.com&cc_key=)”) 
 -> AND url=”[http://www.mysql.com](https://vk.com/away.php?to=http%3A%2F%2Fwww.mysql.com&cc_key=)”;

### Пространственные индексы

(Spatial, R-Tree) MyISAM поддерживает пространственные индексы, которые можно 
 строить по стобцам пространственного типа, например GEOMETRY.

### Полнотекстовые индексы

Позволяют искать в тексте ключевые слова, а не сравнивать искомое значение со значениями в столбце. Напоминает поисковые сис темы, предназначены для операций MATCH AGAINST.

### Стратегии индексирования

Столбец индексирования должен быть изолирован и не должен быть частью выражения или употребляться в качестве аргумента внутри функции. Например, здесь не сработает:

mysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;

Необходимо упрощать критерии во фразе WHERE, так, чтобы индексированный столбец оказывался в одиночестве по одну сторону от оператора сравнения. 
 Такой запрос без индекса 
 mysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE)- TO_DAYS(date_col)

может быть преобразован в запрос с индексом: 

mysql> SELECT ... WHERE date_col >= DATE_SUB(‘2008-01-17’, INTERVAL 10 DAY); 

### Префиксные индексы

При индексировании длинных символьных столбцов можно эмулировать хеш-индекс. Другой вариант – индексирование первых нескольких символов. Индекс будет занимать меньше места, но станет менее селективным. Селективность  индекса – это отношение количества различных проиндексированных значений (кардинальности) к общему количеству строк в таблице ([#T](https://vk.com/feed?section=search&q=%23T)). Диапазон возможных значений селективности от 1/[#T](https://vk.com/feed?section=search&q=%23T) до 1. Индекс с высокой селективностью позволяет MySQL при поиске соответствий отфильтровывать больше строк. Уникальный индекс имеет селективность, равную единице.

При индексировании столбцов типа BLOB или TEXT, либо очень длинных столбцов VARCHAR необходимо определять префиксные индексы, поскольку MySQL не позволяет индексировать такие столбцы по их полной длине. При выборе длины префикса кардинальность префикса должна быть почти такой же, как кардинальность всего столбца. Способ нахождения длины префикса. Сначала находим наиболее часто встречающиеся города: 

SELECT COUNT(*) AS cnt, city FROM sakila.city_demo GROUP BY city ORDER BY cnt DESC LIMIT 10;

+-----+----------------+ 
 | cnt | city | 
 +-----+----------------+ 
 | 65 | London |

Идея состоит в увеличении длины префикса до тех пор, пока он не станет почти таким же селективным, как полная длина столбца:

SELECT COUNT(*) AS cnt, LEFT(city, 7) AS pref -> FROM sakila.city_demo GROUP BY pref ORDER BY cnt DESC LIMIT 10; 

+-----+---------+ 
 | cnt | pref | 
 +-----+---------+ 
 | 70 | Santiag |

Другой способ вычислить селективность полного столбца и префикса. Селективность полного столбца: 
 SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;

Селективность нескольких длин префиксов: 

SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3, 

COUNT(DISTINCT LEFT(city, 4))/COUNT(*) AS sel4

FROM sakila.city_demo;

Эффективней первый способ т.к. показывает селективность по распространенным значениям, а селективность по ним всегда ниже, чем средняя селективность. из-за неравномерности распределения значений.

Добавление индекса по префиксу столбца: 
 mysql> ALTER TABLE sakila.city_demo ADD KEY (city(7));

MySQL не может использовать префиксные индексы ни для запросов с фразами ORDER BY и GROUP BY, ни как покрывающие индексы.

MySQL не поддерживает индексы по реверсированному ключу (суффиксные индексы). Но можно самостоятельно хранить реверсированные строки и создавать по ним префиксный индекс. Поддерживать этот индекс можно с помощью триггеров

### Кластерные индексы

вторичные индексы (отличные от индекса по первичному ключу) содержат все столбцы, составляющие первичный ключ, так что если первичный ключ длинный, то все прочие индексы будут большими. Если над таблицей построено много индексов, то первичный ключ нужно делать как можно меньшим.

 

Означает что B-Tree-индекс содержит и сами строки и индекс в одной и той же структуре. Когда над таблицей построен кластерный индекс, в листовых страницах индекса хранятся сами строки. Термин «кластерный» означает, что строки с близкими значениями ключа хранятся по соседству. Над таблицей можно построить только один кластерный индекс, поскольку невозможно хранить одну и ту же строку одновременно в двух местах подсис темы хранения. Кластерные индексы поддерживает только InnoDB. листовые страницы содержат сами строки, а узловые – только индексированные столбцы. InnoDB кластеризует данные по первичному ключу. Если он не определен, то InnoDB попытается использовать вместо него уникальный индекс, не допускающий пустых значений. Если такого индекса не существует, InnoDB определит скрытый первичный ключ за вас и затем кластеризует таблицу по нему. InnoDB 
 кластеризует записи вместе только внутри страницы. Разные страницы с близкими значениями ключей могут оказаться далеко друг от друга.

  

Преимущества: хранение связанных данных рядом. хранение индекса и данных вместе в одной B-Tree структуре, поэтому извлечение строк из кластерного индекса происходить быстро. Недостатки: имеют смысл если рабочая нагрузка характеризуется большим количеством операций ввода/вывода. Если данные помещаются в памяти, то порядок доступа к ним не имеет значения.

Вставка данных в порядке первичного ключа очень быстрая. Если вставка данных осуществляется в другом порядке можно реорганизовать таблицу с помощью команды OPTIMIZE TABLE. Обновление столбцов кластерного индекса дорого, т.к. необходимо перемещать каждую обновленную строку в новое место. Вставка новых строк или обновление первичного ключа, требующее перемещения строки, может приводить к расщеплению страницы. В листовых узлах вторичных ключей хранятся значения столбцов, составляющих первичный ключ, что приводит к их увеличению. Для доступа к данным по вторичному индексу требуется просмотр двух индексов вместо одного. В листовом узле содержится не указатель на физический адрес строки, а значение ее первичного ключа.

Структура данных InnoDB и MyISAM для таблицы: 

CREATE TABLE layout_test ( 
 col1 int NOT NULL, 
 col2 int NOT NULL, 
 PRIMARY KEY(col1), 
 KEY(col2) 
 );

MyISAM сохраняет данные на диске в том порядке, в котором они были вставлены: 

  

Структура первичного индекса, аналогична структуре любого другого индекса.

  

Каждый листовой узел в индексе содержит номер строки. В MyISAM отсутствуют структурные различия между первичным ключом и любым другим индексом. Первичный ключ является просто уникальным индексом, не допускающим пустых значений под названием PRIMARY.

Кластерный индекс в InnoDB «является» таб лицей и отдельного хранилища для строк, как в MyISAM, нет. Листовый узел содержит значение первичного ключа и другие столбцы (col2).

  

Листовые узлы вторичных индексов содержат вместо «указателей на строки» значения первичного ключа, которые выступают в роли таких «указателей». Это уменьшает объем работы, необходимой для обслуживания вторичных индексов при перемещении строки или в момент расщепления страницы данных, однако это увеличивает размер индекса.

Использование непоследовательных кластерных ключей (типа хешей):делает вставку в кластерный индекс случайной, что является худшим сценарием, и не приводит 
 к полезной кластеризации данных. При использовании InnoDB нужно стремиться к вставке данных в порядке, соответствующем первичному ключу. Однако иногда вставка в порядке первичного ключа оказывается хуже, т.к. «горячей точкой» является последняя страница первичного индекса. Поскольку все вставки происходят именно здесь, возникает состязание за блокировку следующего ключа и/или блокировку автоинкремента 

### Покрывающие индексы

MySQL может использовать индекс для извлечения данных, не считывая строку таб лицы. Это возможно для индексов, который содержит (или «покрывает») все данные, необходимые для формирования результатов запроса. Преимущества:

Записи индекса обычно компактнее полной строки, поэтому, если MySQL читает только индекс, то обращается к значительно меньшему объему данных.

Индексы отсортированы по индексируемым значениям, поэтому для поиска по диапазону потребуется меньше операций обращения к диску по сравнению с извлечением каждой строки из произвольного места хранения.

MyISAM, кэшируют в памяти MySQL только индексы. Поскольку кэширование данных для MyISAM выполняет операционная система, доступ к ним обычно требует сис темного вызова. Это может оказать огромное влияние на производительность,

Вторичный покрывающий индекс в InnoDB  позволяет избежать еще одного поиска по первичному индексу.

Индекс должен хранить значения индексируемых столбцов. Хеш-индексы, пространственные индексы и полнотекстовые индексы такие значения не хранят, поэтому MySQL может использовать в качестве покрывающих только B-Tree-индексы.

Запустив команду EXPLAIN для запроса, «покрываемого» индексом, вы увидите в столбце Extra сообщение «Using index».

Если поля выборки не покрываются индексом, можно переписать запрос путем join с вложенным запросом, который заключается в выборке из этой же таблицы первичного ключа с условиями, покрываемые индексом. InnoDB хранят в листовых узлах значения первичного ключа. Это означает, что вторичные индексы имеют «дополнительные столбцы», которые можно использовать для «покрытия» запросов.

SELECT * FROM products JOIN (

   SELECT prod_id

   FROM products

   WHERE actor=’SEAN CARREY’ AND title LIKE ‘%APOLLO%’

) AS t1 ON (t1.prod_id=products.prod_id)

### Просмотр индекса для сортировки

Есть два способа получения отсортированных результатов: использовать файловую сортировку или просматривать индекс по порядку. Слово «index» в столбце type EXPLAIN говорит о сортировке по индексу. Просмотр самого индекса производится быстро, поскольку сводится просто к перемещению от одной записи к другой. Однако если MySQL не использует индекс для «покрытия» запроса, ей приходится считывать каждую строку, которую она находит в индексею, это операции ввода/вывода с произвольным доступом, чтение происходит значительно медленнее,

Сортировка по индексу сработает, если:

·     все столбцы отсортированы в одном направлении (по возрастанию или по убыванию). 

·     Если в запросе соединяется несколько таблиц, то необходимо, чтобы во фразе ORDER BY упоминались только столбцы из первой таблицы. 

·     Должен быть указан самый левый префикс ключа, либо для начальных столбцов индекса в параметрах WHERE или JOIN заданы константы в условии

Во всех остальных случаях MySQL использует файловую сортировку.

Пример индекса:

UNIQUE KEY rental_date (rental_date,inventory_id,customer_id),

Ниже перечислены запросы, которые его не будут использовать:

·   Указано два разных направления сортировки, но все столбцы индекса отсортированы по возрастанию: 

 WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id DESC, customer_id ASC; 

·   Во фразе ORDER BY указан столбец, отсутствующий в индексе: 

WHERE rental_date = ‘2005-05-25’ ORDER BY inventory_id, staff_id; 

·   Столбцы, заданные во фразах WHERE и ORDER BY, не образуют левый префикс ключа: 

 WHERE rental_date = ‘2005-05-25’ ORDER BY customer_id;

·   Присутствует условие поиска по диапазону: 

WHERE rental_date > ‘2005-05-25’ ORDER BY inventory_id, customer_id; 

·   Используется оператор IN (), который с точки зрения оптимизатора то же самое, что поиск по диапазону. 

 WHERE rental_date = ‘2005-05-25’ AND inventory_id IN (1,2) ORDER BY customer_id;

### Упакованные (сжатые по префиксу) индексы

MyISAM использует префиксное сжатие для уменьшения размера индекса. По умолчанию упаковываются только строковые значения, но вы можете затребовать также сжатие целочисленных значений. Для сжатия блока индекса MyISAM сохраняет первое значение полностью, а при сохранении каждого последующего значения в том же блоке записывает только количество байтов, совпадающих с частью префикса, плюс отличающиеся данные суффикса. Преимущество: сжатые блоки занимают меньше места, недостаток: MyISAM не может выполнить двоичный поиск для нахождения нужного элемента и вынужден просматривать блок с самого начала. Упакованные ключи замедляют поиск по индексу в таб лицах MyISAM в несколько раз из-за дополнитеного сканирования, требуемого для выполнения произвольного поиска. Поиск упакованного ключа в обратном направлении происходит еще медленнее. Управлять упаковкой индексов в таблице с помощью параметра PACK_KEYS команды CREATE TABLE.

### Избыточные и дублирующие индексы

Индексы различных типов (например, хеш-индексы или полнотекстовые индексы) не являются избыточными по отношению к B-Tree-индексам вне зависимости от того, какие столбцы они покрывают.

Бывают случаи, когда избыточные индексы необходимы по причинам, связанным с производительностью. Например, если у вас есть индекс по целочисленному столбцу, и вы расширяете его длинным столбцом типа VARCHAR, он может стать значительно более медленным. Особенно это относится к случаям, когда ваши запросы используют покрывающий индекс,

### Индексы и блокировки

Индексы в InnoDB позволяют блокировать меньше строк при выполнении запроса, т.к. InnoDB блокирует строки только в момент доступа к ним, а индекс позволяет уменьшить количество строк, к которым обращается InnoDB, и, следовательно, блокирует их. Однако это работает только в том случае, когда InnoDB может отфильтровывать ненужные строки на уровне  подсис темы хранения. Если индекс не позволяет InnoDB сделать это, т.е. в Explain написано Using where, то сервер MySQL вынужден применять фразу WHERE после того, как InnoDB извлечет строки и вернет их серверу. К этому моменту уже невозможно избежать блокировки строк:

Индексы должны создаваться с учетом знания того, какие запросы будут их использовать. Если запускается много длинных агрегирующих запросов для формирования сводных отчетов, то диску станет легче от наличия покрывающих индексов, которые поддерживают запросы с фразой GROUP BY. Индексы должны быть максимально селективными, поскольку они дают больший выигрыш. Если для запроса нет индекса, MySQL придется выполнять полное сканирование таблицы и блокировать каждую строку, вне зависимости от того, нужна она или нет.

### Практические примеры индексирования

Вначале нужно решить, будем ли мы использовать сортировку с помощью индексов или подойдет обычная сортировка (filesort). Каждый раз когда сортировка выполняется без индекса, она называется filesort, хотя она может и не иметь отношения к файлам на диске. Если СУБД MySQL задействует в запросе индекс для поиска по диапазону, то она не может использовать другой индекс (или суффикс того же самого индекса) с целью упорядочивания. Если таких операций много то приходится довольствоваться обычной сортировкой (filesort).

Прием: поместить неселективный столбец в начале индекса. Если запрос не выполняет фильтрации по столбцу sex (пол), мы можем обеспечить использование этого индекса, добавив во фразу WHERE выражение AND sex IN(‘m’, ‘f’). Это позволит MySQL использовать префикс индекса (типа sex age lastname). Однако если список содержит много различных значений, это будет работать плохо. Использование слишком большого количества списков вызывает лавинообразный рост числа комбинаций, которые оптимизатор должен оценить, оптимизация запроса занимала больше времени, чем его выполнение, и требовала большого объема памяти.

MySQL использует как можно больше столбцов индекса вплоть до первого условия, задающего диапазон значений, включительно. Соответственно в конец индекса необходимо помещать столбец, по которому будет условие поиска по диапазону.

В случае необходимости выбора данных по двум диапазонам можно выборку по одному диапазону заменить на выборку по константе из фиктивного столбца. Например, добавим столбец active (активность пользователя(, значения которого будут вычисляться по крону. Когда пользователь заходит на сайт, записываем в столбец значение 1, а если пользователь не появлялся на сайте в течение семи дней, то по крону присваиваем 0. В этом случае жертвуем точностью. Если требуется точность, можно оставить условие last_online во фразе WHERE, но не индексировать этот столбец.

Проблемы являются запросы со страницами, находящимися далеко от начала, типа LIMIT 100000, 10. Способы оптимизации: денормализация, предварительное вычисление и кэширование, использование покрывающего индекса с целью извлекать только столбцы первичного ключа.

### Обслуживание индексов и таблиц

CHECK TABLE выявляет ошибки в таблицах и индексах. REPAIR TABLE исправить поврежденную таблицу. Можно также выгрузить данные в файл и загрузить назад или выполнить «пустую» команду ALTER просто указав ту же систему хранения. 

ALTER TABLE innodb_tbl ENGINE=INNODB;

ANALYZE TABLE обновить статистику по индексам для принятия правильных планов выполнения запроса. 

Изучение индексов, в частности их кардинальности:

 mysql> SHOW INDEX FROM sakila.actor\G 
 ************************** 1. row ************************** 
 Table: actor 
 Key_name: PRIMARY 
 Column_name: actor_id 
 Cardinality: 200

OPTIMIZE TABLE дефрагментация данных и индексов, можно также использовать варианты из REPAIR TABLE.

### Нормализация и денормализация

В нормализованной базе данных каждый факт представлен один и только один раз. В денормализованной базе данных, наоборот, информация дублируется. Любой нетривиальный запрос к хорошо нормализованной схеме потребует join. Это не только дорого, но и делает некоторые стратегии индексирования невозможными. Например, из-за нормализации в разных таб лицах могут оказаться столбцы, которые хорошо было бы иметь в одном индексе.

Достоинством денормализованной схемы является то, что все данные находятся в одной и той же таблице, что позволяет избежать соединений. Худшим случаем при этом будет полное сканирование таблицы. Это значительно быстрее соединения, когда данные не помещаются в память, поскольку удается избежать операций ввода/вывода с произвольным доступом. Становятся возможны эффективные стратегии индексирования.

На практике часто приходится сочетать оба подхода, применяя частично нормализованные схемы. Самым общим способом денормализации данных является дублирование отдельных столбцов из одной таблицы в другую. Для обновления дублей можно использовать триггеры. При этом обновление таблицы становится дороже, поскольку вам придется изменять ее в обеих таблицах. Для решения нужно сравнить частоту UPDATE и SELECT. Также перенос данных из родительской таблицы в дочернюю требует сортировка.

Полезно кэшировать производные значения: сколько сообщений пользователь, статистику. Это позволяет не запускать дорогой подзапрос, а подсчитывать статистику при каждом обновлении данных.

### Кэширующие и сводные таблицы

Это отдельные таблицы, расчитываемые по крону, а потому допускающие устаревание данных. Кэширующая таблица содержит данные, которые можно легко, хотя и не так быстро, извлечь из другой таблицы. Сводная таблица хранит агрегированные данные из запросов с фразой GROUP BY. Их называют roll-up таблицы (таблицы-свертки). Построение таких таблиц называется материализацией.

Пример сводной таблицы: точный счетчик сообщений, размещенных за предыдущие 24 часа. Строится сводная почасовая таблица. Суммируются число сообщений за 23 целых часа периода из сводной таблицы, за часть часа в начале периода и за часть часа в конце периода. Также примеры: наиболее активных пользователей или самые распространенные «теги».

Кэширующие таблицы полезны для оптимизации поисковых запросов и извлечения данных. Такие запросы часто требуют специальной структуры таблиц и индексов, отличной от структуры, которая необходима для оперативной обработки транзакций. Кэширующая таблица может содержать только некоторые столбцы главной таблицы, для нее может  использоваться другая подсистемы хранения MyISAM, с индексами меньшего размера. Можно вынести таблицу в Sphinx.

При использовании таблиц  нужно выбрать поддержку в режиме реального времени или периодически перестраивать. Перестроение не только экономит ресурсы, но и может дать более эффективную таблицу без фрагментации и с полностью отсортированными индексами. 

При перестроении итоговых и кэширующих таб лиц часто требуется, чтобы хранящиеся в них данные на время этой операции оставались доступными. Этого можно добиться, используя «теневую таблицу». Закончив построение которой, вы можете поменять таблицы местами, мгновенно переименовав их.

Таблицы счетчиков. При совместном доступе приложений к единственной строке со счетчиком возникают блокировки. Единственная строка становится глобальным «мьютексом» для любой транзакции, которая обновляет счетчик. Транзакции оказываются сериализованными. Увеличить уровень конкуренции можно, создав несколько строк и обновляя случайно выбранную строку.

mysql> UPDATE hit_counter SET cnt = cnt + 1 WHERE slot = RAND( ) * 100;

или с группировкой по дням

mysql> INSERT INTO daily_hit_counter(day, slot, cnt) 
 -> VALUES(CURRENT_DATE, RAND( ) * 100, 1) 
 -> ON DUPLICATE KEY UPDATE cnt = cnt + 1;

### Ускорение ALTER TABLE

При ALTER TABLE MySQL создает пустую таблицу с новой структурой, вставляет в нее все данные из старой таблицы и удаляет старую таблицу. Для больших таблиц это может занять очень много времени. Во время преобразования на таблицу будет взята монопольная блокировка и таблица окажется заблокированной на чтение.

Общий алгоритм с использованием дополнительной таблицы:

\1. создать временную таблицы одинаковую по структуре с изменяемой

\2. внести изменения во временную таблицу

\3. перенести данные во временную таблицу из основной. Если данных много можно переносить пачками. Желательно включить режим AUTOCOMMIT или вставку каждой пачки завернуть в транзакцию, чтобы журнал отмены не становился слишком большим.

\4. поменять временную таблицу и основную местами

\5. удалить старую таблицу

 

\1. CREATE TABLE relations_new LIKE relations;

\2. ALTER TABLE relations_new CHANGE sent_at sent_at_new int(11) DEFAULT NULL;

\3. INSERT INTO relations_new SELECT * FROM relations;

  или пачками

  INSERT INTO relations_new SELECT * FROM relations WHERE id BETWEEN 1 AND

​     1000000;

\4. ALTER TABLE relations RENAME relations_old;

  ALTER TABLE relations_new RENAME relations;

\5. DROP TABLE relations_old;

Если таблица находится под нагрузкой, то между 3 и 4 пунктом в данные могли быть внесены изменения и они останутся в старой таблице и не будут перенесены в новую. Этот конфликт нужно разрешать вручную. Если большая часть запросов идет на INSERT, то можно просто найти вновь добавленные записи в старой таблице и дополнительно перенести в новую:

SELECT MAX(id) INTO @maxidnew FROM relations_new;

INSERT INTO relations_new SELECT * FROM relations WHERE id > @maxidnew;

 

#### MyISAM

В MyISAM некоторые изменения можно ускорить через изменение frm файла. Например, изменить значение по умолчанию для столбца с помощью команды ALTER COLUMN, которая модифицирует frm-файл, не затрагивая таблицу

Для эффективной загрузки таблиц MyISAM часто отключают ключи, загружают данные и повторно включают ключи: 
 mysql> ALTER TABLE test.load_data DISABLE KEYS; 
 mysql> ALTER TABLE test.load_data ENABLE KEYS; 

MyISAM, в отличии от InnoDB, после загрузки может построить индексы путем сортировки. Это происходит намного быстрее и приводит к дефрагментированному, компактному индексному дереву.

#### InnoDB

Ускорить загрузку можно, удалив индексы, а потом заново их создав.

ALTER TABLE relations_new

  DROP INDEX source_persona_index

## Оптимизация запросов

Главная причина, из-за которой запрос может выполняться медленно – слишком большой объем обрабатываемых данных. Т.к. MySQL выдает результат запроса сразу, а не по мере выбора результата, при необходимости взять часть данных из результата клиентская библиотека получит полный набор данных и большую часть отбросит. Гораздо лучше включить в запрос фразу LIMIT.

Частая проблема - выборка всех столбцов таблицы или соединения нескольких таблиц, наличие SELECT * должно насторожить, неужели действительно нужны все столбцы без исключения, скорее всего, нет. Однако получение всех столбцов упрощает разработку, так как дает возможность использовать один и тот же код в разных местах и полезно для организации кэширования. т.к. кэширование полных объектов предпочтительнее выполнения ряда отдельных запросов.

Методы доступа отображаются в столбце type результата, возвращаемого командой EXPLAIN. Это может быть и полное сканирование таб лицы, и сканирование индекса, и сканирование диапазона, и поиск по уникальному индексу, и возврат константы. Каждый из вышеперечисленных методов быстрее предыдущего, поскольку требует меньшего количества операций чтения. Если тип доступа не оптимален, то для решения проблемы лучше всего добавить подходящий индекс.

MySQL может применять фразу WHERE тремя способами, которые перечислены ниже в порядке от наилучшего к наихудшему:

·     Применить указанные условия к операции поиска по индексу с целью исключить неподходящие строки. Это происходит на уровне подсистемы хранения. 

·     Использовать покрывающий индекс (слова «Using index» в столбце Extra), чтобы избежать доступа к самим строкам и отфильтровать неподходящие строки после выборки результатов из индекса. Это происходит на уровне сервера, но не требует чтения строк из таб лицы. 

·     Выбрать строки из таблицы, а затем отфильтровать неподходящие (слова «Using where» в столбце Extra). Это происходит на уровне сервера, причем фильтрации предшествует чтение строк из таблицы.

### Способы реструктуризации запросов

Традиционно при проектировании базы данных стараются сделать как можно больше работы с помощью наименьшего числа запросов. Исторически связано с высокой стоимостью сетевых коммуникаций и накладных расходов на разбор и оптимизацию. Однако MySQL изначально проектировалась так, чтобы установление и разрыв соединения происходили максимально эффективно, а обработка небольших простых запросов выполнялась очень быстро. Современные сети гораздо быстрее, чем раньше, поэтому и сетевые задержки заметно сократились. MySQL способна выполнять свыше 50 000 простых запросов в секунду на типичном серверном оборудовании и свыше 2000 запросов в секунду от одиночного клиента в гигабитной сети, поэтому выполнение нескольких запросов может оказаться вполне приемлемой альтернативой.

Передача информации с использованием соединения все же происходит значительно медленнее по сравнению с тем, какой объем находящихся в памяти данных сам MySQL может перебрать в секунду, – это число измеряется миллионами строк. Так что с учетом всех факторов по-прежнему лучше бы ограничиться минимальным количеством запросов, но иногда можно повысить скорость выполнения сложного запроса, разложив его на несколько более простых.

**Разбиение запроса на части.** Тактика «разделяй и властвуй» запрос обрабатывающий большое количество строк разбивается на несколько мелких запросов. Например,  удаление старых данных. Если делать это одним большим запросом, то возможны блокировки большого числа строк на длительное время, переполнение журналов транзакций, истощение ресурсов, блокировка небольших запросов, которые не допускают прерывания. Разбив команду DELETE на части, каждая из которых удаляет умеренное число строк, мы заметно повысим производительность и уменьшим отставание реплики в случае репликации запроса (транзакционные подсис темы хранения могут работать эффективнее при меньшем размере транзакции). Кроме того, имеет смысл вставить небольшую паузу между последовательными командами DELETE, чтобы распределить нагрузку по времени и не удерживать блокировки слишком долго.

**Декомпозиция соединения**  (join  decomposition). Смысл в том, что выполнить несколько однотабличных запросов вместо одного многотабличного, а соединение выполнить уже в приложении. Такая реструктуризация может дать ощутимый выигрыш в производительности. Выигрыш:

Можно более эффективно реализовать кэширование, т.к. как правильно проще кешировать отдельные сущности из БД, например отдельные теги или посты. И если в кеше уже есть записи из таблицы постов, то соответствующие значения можно исключить из списка IN(). Кэш запросов от такой стратегии также выигрывает. Если часто изменяется только одна таб лица, то декомпозиция соединения может уменьшить количество перезагрузок записей в кэш (cache invalidations).

Для подсистемы MyISAM запросы, обращающиеся только к одной таблице, позволяют более эффективно использовать блокировки, поскольку таблицы блокируются по отдельности и на краткий промежуток времени, а не коллективно и надолго. 

Соединение результатов на уровне приложения упрощает масштабирование базы данных путем размещения разных таблиц на различных серверах.

Может быть построен более эффективный план выполнения запроса, т.к. использование списка IN() вместо соединения позволяет MySQL более эффективно сортировать идентификаторы и более оптимально извлекать строки, чем это было бы возможно в процессе соединения.

Можно избавиться от лишних обращений к строкам, если в соединении несколько раз встречается одна и та же таблица.

Эту технику можно считать ручной реализацией хеш-соединений вместо стандартного применяемого в MySQL алгоритма вложенных циклов. Иногда хеш-соединение оказывается более эффективным

### Основные принципы выполнения запросов

Порядок обработки запроса:

\1.   Клиент отправляет SQL-команду серверу. 

\2.   Сервер проверяет кеш и если там есть запрос сразу возвращает результат. При этом производится поиск в хеш-таблице с учетом регистра ключа. Если поступивший запрос отличается от хранящегося в кэше хотя бы в одном байте, запросы считаются разными, и сервер переходит к следующей стадии обработки запроса.

\3.   Сервер осуществляет разбор, предварительную обработку (preprocesing) и оптимизацию SQL-команды, преобразуя ее в план выполнения запроса.

\4.   Подсистема выполнения запросов выполняет этот план, обращаясь к подсистеме хранения. 

\5.   Сервер отправляет результат клиенту.

  

Клиент-серверный протокол MySQL полудуплексный, отсутствует механизм управления потоком данных: после того как одна сторона отправила сообщение, другая должна получить его целиком и только потом сможет ответить.

Клиент отправляет запрос в виде одного пакета данных. Поэтому важна конфигурационная переменная max_allowed_packet в случаях, когда встречаются длинные запросы. Ответ сервера состоит из нескольких пакетов данных. Клиент обязан получить весь результирующий набор, отправленный сервером (пьет из пожарного шланга).

Клиентские библиотеки по умолчанию целиком буферизуют результат в памяти. Это важно, т.к. пока все строки не будут получены, сервер MySQL не освобождает блокировки и другие ресурсы. Потребляемый клиентской библиотекой объем памяти можно сократить, если задать режим работы без буферизации. Но это означает. что сервер удерживает блокировки, пока приложение взаимодействует с библиотекой (в php реализуется mysql_unbuffered_query( ).

У каждого соединения (т.е. потока) имеется состояние, показывающее, что происходит в текущий момент времени. Проверить можно командой SHOW FULL PROCESSLIST (столбец Command):

Sleep Поток ожидает поступления нового запроса от клиента. 
 Query Поток либо занят выполнением запроса, либо отправляет клиенту результаты. 
 Locked Поток ожидает предоставления табличной блокировки на уровне сервера. Блокировки, реализованные подсис темой хранения, напри- мер блокировки строк в InnoDB, не вызывают перехода в состояние Locked.

Analyzing и Statistics Поток проверяет статистику, собранную подсистемой хранения, и оптимизирует запрос.

Copying to tmp table [on disk Поток обрабатывает запрос и копирует результаты во временную таблицу. 

Sorting result Поток занят сортировкой результирующего набора
 Sending data пересылает данные между различными стадиями обработки запроса, генерирует результирующий набор или возвращает результаты клиенту.

### Оптимизация запроса

Планирование запроса состоит в преобразовании SQL-команды в план выполнения. Состоит из следующих этапов: 

·   разбор – строится дерево разбора с проверкой грамматику языка SQL, например, лексемы допустимы, следуют в нужном порядке и нет непарных кавычек

·   предварительная обработка (preprocessing) –проверяет, что указанные таблицы и столбцы существуют, а ссылки на столбцы не допускают неоднозначного толкования.

·   оптимизация. 

На этапе оптимизации оптимизатор пытается выбрать лучший план выполнения из множества планов. Используется стоимостный оптимизатор. В качестве единицы стоимости принимаются затраты на считывание случайной страницы данных размером 4 Кбайт. Сделанную оптимизатором (теоретическую!) оценку стоимости запроса можно узнать из сеансовой переменной last_query_cost:

mysql> SHOW STATUS LIKE ‘last_query_cost’; 
 +-----------------+-------------+ 
 | Variable_name  | Value    | 
 +-----------------+-------------+ 
 | Last_query_cost | 1040.599000 | 
 +-----------------+-------------+

Значит что для выполнения запроса потребуется выполнить примерно 1040 случайных чтений страниц данных. Оценка вычисляется на основе статистической информации: количество страниц в таблице или в индексе, кардинальность (количество различных значений) индекса, длина строк и ключей, распределение ключей. Оптимизатор не учитывает то, что некоторые строки могут находится в памяти, он предполагает что их все придется читать с диска.

Причины выбора не наилучшего плана: 

·     Некорректная статистика. InnoDB не ведет точную статистику количества строк в таблице;

·     Принятая метрика стоимости не всегда эквивалентна истинной стоимости выполнения запроса, План, предполагающий чтение большего количества страниц, может быть дешевле, потому что чтение с диска производится последовательно.

·     MySQL не берет в расчет другие одновременно выполняющиеся запросы, а они могут повлиять на время обработки оптимизируемого.

·     Иногда возможности оптимизатора по выбору плана апроса ограничены, так если запрос содержит фразу MATCH(), то используется полнотекстовый индекс, несмотря на лучшие другие индексы.

·     Нельзя учесть стоимость некоторых операций, например выполнение хранимых или определенных пользователем функций.

Существует два вида оптимизации: статическая и динамическая. Для выполнения статической оптимизации достаточно исследования дерева разбора. Например, оптимизатор может преобразовать фразу WHERE в эквивалентную форму, применяя алгебраические правила. Динамические оптимизации зависят от контекста, например, конкретных значений в условии WHERE или количеством строк в индексе, вычисляются при каждом выполнении запроса.

Оптимизации, поддерживаемые MySQL:

·   Изменение порядка соединения

·   Преобразование OUTER JOIN в INNER JOIN, это возможно при определенных условиях, зависящих от фразы WHERE и схемы таблицы

·   Применение алгебраических правил эквивалентности. Например, (5=5 AND a>5) приводится к более простому: a>5.

·   Оптимизации COUNT(), MIN() и MAX(). Чтобы найти минимальное значение в столбце, который является самой левой частью ключа индекса типа B-Tree, MySQL может просто запросить первую строку из этого индекса. Если применена такая оптимизация, то в плане, выведенном командой EXPLAIN, будет присутствовать фраза «Select tables optimized away» (некоторые таб лицы исключены при оптимизации). Это означает, что оптимизатор полностью исключил таблицу из плана выполнения, подставив вместо нее константу. COUNT(*) без фразы WHERE можно оптимизировать в MyISAM. 

·   Если MySQL обнаруживает, что выражение можно свернуть в константу, то делает это на стадии оптимизации. Например, определенную пользователем переменную можно преобразовать в константу, если она не изменяется в запросе. 

mysql> EXPLAIN SELECT film.film_id, film_actor.actor_id 
 -> FROM sakila.film 
 -> INNER JOIN sakila.film_actor USING(film_id) 
 -> WHERE film.film_id = 1;

вследствие распространения «константности» значения из одного места в другое значение film_id будет одинаково на протяжении всего запроса – оно должно быть равно константе, заданной во фразе WHERE.

·   Покрывающий индекс содержит все необходимые запросу столбцы, данные таблицы не читаются.

·   MySQL может прекратить обработку запроса, как только поймет, что этот запрос или шаг полностью выполнен, например, при LIMIT.

mysql> SELECT film.film_id 
 -> FROM sakila.film 
 -> LEFT OUTER JOIN sakila.film_actor USING(film_id) 
 -> WHERE film_actor.film_id IS NULL;

Обнаружив первого актера, сервер прекращает обработку текущего фильма и переходит к следующему, поскольку знает, что условию WHERE такой фильм заведомо не удовлетворяет.

·   Распространение равенства

mysql> SELECT film.film_id 
 -> FROM sakila.film 
 -> INNER JOIN sakila.film_actor USING(film_id) 
 -> WHERE film.film_id > 500; 
 Условие WHERE применяется не только к таблице film, но и к таблице film_actor, поскольку в силу наличия фразы USING оба столбца должны совпадать.

... WHERE film.film_id > 500 AND film_actor.film_id > 500 
 В MySQL это необязательно и лишь усложняет сопровождение запросов.

·   Перечисленные в списке IN() значения сортируются, выполняется быстрый двоичный поиск. Вычислительная сложность при этом составляет O(log n), где n – размер списка, тогда как сложность эквивалентной последовательности условий OR равна O(n) (т. е. гораздо медленнее для больших списков).

Если оптимизатор, то можно включить в запрос подсказку (hint).

### Соединения в MySQL

Синтаксис:

*table1* [INNER | CROSS] JOIN *table2* [ON *condition*]

*table1* STRAIGHT_JOIN *table2* ON *condition*

*table1* {LEFT|RIGHT} [OUTER] JOIN *table2* ON *condition*

*table1* NATURAL [{LEFT|RIGHT} [OUTER]] JOIN *table2*

**JOIN**, **CROSS JOIN** и **INNER JOIN** полностью эквивалентны.

**STRAIGHT_JOIN** аналог **INNER** **JOIN**, но заставляет сервер выполнять соединение в той последовательности, которая указана в запросе. Имеет смысл, если оптимизатор неоптимально выбирает порядок соединения.

SELECT *

FROM table1 STRAIGHT_JOIN table2

ON table1.id=table2.id;

**NATURAL JOIN** эквивалентен **INNER JOIN** или **LEFT JOIN** с предложением **USING**, перечисляющем названия всех столбцов, которые существуют в обеих таблицах (даже если это первичный ключ id).

#### Алгоритм вложенных циклов (nested loops)

В MySQL под «соединением» (join) понимается любой запрос, а не только тот где несколько таблиц. Все соединения реализуются алгоритмом вложенных циклов: в цикле перебирает строки из одной таблицы, а затем во вложенном цикле ищет соответствующие строки в следующей, у которых выполняется условие соединения. На каждой итерации самого глубокого цикла выбранные из таблиц строки конкатенируются, для получения строк итогового результата., составленную из перечисленных в списке SELECT столбцов. Далее MySQL пытается найти следующую строку в последней таблице. Если такой не оказывается, то производится возврат на одну таблицу назад и попытка найти дополнительные строки в ней. Этот план выполнения можно применить к запросам с одной таблицей, поэтому они тоже считаются соединениями.  Если в некотором цикле выполняется поиск по индексу, и всех колонок в индексе достаточно для получения итогового результата, то прямой доступ к таблице в этом цикле не выполняется (покрывабщий индекс).

Данный алгоритм обобщается и на внешние соединения, следующим образом:

if inner_row

   ...

else 

   output [ outer_row.col1, NULL ] 

Таким способом можно выполнить не все допустимые SQL-запросы, поэтому MySQL и не поддерживает оператор FULL OUTER JOIN. При выполнении подзапроса во FROM, он выполняется первым, его результаты сохраняются во временной таб лице, которая затем трактуется как самая обычная таб лица («производная таб лица», derived table), аналогично временная таблица создается для UNION, запросы с RIGHT OUTER JOIN преобразуются в эквивалентную форму с LEFT OUTER JOIN. **Над производными таблицами не строятся индексы.**

Запрос преобразуется в дерево дерево инструкций, получившийся после предобработки запрос можно реконструировать выполнив команду EXPLAIN EXTENDED, а вслед за ней команду SHOW WARNINGS. 

Планы выполнения запросов с соединениями  имеют вид «левоглубоких» деревьев (left-deep tree).

  

Mysql оптимизирует порядок соединения таблиц. 

Mysql выбирает план, в котором меньше строк в первой таблице, что позволяет сделать меньше запросов по индексу для последующей таблицы. Проверить оценку запроса можно через Last_query_cost. Если соединяемых таблиц много, то вариантов их соединения растет как n-факториал, тогда при превышении параметра optimizer_search_depth сервер применяет «жадный» поиск. Пространство поиска позволяют сократить запросы с LEFT JOIN и коррелированные подзапросы, которые всегда выполняются в одном порядке. 

Основной плюс этого метода — полное безразличие к входным данным. Алгоритм работает для любых двух таблиц, не требует никаких индексов и перекладываний данных в памяти, а также прост в реализации. На практике это означает, что достаточно просто бежать по диску двумя курсорами и периодически выплёвывать в сокет совпадения. Самый быстрый, если нужно получить первую строку результата, например, при использовании EXISTS. Минус — без использования индексов сложность O(N*M). При использовании поиска по индексу сложность ниже и алгоритм лучше всех масштабируется, при этом как правило сложность O(n).

#### Соединение хэшированием (hash Join)

В MySQL не реализован. Если размер одной из таблиц позволяет засунуть ее целиком в память, значит, на ее основе можно сделать хеш-таблицу и быстренько искать в ней нужные ключи. Проверим размер обоих списков. Возьмем меньший из списков, прочтем его полностью и загрузим в память, построив HashMap. Теперь вернемся к большему списку и пойдем по нему курсором с начала. Для каждого ключа проверим, нет ли такого же в хеш-таблице. Если есть — запишем совпадение в результирующую таблицу. Временная сложность этого алгоритма падает до линейной O(N+M), но требуется дополнительная память.

#### Merge Join

В MySQL не реализован. Данные в обоих списках должны быть заранее отсортированы, например, по возрастанию. Это возможно, если присутствуют индексы по обоим таблицам, или же если мы отсортировали данные на предыдущих стадиях запроса. Два отсортированных списка можно склеить в один за линейное время. Ставим по курсору в начало обоих списков. Если ключи под курсорами равны, записываем совпадение в результирующую таблицу. Если же нет, смотрим, под каким из курсоров ключ меньше. Двигаем курсор над меньшим ключом на один вперед, догоняя другой курсор.

Если данные отсортированы, то временная сложность алгоритма линейная O(M+N) и не требуется никакой дополнительной памяти. Если же данные не отсортированы, то нужно сначала их отсортировать. Из-за этого временная сложность возрастает до O(M log M + N log N), плюс появляются дополнительные требования к памяти.

### Оптимизации сортировки

Если MySQL не находит индекса для сортировки, то сортирует их сама в памяти или на диске, но сама процедура всегда называется файловой сортировкой (filesort). Если обрабатываемые данные умещаются в буфер, то MySQL может выполнить сортировку целиком в памяти, применяя алгоритм быстрой сортировки (quicksort). В противном случае сортировка выполняется на диске поблочно. Каждый блок обрабатывается методом быстрой сортировки, а затем уже отсортированные блоки сливаются.

Существует два алгоритма файловой сортировки: 

·   Двухпроходный. Читает указатели на строки и столбцы, упомянутые во фразе ORDER BY, сортирует их, затем проходит по отсортированному списку и снова читает исходные строки, чтобы вывести результат,  обходится довольно дорого, поскольку читает строки из таблицы дважды, и второе чтение вызывает много непоследовательных операций ввода/вывода. Однако используется минимальный объем памяти, поэтому если все сортируемые строки уже находятся в ОЗУ, то этот алгоритм выгоден, лучше хранить меньше данных и перечитывать строки для генерации окончательного результата.

·   Однопроходный (новый). Читает один раз все необходимые запросу столбцы, сортирует строки по столбцам, упомянутым во фразе ORDER BY, проходит по отсортированному списку и выводит заданные столбцы. При этом необходимо больше памяти, так как для каждой строки приходится хранить все запрошенные столбцы, а не только те, по которым производится сортировка.

Для каждого сортируемого кортежа выделяется запись фиксированной длины с размером, равным максимальной длине строки. VARCHAR преобразуются в CHAR фиксированной длины, под символ UTF-8 выделяется три байта.

Объем памяти, доступный для filesort, управляется переменной @@sort_buffer_size. Если отсортированные данные не помещаются в память (т. е. имеется более одного фрагмента), filesort использует временный файл для хранения кусков.

Старый режим используется, когда новый не применим в случае когда отсортированные кортежи имеют blobs или столбцы переменной длины. Вывод EXPLAIN не дает никакого представления о том, какой режим используется, поэтому вам придется вручную проверять blob в списке выходных столбцов.

MySQL имеет три способа join с сортировкой:

·   Когда первая таблица в join имеет индекс, соответствующий списку ORDER BY. Порядок будет «распространяться» на другие таблицы на выходе. В EXPLAIN нет упоминания filesort.

·   Все элементы ORDER BY относятся к первой таблице в порядке объединения. filesort первая таблица в старом или новом режиме, а затем переходим к выполнению соединения. В EXPLAIN выводится “Using filesort”.

·   Иначе записать весь вывод join во временную таблицу и затем вызвать filesort. В EXPLAIN “Using temporary; Using filesort”.

### Коррелированные подзапросы

Стоит избегать подзапросы в операторе IN() во фразе WHERE. MySQL должна была бы подставить список значений внутри IN, однако делает наоборот – полное сканирование внешней таблицы и для каждой строки выполняет подзапрос, т.е.

SELECT * FROM sakila.film 
 WHERE EXISTS ( 
 SELECT * FROM sakila.film_actor WHERE actor_id = 1 
 AND film_actor.film_id = film.film_id);

Type  подзапроса в Explain DEPENDENT SUBQUERY. Такой запрос легко переписать с использованием оператора JOIN. Еще одна неплохая оптимизация – вручную сгенерировать список IN(), выполнив вместо подзапроса отдельный запрос с функцией GROUP_CONCAT(). Иногда это оказывается быстрее, чем JOIN.

Иногда коррелированный подзапрос бывает оптимальным: 

mysql> EXPLAIN SELECT film_id, language_id FROM sakila.film 
 WHERE NOT EXISTS(

SELECT * FROM sakila.film_actor 
 WHERE film_actor.film_id = film.film_id )

Обычно рекомендуют его переписать на LEFT OUTER JOIN и IS NULL. Для варианта с LEFT JOIN в столбце Extra стоит «Not exists». Это пример работы алгоритма раннего завершения, т.е. читается не более одной строки из индекса по film_id. Это эквивалентно коррелированному подзапросу NOT EXISTS( ), поскольку обработка 
 текущей строки прекращается, как только ей найдено соответствие. На практике только измерение может показать, какой способ быстрее. По результатам измерения left join немного быстрее.

В следующем случае подзапрос быстрее очевидно из-за примененной оптимизации и отсутствия необходимости создавать временную таблицу с последующим выбором по distincr.

mysql> SELECT DISTINCT film.film_id FROM sakila.film 
 -> INNER JOIN sakila.film_actor USING(film_id);

mysql> SELECT film_id FROM sakila.film 
 -> WHERE EXISTS(SELECT * FROM sakila.film_actor 
 -> WHERE film.film_id = film_actor.film_id);

### Ограничения UNION

MySQL не может «опустить» условия с внешнего уровня UNION на внутренний, где их можно было бы использовать с целью ограничения результата или создания возможностей для дополнительных оптимизаций. Например при объединении две очень большие таблицы и ограничиваете результат первыми 20 строками, MySQL сначала запишет обе таблицы во временную, а затем выберет всего 20 строк. Этого можно избежать, включив ограничение LIMIT 20 в каждую часть UNION.

explain (select id from fishki_pg_data limit 10)

union 

(select id from fishki_category limit 10)

order by id

limit 10;

### Оптимизация слияния индексов

При выполнении запроса можно использовать два индекса: они просматриваются одновременно, после чего результаты сливаются. Существует три варианта этого алгоритма: объединение для условий c OR, пересечение для условий c AND и объединение пересечений для случая, когда встречаются как OR, так и AND.

mysql> EXPLAIN SELECT film_id, actor_id FROM sakila.film_actor 
 -> WHERE actor_id = 1 OR film_id = 1\G

Extra: Using union(PRIMARY,idx_fk_film_id); Using where

MySQL умеет применять эту технику к сложным фразам WHERE, поэтому для некоторых запросов в столбце Extra можно встретить вложенные операции. В результате параллельных просмотров может возвращаться много строк, подлежащих слиянию, что повлияет на одновременно выполняющиеся запросы. При этом запуск изолированно запроса не покажет влияния и большого размера выделенной памяти. Это свидетельствует о необходимо тестировать на реальной системе. 

**MySQL не умеет распараллеливать выполнение одного запроса на нескольких ЦП**. Эту возможность предлагают многие СУБД, но только не MySQL.

### Непоследовательный просмотр индекса

MySQL не умеет выполнять непоследовательный просмотр индекса (loose index scan), то есть просмотр несмежных диапазонов индекса. При просмотре индекса всегда необходимо задавать начальную и конечную точку. Если бы такое было возможно, то это позволило бы оптимизировать случаи, когда используется не левый префикс ключа:

INDEX(a,b)

WHERE b BETWEEN 2 AND 3;

  

Непоследовательный просмотр индекса возможен в некоторых ситуациях, например для отыскания минимального и максимального значений в запросе с группировкой:

INDEX (post_id, gallery_id)

explain SELECT post_id, max(gallery_id) FROM fishki_pg_data group by post_id;

Extra: Using index for group-by

Наличие слов «Using index for group-by» свидетельствует о непоследовательном просмотре индекса. 

Для непоследовательного просмотра индекса можно также применять обходное решение с указанием список констант для столбца, указанного первым в ключе индекса.

### Функции MIN() и MAX()

Запросы, которые выбирают min или max значение из проиндексированного поля и имеют условие по неиндексированному полю можно оптимизировать так. Вместо:

mysql> SELECT MIN(actor_id) FROM sakila.actor WHERE first_name = ‘PENELOPE’; 
 что приводит к полному просмотру таблицы можно написать:

mysql> SELECT actor_id FROM sakila.actor USE INDEX(PRIMARY) 
 -> WHERE first_name = ‘PENELOPE’ LIMIT 1;

что прекратит поиск после нахождения первой подходящей строки.

### SELECT и UPDATE одной таблицы

MySQL не позволяет производить SELECT из таблицы одновременно с UPDATE.

mysql> UPDATE tbl AS outer_tbl 
 -> SET cnt = ( 
 -> SELECT count(*) FROM tbl AS inner_tbl 
 -> WHERE inner_tbl.type = outer_tbl.type ); 
 ERROR 1093 (HY000): You can’t specify target table 
 ‘outer_tbl’ for update in FROM clause

Можно через производную таблицу, так как MySQL материализует ее в виде временной таблицы.

mysql> UPDATE tbl INNER JOIN

-> (SELECT type, count(*) AS cnt 
 -> FROM tbl 
 -> GROUP BY type 
 -> ) AS der USING(type) 
 -> SET tbl.cnt = der.cnt;

### Коррелированный подзапрос

Вложенный запрос , который использует значения из внешнего запроса. Оценивается отдельно для каждой строки, обработанной внешним запросом, поэтому неэффективен.

Найти всех сотрудников, чья зарплата выше среднего для их отдела.

SELECT employee_number, name 

FROM employees AS emp 

WHERE salary > ( SELECT AVG(salary) FROM employees WHERE department = emp.department);

Корреляционные подзапросы могут появляться в другом месте, кроме предложения WHERE; например, в предложении SELECT для печати списка сотрудников и средней зарплаты для отдела каждого сотрудника. 

SELECT employee_number, name, 

(SELECT AVG(salary) FROM employees WHERE department = emp.department) AS department_average 

FROM employees AS emp;

Эффект коррелированных подзапросов в некоторых случаях может быть получен с использованием объединений. Такие запросы не коррелируют с внешним запросом и поэтому - выполняется только один раз, независимо от количества сотрудников. 

SELECT employees.employee_number, [employees.name](https://vk.com/away.php?to=http%3A%2F%2Femployees.name&cc_key=) 

FROM employees INNER JOIN 

  (SELECT department, AVG(salary) AS department_average 

  FROM employees 

  GROUP BY department) AS temp 

ON employees.department = temp.department 

WHERE employees.salary > temp.department_average;

Если внутренний запрос используется в нескольких запросах, внутренний запрос может быть сохранен как представление, а затем joinиться как обычная таблица.

Самая важная рекомендация, которую можно дать – стараться по возможности использовать вместо них соединение.

### Оптимизация запросов с JOIN

Стройте индексы по столбцам, используемым во фразах ON или USING. При добавлении индексов учитывайте порядок соединения – следует индексировать только вторую таблицу в порядке соединения,

Старайтесь, чтобы в выражениях GROUP BY и ORDER BY встречались столбцы только из одной таблицы, тогда у MySQL появится возможность воспользоваться для этой операции индексом.

### Оптимизация GROUP BY и DISTINCT

MySQL зачастую внутренне переключается между ними на стадии оптимизации. Если подходящего индекса не существует, то возможно две стратегии: воспользоваться временной таблицей или прибегнуть к файловой сортировке. Чтобы заставить оптимизатор выбрать нужный вам метод, включите в запрос подсказки SQL_BIG_RESULT или SQL_SMALL_RESULT.

Если нужна группировка по значению столбца, который извлекается при соединении из справочной таб лицы, то обычно более продуктивно группировать по идентификатору из этой таблицы, а не по его значению. Вместо

mysql> SELECT actor.first_name, actor.last_name, COUNT(*) 
 -> FROM sakila.film_actor 
 -> INNER JOIN sakila.actor USING(actor_id) 
 -> GROUP BY actor.first_name, actor.last_name;

сделать так

mysql> SELECT actor.first_name, actor.last_name, COUNT(*) 
 -> FROM sakila.film_actor 
 -> INNER JOIN sakila.actor USING(actor_id) 
 -> GROUP BY film_actor.actor_id;

Авторы не рекомендуют использовать такие хаки и желательно  ставить SQL_MODE в режим ONLY_FULL_GROUP_BY, чтобы сервер выдавал сообщение об ошибке, а не разрешал писать плохие запросы. Чтобы обойти эту сложность, можно воспользоваться функциями MIN() или MAX(). 

Возможно сделать также через подзапрос

mysql> SELECT actor.first_name, actor.last_name, c.cnt 
 -> FROM sakila.actor 
 -> INNER JOIN ( 
 -> SELECT actor_id, COUNT(*) AS cnt 
 -> FROM sakila.film_actor 
 -> GROUP BY actor_id 
 -> ) AS c USING(actor_id) ;

Однако стоимость создания и заполнения временной таблицы может быть слишком высока по сравнению с мелким отступлением от принципов реляционной теории. Также временная таблица, создаваемая в процессе выполнения подзапроса, не имеет индексов.

MySQL автоматически упорядочивает результат запроса с группировкой по столбцам, перечисленным во фразе GROUP BY, если фраза ORDER BY явно не указана. Если порядок не имеет значения, то можно подавить файловую сортировку (filesort) включив фразу ORDER BY NULL. При группировке можно поместить сразу после GROUP BY DESC или ASC.

### GROUP BY WITH ROLLUP

Модификатор with rollup используется для создания отчетов, содержащих подытоги и окончательное итоговое значение. Например, нужно получить суммарное и среднее число проживающих людей на всех географических территориях (регионах), а также на континентах и во всём мире. Вместо выполнения нескольких запросов и последующего сложного объединения результатов, можно выполнить всего один:

SELECT Continent, Region, SUM(Population) AS pop, AVG(Population) AS avg_pop FROM Country GROUP BY Continent, Region WITH ROLLUP;

+-----------+----------+------------+----------------+
 | Continent | Region            | pop      | avg_pop |
 +---------------+---------------------------+------------+--------------
 | Asia | Southern and Central Asia | 1490776000 | 106484000.0000 |
 | Asia | NULL | 3705025700 | 72647562.7451 |
 | Europe | Western Europe | 183247600 | 20360844.4444 |
 | Europe | NULL | 730074600 | 15871186.9565 |
 | NULL | NULL | 6078749450 | 25434098.1172 |

В некоторых строках в не агрегирующих колонках стоит NULL, что указывает на то, что данная строка является подытогом. Строка с двумя NULL является окончательным итогом по отношению к численности населения на всём земном шаре.

Оптимизация WITH ROLLUP может оставлять желать лучшего. Иногда оказывается эффективнее выполнить суперагрегирование в самом приложении,

### Оптимизация LIMIT со смещением

Типичная проблема – слишком большое смещение. Если в запросе встречается фраза LIMIT 10000, 20, то сервер сгенерирует 10 020 строк и отбросит первые 10 000, а это очень дорого. В предположении, что доступ ко всем страницам производится с одинаковой частотой, такой запрос в среднем просматривает половину таблицы. Для оптимизации можно либо наложить ограничения на то, сколько страниц разрешено просматривать. Также можно выполнять смещение, пользуясь покрывающим индексом, а не исходной таб лицей. Затем полученные результаты можно соединить с полными строками, чтобы дополнительно выбрать интересующие вас столбцы.

mysql> SELECT film.film_id, film.description 
 -> FROM sakila.film 
 -> INNER JOIN ( 
 -> SELECT film_id FROM sakila.film 
 -> ORDER BY title LIMIT 50, 5 
 -> ) AS lim USING(film_id); 
 Выигрыш достигается за счет того, что серверу приходится просматривать только индекс, не обращаясь к самим строкам.

Можно попробовать преобразовать запрос с LIMIT в позиционный запрос, который сервер сможет выполнить путем просмотра диапазона индекса. Например, если предварительно вычислить столбец position и построить по нему индекс,

mysql> SELECT film_id, description FROM sakila.film 
 -> WHERE position BETWEEN 50 AND 54 ORDER BY position;

При ранжировании данных нужно заранее вычислять и сохранять ранги. Также возможны: предварительное вычисление итогов;  соединение со вспомогательными таблицами, которые содержат только первичный ключ и столбцы, необходимые для 
 выполнения ORDER BY; воспользоваться поисковой системой Sphinx.

### Оптимизация SQL_CALC_FOUND_ROWS

Позволяет узнать, сколько строк сервер вернул бы, если бы не было LIMIT. Сервер не умеет подсчитывать строки, которые не отбирал. поэтому он должен сгенерировать и отбросить оставшуюся часть результирующего набора, а не останавливаться, выбрав затребованное количество строк. Это очень дорого. 
 Варианты избежать подсчета строк: 

·   включить в страницы ссылку «следующая», например если на странице выводится 20 результатов, мы отбираем с помощью фразы LIMIT 21 строку, а выводим только 20. Если 21-я строка существует, значит, имеется следующая страница, и мы формируем ссылку «следующая».

·   выбрать и закэшировать намного больше строк, чем необходимо, скажем 1000, и генерировать последующие страницы из кэша. Если строк больше 1000, то можно вывести сообщение «найдено более 1000 результатов. 

В любом случае, выполнение отдельного запроса COUNT(*) для нахождения количества строк с покрывающим индексом намного быстрее режима SQL_CALC_FOUND_ROWS. 

### Оптимизация UNION 

MySQL всегда выполняет запросы с UNION путем создания и заполнения временной таблицы. Помочь оптимизатору можно «опустив вниз» фразы WHERE, LIMIT, ORDER BY и другие условия (то есть скопировав их из внешнего запроса в каждый SELECT, ходящий в объединение).

Очень важно всегда употреблять UNION ALL, если только вы не хотите, чтобы сервер устранял строки-дубликаты. Когда ключевое слово ALL отсутствует, MySQL будет создавать временную таб лицу в режиме distinct, а это значит, что для соблюдения уникальности производится сравнение строк целиком. Такая операция обойдется очень недешево. При этом наличие слова ALL не отменяет необходимости во временной таблице. MySQL в обязательном порядке помещает в нее результаты, а затем читает их оттуда,

### Подсказки оптимизатору запросов

**HIGH_PRIORITY** **и** **LOW_PRIORITY**. Говорят, какой приоритет назначить данной команде относительно других команд, пытающихся обратиться к тем же таблицам. Влияют на дисциплину обслуживания очереди команд, ожидающих доступа к таблице.

DELAYED. Применяется к INSERT и REPLACE. Команда возвращает управление немедленно, а подлежащие вставке строки помещаются в буфер и будут реально вставлены все сразу, когда таблица освободится. Полезно для протоколирования и аналогичных приложений, в которых нужно записывать много строк, не заставляя клиента ждать и не выполняя операцию ввода/вывода для каждой команды в отдельности. Функция LAST_INSERT_ID( ) в этом случае неприменима.

**STRAIGHT_JOIN**. Пишется сразу после SELECT, внутри SELECT или в любой другой команде между двумя соединяемыми таблицами. В первом случае она говорит серверу, что указанные в запросе таблицы нужно соединять в порядке перечисления. Во втором случае она задает порядок соединения таблиц, между которыми находится. Полезна, если выбранный MySQL порядок соединения не оптимален или оптимизатор тратит чересчур много времени на выбор порядка. В последнем случае поток слишком много времени проводит в состоянии «Statistics».

**SQL_SMALL_RESULT и** **SQL_BIG_RESULT.** Применимы к SELECT. Они говорят оптимизатору, когда и как использовать временные таблицы или сортировку при выполнении запросов с GROUP BY или DISTINCT. SQL_SMALL_ RESULT означает, что результирующий набор будет невелик, так что его можно поместить в ндексированную временную таблицу, чтобы не сортировать для группировки. Напротив, SQL_BIG_RESULT означает, что результат велик, и лучше использовать временные таблицы на диске с последующей сортировкой.

SQL_BUFFER_RESULT. Результаты нужно поместить во временную таб лицу и как можно скорее освободить табличные блокировки, при этом вместо памяти клиента потребляется память сервера.

**SQL_CACHE и** **SQL_NO_CACHE**. Указывают, что данный запрос является или не является кандидатом на помещение в кэш запросов.

**SQL_CALC_FOUND_ROWS**. Заставляет MySQL вычислить весь результирующий набор, даже если имеется фраза LIMIT, ограничивающая количество возвращаемых строк, не рекомендуется.

**FOR UPDATE и** **LOCK IN SHARE MODE.** Управляет блокировками для команд SELECT, в тех подсистемах хранения, где реализованы блокировки на уровне строк. Полезно, когда заранее известно, что эти строки нужно будет обновить, или чтобы избежать эскалации и сразу получить монопольные блокировки.

**USE INDEX, IGNORE INDEX и** **FORCE INDEX.** Указывают какие индексы использовать или игнорировать при поиске строк в таблице, можно дополнить словами FOR ORDER BY или FOR GROUP BY. FORCE INDEX – то же самое, что USE INDEX, однако сообщает оптимизатору о том, что сканирование таблицы обойдется гораздо дороже поиска по индексу, даже если индекс не очень полезен. Полезно если оптимизатор выбрал неподходящий индекс или для неявного упорядочения по индексу без использования ORDER BY.

Нужно внимательно переходить на новую версию MySQL, поскольку включенные в запрос подсказки могут помешать оптимизатору применить новую, более эффективную стратегию. Нужно иметь комплекс тестов, описывающих нагрузку в ваших конкретных условиях эксплуатации, прогонять эти тесты на сервере разработки для каждой новой версии СУБД и лишь потом устанавливать новую версию на промышленные сервера.

Системные переменные:

optimizer_search_depth. Глубина исследования частичных планов. Следует уменьшить, если запрос слишком долго пребывает в состоянии «Statistics».

optimizer_prune_level. Позволяет оптимизатору пропускать некоторые планы в зависимости от количества исследованных строк.

### Переменные, определяемые пользователем

Позволяют к реляционной логике добавить процедурную. В чистой реляционной теории все таблицы рассматриваются как неупорядоченные множества, которыми сервер как-то манипулирует целиком. MySQL позволяет прагматично обработать таблицу, как набор строк. 

Существование переменной ограничено временем жизни соединения с сервером. Определяются присвоением с помощью команд SET или SELECT: 
 mysql> SET [@one](https://vk.com/one) := 1; 
 mysql> SET @min_actor := (SELECT MIN(actor_id) FROM sakila.actor); 
 mysql> SET [@last_week](https://vk.com/last_week) := CURRENT_DATE-INTERVAL 1 WEEK; 
 Переменные можно использовать в различных местах выражения: 

mysql> SELECT ... WHERE col <= [@last_week](https://vk.com/last_week);

·   Подавляют кэширование запроса.

·   Связаны с конкретным соединением,

·   При использовании пула соединений или устойчивых (persistent) соединений они могут привести к интерференции между, казалось бы, изолированными участками кода.

·   типизация пользовательских переменных динамическая.

·   лучше всегда употреблять при присвоении :=.

·   Порядок и даже момент присваивания переменной значения не всегда детерминирован и может зависеть от выбранного оптимизатором плана выполнения. 

Можно одновременно присвоить переменной значение и воспользоваться им.

mysql> SET @rownum := 0; 
 mysql> SELECT actor_id, @rownum := @rownum + 1 AS rownum FROM sakila.actor LIMIT 3;

Задача ранжирования: найти 10 актеров, сыгравших в наибольшем количестве фильмов, причем значение в столбце rank должно быть одинаково у актеров, сыгравших в одном и том же количестве фильмов.

Не сработает:

mysql> SET @curr_cnt := 0, @prev_cnt := 0, @rank := 0; 
 mysql> SELECT actor_id, 
 -> @curr_cnt := COUNT(*) AS cnt, 
 -> @rank := IF(@prev_cnt <> @curr_cnt, @rank + 1, @rank) AS rank, 
 -> @prev_cnt := @curr_cnt AS dummy 
 -> FROM sakila.film_actor 
 -> GROUP BY actor_id 
 -> ORDER BY cnt DESC 
 -> LIMIT 10; 

rank и dummy равны во всех строках 0. Причины неудач возможны: ошибка в имени переменной или присвоение переменной на другом этапе выполнения запроса. Ранжирование средствами SQL O(n2), тогда как решение с использованием пользовательских переменных O(n),

Проблему можно решить, добавив в запрос еще один уровень временных таблиц за счет подзапроса во фразе FROM: 

mysql> SET @curr_cnt := 0, @prev_cnt := 0, @rank := 0;

-> SELECT actor_id, 
 -> @curr_cnt := cnt AS cnt, 
 -> @rank := IF(@prev_cnt <> @curr_cnt, @rank + 1, @rank) AS rank, 
 -> @prev_cnt := @curr_cnt AS dummy 
 -> FROM ( 
 -> SELECT actor_id, COUNT(*) AS cnt 
 -> FROM sakila.film_actor 
 -> GROUP BY actor_id 
 -> ORDER BY cnt DESC 
 -> LIMIT 10 
 -> ) as der;

Проблемы возникают если присваивание и чтение значений происходят на разных стадиях обработки запроса. Например это запрос возвращает не одну строку: 
 mysql> SET @rownum := 0; 
 mysql> SELECT actor_id, @rownum := @rownum + 1 AS cnt 
 -> FROM sakila.actor 
 -> WHERE @rownum <= 1; 
 Т.к. фразы WHERE и SELECT обрабатываются на разных стадиях процесса выполнения запроса. Решение состоит в том, чтобы присваивать значения и читать их на одной и той же стадии выполнения запроса: 
 mysql> SET @rownum := 0; 
 mysql> SELECT actor_id, @rownum AS rownum 
 -> FROM sakila.actor 
 -> WHERE (@rownum := @rownum + 1) <= 1;

Понять почему получился такой ответ можно изучив план выполнения запроса в EXPLAIN. Если нужно поместить присваивание в часть ORDER BY, чтобы не искажать результат запроса можно использовать выражение  LEAST(0, @rownum := @rownum + 1), возвращает минимум, всегда 0. Также возможны подобные функции. Иногда оптимизатор считает переменные константами этапа компиляции и отказывается выполнять присваивания, обычно помогает помещение присваиваний внутрь функции типа LEAST().

**Пример:** найти первых N записей в каждой группе. Например, найти 5 последних по времени комментариев к каждому посту:

SELECT id

FROM (

SELECT

​      id,

​     @num := if(@prev_post_id = post_id, @num + 1, 1) AS row_number,

​      @prev_post_id := post_id AS dummy_p

   FROM fishki_comment,

​      (SELECT @num := 0, @prev_post_id := -1) as t

   ORDER BY post_id, dt DESC

) AS x

WHERE x.row_number <= 5

## Дополнительные средства MySQL

### Хранение кода внутри MySQL

Можно хранить код на стороне сервера в форме триггеров, хранимых процедур, хранимых функций, событий (периодически выполняемых заданиях). Хранимые процедуры и функции могут получать параметры и возвращать результаты, триггеры и события – не могут, запускаются в разных контекстах. Плюсы хранения кода внутри СУБД:.

·   Код исполняется там, где находятся данные, поэтому можно сэкономить на сетевом трафике и уменьшить время задержки.

·   Сервер кэширует планы выполнения хранимых процедур, что снижает накладные расходы на повторные вызовы. 

·   Поскольку код содержится на сервере, его можно развертывать, включать в резервную копию и сопровождать средствами сервера.

·   Хранимые процедуры может писать специалист по базам данных, поскольку не всякий прикладной программист умеет создавать эффективные SQL-запросы.

Минусы:

·   Язык медленный и примитивный по сравнению с прикладными языками.

·   Наличие хранимого кода усложняет деплой.

·   Хранимые подпрограммы увеличивают нагрузку на сервер баз данных, а его обычно труднее масштабировать, чем веб-серверы.

**Хранимые процедуры.** Применяют хранимый код в зависимости от решения, где должна находиться бизнес-логика: в коде приложения или в базе данных. Распространены оба подхода.

Рекомендации: сложную логику лучше оставить в приложении и реализовывать ее с помощью более выразительного и гибкого процедурного языка, т.к. вычисления проще масштабировать, можно реализовать кэширование. Для мелких запросов накладные расходы на разбор и передачу по сети занимают заметную долю всего времени обработки, поэтому хранимый код будет быстрее.

**Триггеры** дают возможность выполнить код, когда встречаются команды INSERT, UPDATE или DELETE. Вы можете заставить MySQL обрабатывать триггеры до и/или после выполнения самой команды. Пример применения: эмуляция внешних ключей для подсистем хранения, которые сами по себе их не поддерживают, например MyISAM; автоматическое обновление денормализованных и сводных таблиц; протоколирования обновлений.

Триггеры позволяют упростить логику приложения и повысить производительность, поскольку избавляют от необходимости обмениваться данными по сети.  Может затруднить понимание того, что в действительности делает сервер, поскольку простая, на первый взгляд, команда нередко инициирует большой объем «невидимой» работы.

Серьезное ограничение по производительности – наличие в MySQL только триггеров FOR EACH ROW. Иногда из-за этого триггер работает настолько медленно, что оказывается непригоден для поддержания сводных и кэширующих таблиц. Основной причиной для использования триггеров вместо периодического массового обновления состоит в том, что данные в любой момент времени согласованы. Триггеры над таблицами типа InnoDB выполняются в контексте текущей транзакции, действия фиксируются или откатываются вместе с вызвавшей их командой. 

**События.** Похожи на задания cron, но выполняются целиком внутри сервера MySQL. Обрабатывают SQL-код в требуемый момент времени или с заданным интервалом. Обычно поступают так: оформляют сложный SQL-код в виде хранимой процедуры, а событие просто вызывает ее с помощью команды CALL. События выполняются специальным потоком планировщика событий, поскольку никак не связаны с соединениями. Применение: для периодического запуска задач обслуживания, в том числе перестроения кэша и сводных таблиц, для сохранения переменных состояния с целью мониторинга и диагностики.

Курсоры. Позволяет построчно обойти результат запроса, извлекая строки в переменные для последующей обработки. Хранимая процедура позволяет открывать сразу несколько курсоров, причем они могут быть «вложены» друг в друга. Поддерживается только чтение, потому что обходят временные таблицы, а не таблицы, в которых хранятся реальные данные. Курсор формирует временную таблицу в момент открытия. Временные таблицы, размер которых превышает значение параметра tmp_table_size создаются на диске.

### Подготовленные команды

В момент создания подготовленной команды клиентская библиотека посылает серверу прототип будущего запроса. Сервер разбирает и обрабатывает эту «заготовку» запроса, сохраняет структуру, представляющую частично оптимизированный запрос, и возвращает клиенту дескриптор команды (statement handle). В подготовленных командах могут присутствовать параметры, обозначаемые вопросительными знаками, вместо которых в момент выполнения подставляются фактические значения.

Чтобы впоследствии выполнить этот запрос, серверу необходимо отправить дескриптор команды и значения всех параметров, представленных вопросительными знаками. Для отправки параметров используется расширенный **двоичный** (а не текстовый) клиент-серверный протокол. Двоичный протокол применим только к подготовленным командам. **Преимущества**: 

·   Серверу нужно разобрать запрос только один раз,

·   Сервер должен проделать некоторые шаги оптимизации однократно, так как частичный план выполнения запроса уже закэширован;

·   Отправка параметров в двоичном виде эффективнее передачи в виде ASCII-текста. Например, для отправки значения типа DATE нужно всего 3 байта вместо 10 при передаче в ASCII-виде. Но наибольшая экономия достигается для значений типа BLOB и TEXT, которые можно отправлять серверу блоками, а не одним гигантским куском. Данные не преобразуются из естественного формата хранения в кодировку ASCII.

·   Для каждого выполнения запроса нужно посылать только параметры, а не весь текст запроса.

·   Повышают безопасность, т.к. нет необходимости экранировать специальные символы на уровне приложения.

Существует SQL-интерфейс к подготовленным командам для использования в хранимых процедурах:

mysql> SET @sql := ‘SELECT actor_id, first_name, last_name 
 -> FROM sakila.actor WHERE first_name = ?’; 
 mysql> PREPARE stmt_fetch_actor FROM @sql; 
 mysql> SET @actor_name := ‘Penelope’; 
 mysql> EXECUTE stmt_fetch_actor USING @actor_name;

mysql> DEALLOCATE PREPARE stmt_fetch_actor;

Они находят применение в хранимых процедурах для построения «динамических SQL-команд» путем конкатенации строк (для подстановки имен таблиц, баз данных, чисел в LIMIT).

**Недостатки**:

Локальны по отношению к соединению, поэтому в другом соединении тот же самый дескриптор использовать нельзя.

Если подготовленная команда выполняется всего один раз, вы можете потратить на подготовку больше времени, чем ушло бы на выполнение обычной SQL-команды. Кроме того, для подготовки команды необходимо дополнительное обращение к серверу.

Если вы забудете освободить дескриптор подготовленной команды, то возникнет «утечка». Это может приводить к потерям большого количества ресурсов сервера. Также существует глобальное ограничение на количество подготовленных команд, и в конечном счете другие соединения не смогут подготовить команду.

### Представления

В MySQL представление – это таблица, в которой не хранятся данные. Информация, «находящаяся» в таблице, берется из результатов обработки SQL-запроса. Если имеется представление:

mysql> CREATE VIEW Oceania AS 
 -> SELECT * FROM Country WHERE Continent = ‘Oceania’ 
 -> WITH CHECK OPTION;

то запрос к этому представлению

mysql> SELECT Code, Name FROM Oceania WHERE Name = ‘Australia’;

может быть переписан двумя способами
 mysql> CREATE TEMPORARY TABLE TMP_Oceania_123 AS 
 -> SELECT * FROM Country WHERE Continent = ‘Oceania’; 
 mysql> SELECT Code, Name FROM TMP_Oceania_123 WHERE Name = ‘Australia’; 
 При таком подходе существуют проблем с производительностью и оптимизацией. Другой вариант – переписать запрос, объединив SQL-код самого запроса с SQL-кодом представления.

mysql> SELECT Code, Name FROM Country 
 -> WHERE Continent = ‘Oceania’ AND Name = ‘Australia’;

MySQL может применять оба метода. Для этой цели имеются два алгоритма: MERGE и TEMPTABLE, причем по возможности MySQL старается использовать алгоритм MERGE (объединение). Это возможно, если сохраняется взаимно однозначное соответствие между строками в базовых таблицах и строками в представлении.

Посмотреть, что получилось в результате переписывания запроса, позволяет команда EXPLAIN EXTENDED, сопровождаемая командой SHOW WARNINGS. Если при реализации представления был использован алгоритм TEMPTABLE, то EXPLAIN показывает производную (DERIVED) таблицу. Представления, к которым может быть применен метод MERGE являются обновляемыми, т.е. к ним можно применять команды UPDATE, DELETE и даже INSERT, как к обычной таблице. Фраза CHECK OPTION в конце представления гарантирует, что все строки, измененные через представление, будут соответствовать условию WHERE в определении представления и после изменения.

**Примеры применения**:

Если рефакторинг схемы происходит поэтапно, то иногда с помощью представлений можно сохранить работоспособность кода, который обращается к таблице с изменившейся структурой.

Можно уменьшить количество однотипных таблиц в системе, разместив данные в одной таблице и сделав вывеску для нее в виде представлений. Например, в базе данных для обслуживания блогов: 

CREATE VIEW blog_posts_for_user_1234 AS 
 SELECT * FROM blog_posts WHERE user_id = 1234 
 WITH CHECK OPTION;

### Кодировки и схемы упорядочения

Кодировкой (character set) называется отображение множества двоичных кодов на некоторое множество символов. Схема упорядочения (collation) – это набор правил сортировки для конкретной кодировки.

В MySQL сервер, каждая база данных и каждая таблица имеют свою кодировку и схему упорядочения по умолчанию. Они образуют иерархию умолчаний, на основе которой выбирается кодировка вновь создаваемого столбца. Значения хранятся только в столбцах таблицы, поэтому на более высоких уровнях иерархии определены всего лишь умолчания. Кодировка по умолчанию для таблицы никак не отражается на том, как хранятся значения в этой таблице; это лишь способ сообщить MySQL, какую кодировку следует использовать при создании нового столбца, если она не указана явно.

На каждом уровне иерархии кодировку можно либо определить явно, либо позволить серверу использовать подходящие умолчания. 

·   При создании базы данных кодировка наследуется от определенного на уровне сервера параметра character_set_server. 

·   При создании таблицы кодировка наследуется от базы данных. 

·   При создании столбца кодировка наследуется от таблицы. 

Клиент и сервер могут посылать друг другу данные в разных кодировках. Сервер выполняет преобразование по мере необходимости. Кодировка сервера устанавливается командами SET NAMES и SET CHARACTER. Клиентское приложение также нужно правильно настроить, чтобы не возникало проблемы несоответствия кодировок. Кодировка задается через параметр charset строки DSN подключения.

При сравнении двух значений в разных кодировках MySQL должен сначала привести их к общей кодировке, можно сделать это вручную через CONVERT(), также преобразование выполняется сервером неявно. 

При выборе схемы упорядочения обычно исходят из того, как сортировать буквы: с учетом регистра, без учета регистра или в соответствии с двоичным кодом. Соответственно, имена схем упорядочения, как правило, заканчиваются на _cs, _ci или _bin. Если кодировка или схема упорядочивания опущены MySQL подставит недостающее по умолчанию. Например:

CREATE TABLE d.t( 
 col1 CHAR(1),

col2 CHAR(1) CHARSET utf8, 
 col3 CHAR(1) COLLATE latin1_bin 
 ) DEFAULT CHARSET=cp1251;

mysql> SHOW FULL COLUMNS FROM d.t; 
 | col1 | char(1) | cp1251_general_ci | 
 | col2 | char(1) | utf8_general_ci | 
 | col3 | char(1) | latin1_bin | 

Желательно задавать требуемые в соответствии с бизнес-процессами умолчания на уровне сервера и, быть может, на уровне базы данных. А затем в исключительных случаях задавать кодировку на уровне столбца. При неразумном выборе кодировки может возрасти потребление ресурсов процессора, памяти и места на диске. Преобразование из одной кодировки или схемы упорядочения влечет за собой лишние издержки. При соединении двух таблиц по столбцам, имеющим разные кодировки, MySQL вынуждена перекодировать один из них, при этом возможно не удастся воспользоваться индексом, поскольку перекодировку можно уподобить функции, обертывающей столбец.

Функция LENGTH() возвращает количество байт, CHAR_LENGTH() – символов, для многобайтовых кодировок это разные значения. При использовании UTF8 уменьшаются в три раза ограничения на длину ключа:

mysql> CREATE TABLE big_string(str VARCHAR(500), KEY(str)) DEFAULT 
 CHARSET=utf8; 
 mysql> SHOW WARNINGS;

| Warning | 1071 | key was too long; max key length is 999 bytes | 
 MySQL автоматически укорачивает ключ индекса:

mysql> SHOW CREATE TABLE big_string\G 
 KEY `str` (`str`(333)) 

Многим приложениям кодировка UTF-8 совсем ни к чему. Преобразование столбца из национальной кодировки в UTF-8 можно ощутимо увеличить объем потребляемого места на диске. Например, значение перестанет помещаться на одной странице и придется задействовать внешнюю память.

Иногда вообще не нужно использовать кодировку. Кодировки полезны для сравнения с учетом регистра, сортировки, распознавания границ между символами (SUBSTRING). Если не требуется, чтобы сервер баз данных мог обрабатывать символьные значения, то можно хранить все, включая данные в кодировке UTF-8, в столбцах типа BINARY. Можно добавить специальный столбец, в котором будет содержаться информация о том, в какой кодировке представлена информация.

#### Конфигурирование кодировки сервера

Приложение может настраивать свое соединение с сервером при каждом подключении с помощью команды:

SET NAMES 'utf8'

Также параметры кодировки можно указать при запуске сервера:

[mysqld]

character-set-server=utf8     # Кодировка сервера по умолчанию

collation-server=utf8_general_ci # Схема упорядочения сервера по умолчанию

### Полнотекстовый поиск

#### Понятия полнотекстового поиска

**Полнотекстовый поиск** (full text searching) — поиск ключевых слов в содержимом поля документов, хранящихся в базе данных. Результатом поиска, является набор документов, отранжированных по реливантности. 

Для организации эффективного полнотекстового поиска необходимо построить полнотекстовый индекс. Для формирования индекса и разбора на части поискового запроса в тексте необходимо выделить термы. Терм – это минимальная единица текста, по которой осуществляется индексирование и которая хранится в словаре индекса. Чаще всего термом является слово, приведенное к нормальной форме (навыками → навык). 

Процесс подготовки текста к индексированию включает:

·   выделение термов

·   удаление из текста стоп-слов. Стоп-слова – это часто встречающиеся в тексте слова (например, союзы), знаки препинания и т.д.

##### Инвертированный индекс

Прямой индекс (forward index) – структура данных, в которой для каждого документа хранится список термов, встречающихся в документе:

| Документ  | Слова                    |
| --------- | ------------------------ |
| Документ1 | Корова,  говорит, мычать |

Для поиска всегда применяется инвертированный индекс. Инвертированный индекс (inverted index) — структура данных, в которой для каждого терма из общего словаря (term dictionary) сопоставлен список документов (posting list), в которых этот терм присутствует. 

| Слово  | Документы                        |
| ------ | -------------------------------- |
| Корова | Документ1,  Документ2, Документ3 |

Для хранения term dictionary могут использоваться следующие структуры:

·   хэш-таблица, где терм — ключ, а значение — ссылка на список документов этого терма.

·   упорядоченный список, по которому можно искать бинарным поиском.

·   префиксное дерево (trie).  

Чаще всего используется префиксное дерево. Особенности префиксного дерева:

·   Корню дерева соответствует пустая строка.

·   Каждому ребру префиксного дерева соответствует символ. 

·   Получить ключ узла можно выписыванием подряд символов, помечающих рёбра на пути от корня до узла. 

Преимущества префиксного дерева:

·   отличный расход памяти: хорошо поддается сжатию и повторяющиеся части префиксов будут храниться всего один раз. 

·   получаем возможность делать префиксные запросы. 

##### Булевский поиск

Булевский поиск – полнотекстовый поиск с возможностью использовать операторы булевой алгебры в поисковом запросе (AND, OR и NOT).

Самый простой тип запроса – по одному терму. Для такого запроса достаточно в инвертированном индексе найти список документов, соответствующий терму.

Для более сложных запросов чаще всего используется оператор AND – логическое И. Например, запрос, в котором указаны несколько слов через пробел java android, преобразуется в запрос java AND android. 

Принципы реализации:

·   AND – в индексе по термам java и android находятся списки документов, а затем по ним делается пересечение — то есть мы находим документы, в которых есть оба терма. 

·   OR – по спискам документов делает объединение

·   префиксный поиск вида jav* –отлично работает, когда словарь реализован на префиксном дереве, и тогда мы просто доходим до вложенности префикса и берем все термы, которые лежат ниже.

##### Ранжирование

После получения списка документов их необходимо отранжировать. Релева́нтность — семантическое соответствие найденных документов, заданному поисковому запросу.

Самые элементарные принципы ранжирования – основанные на сортировке по какому-либо свойству документа. Например, ранжирование по дате или по количеству найденных слов в документе. Такие подходы применяются редко. 

Наиболее часто документы ранжируются по величине TF-IDF, которая для конкретного документа определяется по формуле:

  

TF (term frequency, частота терма) — насколько часто терм встречается в документе:

  

IDF (inverse document frequency, обратная частота документа) — инверсия частоты, с которой терм встречается в документах коллекции:

  

Большой вес в TF-IDF получат слова с высокой частотой в пределах конкретного документа и с низкой частотой употреблений в других документах.

Пертине́нтность — соответствие найденных информационно-поисковой системой документов информационным потребностям пользователя

#### Реализация в MySQL

Полнотекстовый индекс MyISAM представляет собой специальный вид B-дерева с двумя уровнями. На первом уровне находятся ключевые слова. А на втором уровне для каждого ключевого слова располагается список ассоциированных с ним указателей на документы, в которых встречается данное ключевое слово. При индексировании отбрасываются: стоп слова, то есть «шум» (можно задать параметром ft_stopword_file), слова короче ft_min_word_len символов и длиннее ft_max_word_len символов.

В полнотекстовом индексе не хранится информация о том, в каком столбце набора находится ключевое слово и фразе MATCH AGAINST нельзя сказать, что слова, встречающиеся в одном столбце, важнее слов, встречающихся во всех остальных. Хотя иногда желательно, чтобы документы, в которых ключевое слово встречается в заголовке, оказывались в списке результатов раньше.

При полнотекстовом поиске на естественном языке исключаются вхождения, которые встречаются более чем в 50% строк таблицы, даже если их нет в списке стоп-слов. Если полнотекстовый индекс строится по небольшой таблице, то высока вероятность, что индекс не будет ничего искать, т.к. слова встречаются более чем в половине строк таблицы. 

Для полнотекстового поиска используется предикат MATCH AGAINST. Выдача полнотекстового поиска автоматически сортируется по релевантности. При другой сортировке используется filesort. **Если запрос полнотекстовый, то другие индексы не рассматриваются**. Функция MATCH() возвращает релевантность в виде числа с плавающей точкой. Этим можно воспользоваться для фильтрации результатов по релевантности или для показа релевантности в пользовательском интерфейсе. Функцию MATCH() можно употреблять более одного раза (в SELECT и WHERE), операция выполняется только один раз.

-> WHERE MATCH(title, description) AGAINST(‘factory casualties’);

Столбцы во фразе MATCH() следует перечислять точно в том порядке, в котором они были заданы при построении полнотекстового индекса, иначе MySQL не сможет воспользоваться индексом.

Стандартным способом нельзя дать приоритет при поиске одному из столбцов в полнотекстовом индексе. Можно через обходной путь, например, сделать столбец title более приоритетным. Для этого  добавить индекс по этому столбцу: 

mysql> ALTER TABLE film_text ADD FULLTEXT KEY(title) ; 

Теперь для целей ранжирования удвоить приоритет title:

-> ORDER BY (2 * MATCH(title) AGAINST(‘factory casualties’)) 
 -> + MATCH(title, description) AGAINST(‘factory casualties’) DESC;

В булевском режиме можно использовать префиксы, скобки для группировки, заключать в кавычки строки для точного поиска фразы.

dinosaur Строки, содержащие слово «dinosaur», имеют больший ранг

~dinosaur Строки, содержащие слово «dinosaur», имеют меньший ранг

+dinosaur Строка *должна содержать* слово «dinosaur» 

-dinosaur В строке *должно отуствовать* слово «dinosaur»

dino* Строки, содержащие слова, которые начинаются с «dino», имеют больший ранг

Булевский поиск выполняется медленно, т.к. индекс не содержит информации соответствиях условиям. Сервер выбирает строки по индексу, а затем их анализирует, при точном сопоставлении фразы в кавычках LIKE может оказаться быстрее в случае большой выборки, так как строки читаются последовательно, а не в квазислучайном порядке индекса, а обращаться к полнотекстовому индексу вовсе не требуется.

Для булевского поиска полнотекстовый индекс не нужен. Если такой индекс есть, он просматривается, в противном случае сканируется вся таблица. Можно даже применить булевский полнотекстовый поиск соединению столбцов из нескольких таблиц, в отличие от индекса по одной таблице. Особенности: изменение строк в полнотекстовом индексе обходится очень дорого: модификация фрагмента текста, содержащего 100 слов, требует не одной, а 100 операций с индексом; Скорость работы с другими типами индексов мало зависит от длины поля; индекс не хранит текст, поэтому не может быть покрывающим. 

WHERE MATCH(content) AGAINST (‘High Performance MySQL’) AND author = 123; 

Неэффективный запрос, т.к. предпочтение полнотекстовому индексу и только затем будет произведена фильтрация по автору без индекса. Чтобы использовать в индексе author_id нужно включить идентификатор автора в полнотекстовый индекс. Можно выбрать какой-нибудь префикс, появление которого в тексте маловероятно, дописать к нему сзади идентификатор автора и включить это «слово» в столбец filters, который обновляется независимо (возможно, с помощью триггера). Затем можно расширить полнотекстовый индекс, включив в него столбец filters, и переписать запрос так: 
 ... WHERE MATCH(content, filters) 
 AGAINST (‘High Performance MySQL +author_id_123’ IN BOOLEAN MODE);

Примеры применения: 

·   вычисление статей, *«похожих» на данную статью по тегам:* полнотекстовый запрос по полю с тегами с сортировкой по релевантности, 

·   найти пользователей, интересы которых совпадают с интересами другого пользователя. 

·   Локализовать поиск некоторой прямоугольной областью. Например, если в строке хранятся координаты X=123 и Y=456, можно построить чередующуюся строку цифр, XY142536. Если потребуется ограничить поиск, например, прямоугольником, для которого X изменяется от 100 до 199, а Y – от 400 до 499, то в запрос можно включить условие «+XY14*».

Задание списка стоп-слов и минимальной длины слова ускоряет поиск, но снижает качество поиска, требуется подбор баланса.

### Ограничения внешнего ключа

Поддерживаются только InnoDB. Обходятся не даром. Их наличие означает, что сервер должен заглядывать в другую таблицу при каждом изменении данных, однако заранее InnoDB строит индекс. Дополнительный индекс увеличивает размер таблицы, в особенности, если велика длина первичного ключа; при этом он пригодится, только проверки внешнего ключа.

Если необходимо строго гарантировать целостность данных, то конечно лучше это поручить MySQL, а не приложению. Внешние ключи полезны также для каскадного удаления и обновления, хотя эти операции выполняются построчно, то есть медленнее, чем пакетный запрос. Из-за внешних ключей запрос может «распространяться» на другие таблицы, а это означает захват блокировок.

Для контроля на уровне MySQL эффективней написать триггер, включив в него явный список допустимых значений (а можно просто воспользоваться типом данных ENUM). 

Зачастую имеет смысл проверять ограничения в приложении, а не использовать для этой цели внешние ключи.

### Объединенные таблицы и секционирование

Объединенные таблицы (merge tables) – это способ объединить несколько таблиц типа MyISAM в одну «виртуальную таблицу», контейнер для таблиц с одинаковыми определениями.

Секционированные  таблицы (partitioned  tables) выглядят как обычные таблицы со специальным набором указаний, сообщающих MySQL, где нужно физически хранить строки, хотя на нижнем уровне каждая секция представляет собой отдельную таблицу со своими индексами, при этом обратиться к таблицам-секциям напрямую невозможно, тогда как объединенные таблицы это позволяют.

Объединенные таблицы

mysql> CREATE TABLE t1(a INT NOT NULL PRIMARY KEY) ENGINE=MyISAM; 
 mysql> CREATE TABLE t2(a INT NOT NULL PRIMARY KEY) ENGINE=MyISAM; 
 mysql> INSERT INTO t1(a) VALUES(1),(2); 
 mysql> INSERT INTO t2(a) VALUES(1),(2); 
 mysql> CREATE TABLE mrg(a INT NOT NULL PRIMARY KEY) 
 -> ENGINE=MERGE UNION=(t1, t2) INSERT_METHOD=LAST; 
 mysql> SELECT a FROM mrg; 
 +------+ 
 | a | 
 +------+ 
 | 1 | 
 | 1 | 
 | 2 | 
 | 2 |

Все объединяемые таблицы должны иметь одинаковое количество и типы столбцов, одинаковые индексы должны быть построены над общей таблицей и ее частями. Объединенная таблица не проверяет ограничений по входящим в нее таблицам, например первичного ключа. Управлять тем, в какое место объединенной таблицы вставляются новые строки, можно только с помощью параметра INSERT_METHOD, который принимает значения LAST *(вставлять в последнюю таблицу) или FIRST (вставлять в первую таблиц). Можно также вставлять данные в составляющие таблицы напрямую.

При удалении объединенной таб лицы все ее составляющие остаются на месте, однако уничтожение любой из составляющих приводит к ошибкам в работе. Если определения объединяемых таблиц слегка различаются, то MySQL может создать объединенную таб лицу, которой впоследствии не сумеет воспользоваться. Если изменить определение одной из составляющих таблиц уже после создания объединенной таблицы, объединенная таблица перестанет работать. Запросы, обращенные к объединенной таблице, переадресуются к каждой из составляющих таблиц, а затем результат обьединяется. Пример применения: Журналы. Можно создаь по одной таблице на каждый день. В начале каждого дня создается новая составляющая таблица, после чего определение объединенной таблицы изменяется, чтобы присоединить ее. Можно также таблицу за предыдущий день преобразовать в формат MyISAM со сжатием.

Пример применения: Обслуживание больших таблиц, которые представляются как объединение таблиц меньшего размера; гораздо быстрее проверить и исправить набор небольших таб лиц, чем одну гигантскую, особенно если последняя не помещается в память. Для удаления старых данных достаточно исключить из объединенной таблицы составляющие и затем сделать DROP TABLE.

Объединенная таблица может генерироваться на лету, получается вроде UNION ALL; однако накладные расходы при этом ниже, так как сервер не копирует результаты во временную таблицу перед отправкой клиенту. Например, может применяться для объединения вчерашних данных с данными за последнюю неделю, две недели и так далее. Одна MyISAM-таблица может входить в несколько объединенных таблиц. Секции не позволяют создавать временные таблицы.•

Удобно для разделения логов по нескольким таблицам в соответствии с датой.

Секционированные таблицы

Строка таблицы может храниться только в одной секции. В определении таблицы указывается способ распределения строк по секциям, основанный на функции секционирования. Секционированная таблица проверяет ограничения: первичные и уникальные ключи. Если функция секционирования при обращении указывает на одну секцию, то к остальным секциям сервер не обращается. Удобно удалять старые данные путем удаления целой секции. Секционированные данные можно распределить по физически разным устройствам. К секциям нельзя обращаться независимо от секционированной таблицы, и каждая секция принадлежит одной и только одной таблице.

Функция секционирования должна возвращать целое число. Существует несколько видов функций секционирования. При секционировании по диапазону для каждой секции задается диапазон значений, и строки распределяются по секциям в зависимости от того, в какой диапазон они попадают. MySQL поддерживает также секционирование по ключам, хеш секционирование и секционирование по списку.

Пример: огромная таблица с данными о продажах товара по датам. Ускорить обработку запросов можно:

\1. Добавить первичный ключ по столбцам (day, itemno) и использовать InnoDB. Тогда данные за один день физически будут располагаться рядом.

\2. Использовать MyISAM и вставлять строки в нужном порядке, чтобы при просмотре индекса данные читались последовательно, а не произвольно.

\3. Организовать по одной секции на каждый день. В этом случае секционирование является грубым аналогом индекса.

Можно применить сочетание 1 и 3 подхода, делаем дату заказа частью первичного ключа и применяем подсистему хранения InnoDB для кластеризации значений по датам.

CREATE TABLE sales_by_day (

day DATE NOT NULL,

product INT NOT NULL,

PRIMARY KEY(day, product)

) ENGINE=InnoDB;

Далее разбиваем таблицу на секции и в качестве функции секционирования берем YEAR(). Хорошая функция для секционирования по диапазону должна линейно зависеть от значения, определяющего секцию.

mysql> ALTER TABLE sales_by_day 
 -> PARTITION BY RANGE(YEAR(day)) ( 
 -> PARTITION p_2006 VALUES LESS THAN (2007), 
 -> PARTITION p_2007 VALUES LESS THAN (2008), 
 -> PARTITION p_2008 VALUES LESS THAN (2009), 
 -> PARTITION p_catchall VALUES LESS THAN MAXVALUE );

Недостаток: чтобы впоследствии добавить новые годы, придется изменить определение таблицы, что в случае большого размера обойдется дорого. Имеет смысл заранее определить больше годов.

Можно распределить секции по разным физическим дискам, например по модулю первичного ключа (если требуется равномерно рапределить нагрузку):

mysql> ALTER TABLE mydb.very_big_table 
 -> PARTITION BY KEY(<primary key columns>) ( 
 -> PARTITION p0 DATA DIRECTORY=’/data/mydb/big_table_p0/’, 
 -> PARTITION p1 DATA DIRECTORY=’/data/mydb/big_table_p1/’);

Того же эффекта можно добиться с помощью RAID-контроллера (что эффективней, т.к. реализовано аппаратно). 

Любой уникальный индекс (в т.ч. первичный ключ) над секционированной таблицей должен содержать все столбцы, на которые ссылается функция секционирования.

Сравнение объединенных и секционированных табиц: объединенные таблицы предоставляют больше возможностей, например индексирование составляющих таб лиц по одной, можно выполнять резервное копирование или восстановление только одной части объединенной таблицы. 

Оптимизатор может использовать функцию секционирования, чтобы отсечь некоторые секции, если ключ, по которому производится секционирование указан в WHERE. Для контроля используем EXPLAIN PARTITIONS: 

mysql> EXPLAIN PARTITIONS SELECT * FROM sales_by_day\G 
 partitions: p_2006,p_2007,p_2008

mysql> EXPLAIN PARTITIONS SELECT * FROM sales_by_day WHERE day > ‘2007-01-01’\G 
 partitions: p_2007,p_2008

### Временные таблицы

Временная таблица видна только в текущей сессии, и удаляется автоматически, когда сессия закрыта. Т.е. два разных сеанса могут использовать одно и то же имя временной таблицы без конфликта друг с другом. Команда аналогична CREATE TABLE. Имеется возможность указать тип engine:

CREATE TEMPORARY TABLE test.temp_table_myisam (x int) ENGINE=MyISAM;

CREATE TEMPORARY TABLE test.temp_table_memory (x int) ENGINE=MEMORY;

## HandlerSocket

Интерфейс для работы с InnoDB без использования SQL прослойки по принципу NoSQL. Не поддерживает SQL запросы, вместо этого он предоставляет простой язык запросов для CRUD операций с таблицами, поэтому гораздо быстрее mysqld/libmysql.

Вывод OProfile расскажет нам, на что же были потрачены ресурсы:

 samples % app name symbol name 259130 4.5199 mysqld MYSQLparse(void*) 196841 3.4334 mysqld my_pthread_fastmutex_lock

са. Это и есть «SQL-оверхед». Очевидно, что падение происходит собственно на уровне работы с SQL, а не на уровне движка хранилища

HandlerSocket обращается к хранилищу InnoDB, запись будет закеширована только буфере, и будет доступна для использования другими SQL запросами.

Протокол поддерживает базовые операции чтения/записи/обновления/удаления, а также ряд продвинутых (например, инкремент/декремент). Нужно поставить сборку Percona, плагин под mysql, для PHP есть расширение  *php-handlersocket*. Как правило применяется как замена кеширования и требует рамещения данных в памяти, позволяет заменить memcached и хранение копии данных в кеше. Пример выбора по первичному ключу:

$hs = new HandlerSocket('localhost', 9998);

$hs->openIndex(1, 'db', 'users', HandlerSocket::PRIMARY, 'id,name,age');

$data = $hs->executeSingle(1, '=', array('7'), 1, 0);

По тестам прирост производительности в 2,5 раза, при этом данные остаются внутри СУБД. 

## Конфигурирование

### Файл `my.cfg`

Файл `my.cfg` может располагаться в нескольких местах. Если существует несколько файлов `my.cfg`, то каждый из них влияет на конфигурацию. MySQL будет загружать файлы `my.cfg` поочередно, и каждое последующее значение будет переопределять предыдущие (в порядке перечисления файлов)???

Узнать те места, которые MySQL будет просматривать при загрузке конфигурации:

```bash
$ mysqld --verbose --help | grep -A1 'Default options'  
Default options are read from the following files in the given order:
/etc/my.cnf /etc/mysql/my.cnf /usr/local/etc/my.cnf ~/.my.cnf

```

```bash
$ mysql --help | grep /my.cnf | xargs ls
ls: /etc/my.cnf: No such file or directory
ls: /etc/mysql/my.cnf: No such file or directory
ls: ~/.my.cnf: No such file or directory
/usr/local/etc/my.cnf
```

Поэтому в MacOS путь `/usr/local/etc/my.cnf`

Последним загружается файл в домашнем каталоге пользователя `~/.my.cnf`. Директивы этого файла перезаписывают директивы остальных файлов и позволяют настроить MySQL индивидуально под пользователя. Настраивать сервер в этом файле не имеет смысла т. к. запускается он с правами `root`. Как правило, в этом файле размещаются секции `[client]`, `[mysql]`, `[mysqldump]`... с настройками клиентских утилит.

Файл использует формат INI. Для комментирования строки используется точка с запятой `;` или символ решетка `#`.

Содержимое конфигурационного файла разделено на секции, которые имеют вид `[имя_секции]`. Имя секции определяет утилиту или сервер, к которым будут относиться перечисленные далее директивы до тех пор, пока не встретится новая секция или конец файла.

Ниже перечислены наиболее типичные секции.

| Секция                    | Описание                                                    |
| ------------------------- | ----------------------------------------------------------- |
| <u>Настройки сервера</u>  |                                                             |
| `[mysqld]`                | Сервер MySQL                                                |
| `[server]`                | Сервер MySQL                                                |
| `[mysqld-5.7]`            | Сервер MySQL, определенной версии                           |
| `[mysqld_safe]`           | Утилита запуска  mysqld_safe                                |
| <u>Настройки клиентов</u> |                                                             |
| `[client]`                | Любая  клиентская утилита, обращающаяся к серверу           |
| `[mysql]`                 | Консольный  клиент mysql                                    |
| `[mysqldump]`             | Утилита  создания SQL-дампов mysqldump                      |
| `[mysqlhotcopy]`          | Утилита  "горячего" копирования бинарных файлов базы данных |

Секция `[client]` задает настройки для всех клиентов (которые умеют читать эту конфигурацию), а `[mysql]`, `[mysqldump]`... только для определенных клиентов и поэтому имеют более высокий приоритет чем `[client]`. 

Пример секции `[mysqld]` в файле `my.cnf`:

```apache
# Директивы MySQL-сервера 
[mysqld]
# Linux-пользователь, под которьм работают рабочие процессы 
user = mysql

# Файл с идентификатором главного процесса mysqld-сервера
pid-file = /var/run/mysqld/mysqld.pid

# Местоположение сокета, через который осуществляется обмен
# данными с MySQL-клиентами
socket = /var/run/mysqld/mysqld.sock

# Порт, по которому ждет запросов MySQL-сервер
port = 3306

# Папка установки MySQL-сервера
basedir = /usr

# Каталог данных, в котором хранятся файлы баз данных
datadir = /var/lib/mysql

# Временная папка
tmpdir = /tnp

# Каталог с локализацией (переводами) сообщений об ошибках 
lc-messages-dir = /usr/share/mysql

# Отключение системной блокировки файлов, вместо этого используется
# блокировка на уровне MySQL (предотвращает дедлоки) 
skip-external-locking

# Привязка к IP-адресу; при использовании в качестве IP-адреса 0.0.0.0
# MySQL будет доступен для обращений извне.
# Отключить работу MySQL-сервера через сеть можно при помощи директивы
# skip-networking. Удаление bind-address и включение skip-networking
# приведет к тому, что сервер начнет работать только через сокет
bind-address = 127.0.0.1

# Объем оперативной памяти, которая отводится на кэш ключей (только MylSAM)
key_buffer = 16М

# Максимальный размер SQL-запроса
max_allowed_packet = 16М

# Размер стека для каждого потока
thread_stack = 192К

# Сколько потоков кэшируется для повторого использования,
# обычно вычисляется по формуле: 8 + (max_connections / 100) 
thread_cache_size = 8

# Максимальное количество одновременных соединений, при достижении этого
# значения новые соединения будут отбрасываться сервером
max_connections = 150

# Максимальный объем для результирующей таблицы, сохраняемой кэшем запросов
query_cache_limit = 4М

# Объем кэша запросов
query_cache_size = 128М

# Местоположение журнала ошибок 
log_error = /var/log/mysql/error.log

# Кодировка по умолчанию для новых баз данных и таблиц 
character-set-server = utf8

# Тип таблиц по умолчанию 
default-storage-engine = InnoDB

# SQL режим (ниже описан)
sql-mode="NO_ENGINE_SUBSTITUTION"

#############################################
# Директивы для настройки InnoDB
#############################################
# Каждая таблица хранится в отдельном файле, собственном табличном
# пространстве. 
innodb_file_per_table

# Объем оперативной памяти, которая отводится под кэш InnoDB. 
innodb_buffer_pool_size=2G

# Как часто сохранять транзакции на диск
innodb_flush_log_at_trx_commit = 2

# Размер буфера журнала транзакций 
innodb_log_buffer_size=8M
```

Пример секции `[mysql]` в файле `my.cnf`:

```apache
[mysql]
# Хост, к которому будет стучаться клиент
host = localhost

# Порт, по которому будет стучаться клиент
port = 3306

# UNIX-сокет, по которому будет стучаться клиент
socket = /var/run/mysqld/mysqld.sock

# Под каким пользователем будет стучаться
user = root

# С каким паролем
password = root
```

Проверить установленное значение конфигурационного параметра можно если посмотреть [системные переменные](#системные-переменные).

#### Настройки

##### Получить значение

```mysql
SELECT @@GLOBAL.sql_mode;  # Глобальное значение
SELECT @@SESSION.sql_mode; # Сеансовое значение
```

##### Установить значение

Варианты:

- в файле `my.cnf`

##### `sql-mode`

`sql_mode` – настройка, которая влияет на синтаксис SQL, поддерживаемый MySQL, и проверки правильности данных, которые он выполняет.

Возможные значения:

- `STRICT_TRANS_TABLES`– включить *strict SQL mode* (режим строгого SQL) 

### Общие особенности конфигурирования

При задании параметров слишком большое значение по памяти может привести к выходу за пределы физической памяти и включению файла подкачки. Самый лучший подход к делу – изменять не более одной-двух переменных за раз, и после каждой такой модификации прогонять тесты. Лучшим свидетельством того, что в распоряжении ОС достаточно памяти, является отсутствие выгрузки страниц в файл подкачки на диске.

Проще всего взять за основу один из образцов конфигурационного файла, поставляемых вместе с MySQL. Образцы конфигурационных файлов имеют говорящие имена, например: my huge.cnf, my large.cnf, my small.cnf,

Основные параметры конфигурации устанавливают размеры блоков памяти. Наиболее важные кэши: кэши операционной системы для данных MyISAM, кэши ключей MyISAM, пул буферов InnoDB, кэш запросов. 

Если вы работаете исключительно с таблицами MyISAM, томожно отключить InnoDB, если с таблицами InnoDB, то под MyISAM можно отвести минимум ресурсов (MySQL применяет таб лицы типа MyISAM для своих внутренних нужд).

### Кеш потоков

Создание и удаление потоков для обслуживания запросов является дорогой операцией. Вместо постоянного создания и удаления потоков, Mysql может сохранять неактивные потоки в кеш потоков (и использовать в случае необходимости). Пока в кэше есть свободные потоки, MySQL отвечает на запросы об открытии соединения очень быстро. 

Системная переменная thread_cache_size определяет максимальное количество потоков в этом кэше. 

Мониторинг кеша потоков выполняется переменными состояния:

·   Threads_cached – количество потоков в кеше потоков

·   Threads_created – количество созданных потоков с момента старта сервера.

Если значение Threads_created слишком велико, то необходимо увеличить кеш потоков. Для оценки можно использовать:

·    количество потоков, создаваемых в секунду   

·   процент промаха в кеш, когда пришлось создавать новый поток   

### Кеш таблиц

Кеш таблиц позволяет при обращении к таблице не открывать файл заново, а вернуть файловый дескриптор из объекта в кэше. Кэш таблиц разделен на две части: кэш открытых таблиц (размер определяется переменной table_open_cache) и кэш определений таблиц (размер определяется переменной table_definition_cache).

Конфигурирование:

·   Проще всего переменным table_open_cache и table_definition_cache присвоить значение, достаточно большое для кэширования всех таблиц.

·   Смотреть на переменную состояния Opened_tables, если она велика или постоянно растет, то переменную table_open_cache следует увеличить.

 

 

Если требует для выполнения команды увеличить какой-то параметр, то стоит это сделать локально для сессии, т.к. глобальное изменение параметра может привести к растрачиванию памяти впустую. Например, sort_buffer_size (управляет размером буфера для сортировки (filesort)). Этот буфер выделяется целиком даже для очень маленьких сортировок:

SET @@session.sort_buffer_size := <value>; 
 — Выполнить запрос... 
 SET @@session.sort_buffer_size := DEFAULT;

### Мониторинг использования ресурсов

Для мониторинга обощенных результатов использования ресурсов сервера применяют команду SHOW GLOBAL STATUS.

 

 

## Оптимизация операционной системы и оборудования

Отсюда провел рефакторинг текста

Основным узким местом в работе MySQL является аппаратное обеспечение. Чаще всего все упирается в скорость работы процессора и подсистемы ввода/вывода. Что ограничивает производительность сервера, можно понять из анализа результатов работы утилит mpstat, iostat и vmstat.

### Процессор

Перегрузка процессора возникает, когда MySQL работает с данными, целиком помещающимися в оперативной памяти или которые могут считываться с диска с необходимой скоростью. 

Пример: база данных имеет небольшой размер и целиком помещается в памяти. Интенсивно выполняются сложные вычислительные операции: подсчет аггрегатных значений (SUM, COUNT), JOIN таблиц.

При перегрузке процессора, для MySQL лучше заменить процессор на более быстрый, а не добавлять еще один процессор. Архитектура MySQL плохо масштабируется на большое число процессоров, и MySQL не умеет распараллеливать выполнение одного запроса на несколько ЦП. В системе с двумя процессорами, которая занята главным образом выполнением одного запроса с большим объемом вычислений, второй ЦП будет простаивать примерно 90% времени.

Несколько ЦП можно задействовать с пользой в системах оперативной обработки транзакций, например веб-приложениях. Для них характерно большое количество мелких операций, которые можно выполнять на разных процессорах, поскольку они поступают по разным соединениям. Однако все равно существует предел распараллеливания при обработке запросов, т.к. любой разделяемый ресурс – потенциальный источник конкуренции. К таким разделяемым ресурсам относятся:

·   блокировки InnoDB на уровне строки 

·   табличные блокировки MyISAM

·   блокировки за доступ к странице пула буферов InnoDB

·   различные глобальные механизмы синхронизации – семафоры и т.д.

### Подсистема I/O

Перегрузки подсистемы ввода/вывода имеет место, когда рабочее множество данных не помещается в память. 

При таких перегрузках требуется переконфигурировать подсистему I/O. Из всех типов памяти (регистры, кеши, …) для администратора доступно только конфигурирования оперативной памяти. Поэтому решают следующие задачи:

·   подбор типа и объема оперативной памяти

·   подбор типа и объема жесткого диска. 

Произвольный и последовательный I/O

Можно выделить два основных типа доступа к данным в памяти: 

·   последовательный. Используется при полном сканировании данных в порядке их расположения в памяти. Это наиболее частый тип доступа для OLAP систем.

·   произвольный. Используется при чтении данных в порядке индекса. Это наиболее частый тип доступа для OLTP и веб-систем.

Последовательные операции выполняются быстрее произвольных **и в оперативной памяти**, и на диске. Последовательная выборка из памяти в 20 раз быстрее произвольной. Последовательная выборка с диска быстрее произвольной в 5000 (!!!) раз. При этом последовательная выборка из памяти быстрее последовательной выборки с диска всего лишь в 10 раз.

| Последовательная  выборка из памяти | 1     |
| ----------------------------------- | ----- |
| Последовательная  выборка с диска   | 10    |
| Произвольная  выборка из памяти     | 20    |
| Произвольная  выборка с диска       | 50000 |

Таким образом, память имеет существенное преимущество (в 2500 раз) при произвольном доступе. Т.е. если выполняется произвольный доступ к данным (чтение в порядке индекса), а это как раз выполняется чаще всего в веб-системах, то эти данные должны быть обязательно размещены в памяти. Если данные, по которым выполняется доступ в порядке индекса не влезают в память, то нужно обязательно добавить памяти.

#### Различия в кешировании чтения и записи

Чтение может быть значительно ускорено с помощью кеширования данных с диска в памяти. В крайнем случае, если все данные помещаются в памяти, то после «прогрева» сервера любая операция чтения будет выбираться из кэша и обращения к диску не будет. 

Операции записи, даже если и будут выполняться целиком над закешированными данными в памяти, – рано или поздно должны быть зафиксированы на диске. 

Способы уменьшить количество операций записи:

·   Запаковать несколько запросов в транзакцию, как описано здесь Ускорение группы операций через транзакции. Это позволяет отложить процесс сброса на диск до момента фиксации транзакции. Например множественное изменение одного элемента, повлечет всего лишь одину фиксацию на диске.  

·   На уровне приложения собрать все изменения в один запрос или одну транзакцию и выполнить одной физической операцией.

·   Использование журнала транзакций (подробнее Журнал транзакций)

 

 

#### Рабочее множество

У каждого приложения есть «рабочее множество» данных – это те данные, которые ему реально нужны для работы. Для достижения оптимальной производительности не нужно загружать в память всю базу данных – достаточно рабочего множества. Размер рабочего множества существенно зависит от приложения. Для одних программ рабочее множество составляет всего 1% от общего объема данных, а для других приближается к 100%. 

Если рабочее множество не умещается целиком в памяти, то сервер вынужден сбрасывать страницы из кэша надиск, чтобы освободить место в памяти, а через некоторое время снова читать только что записанные на диск данные в память. В итоге в буфере постоянно идёт борьба за место между страницами, которая превращается в вечное чтение с диска. По этой причине зачастую, нехватка памяти проявляется как проблема с вводом/выводом.

Вся архитектура приложения существенно зависет от того, можно ли поместить рабочее множество целиком в оперативную память. Если рабочее множество не помещается в память одного узла, то следует изменить архитектуру приложения, например использовать шардирование. 

Также можно использовать вариант с репликацикй, подробнее Репликация для уменьшения рабочего множества

здесь закончил рефакторинг

InnoDB оперирует страницами размером 16 Кбайт. Если при поиске одиночной строки InnoDB должна обратиться к диску, то в пул буферов будет считана вся содержащая ее страница. При поиске по индку также кешируется и индекс, длина индексной страницы также 16Кбайт. Получается, что для доступа к одной строке, требуется загрузка в кеш 32 Кбайт. Так как данные в InnoDB хранятся по кластерному индексу, нужно его выбирать правильно, чтобы в кеш были загружены близкие по смыслу данные на одной странице. 

При подборе объема памяти нужно  найти приемлемый коэффициент непопадания в кэш. Непопадание имеет место, когда для выполнения запроса нужны данные, отсутствующие в кэше, так что серверуприходится читать их с диска. Можно посмотреть в SHOW INNODB STATUS (Buffer pool rate hit). Также можно взглянуть на показатели использования ЦП. Например, если 90% всего времени ЦП работает, а остальные 10% ожидает завершения ввода-вывода, то коэффициент непопадания можно считать хорошим. При сокращении непопадания в кеш путем добавления памяти нужно стремиться к приемлемому коэффициенту , а не к нулевому, т.к. в какой-то момент это не будет оправдывать затраченных средств. 

Если нужное количество данных поместить в память не удается, то имеет смысл оптимизировать подсистему ввода/вывода. А приложение нужно проектировать с уче- 
 том задержек ввода/вывода. Жесткий диск при работе выполняет шаги: подводит головку к нужной дорожке, ждет пока в результате вращения нужные данные не окажутся под головкой (время доступа, задержка, latency), читает данные под головкой (скорость чтения, пропускная способность, сhannel capacity). Что важнее (первое или второе) зависит от характера выполняемых запросов. Хаки: писать локально данные на большой диск, используя 20–30% емкости, сокращается время подвода головки; брать диски меньшего формата, т.к. меньше времени занимает перемещение головки. 

Пример выбора диска – если требует БД для новостного сайта, где требуется большое количество операций произвольного чтения, возвращающих сравнительно мало данных, то здесь акцент на минимальное время доступа. InnoDB обычно хорошо масштабируется на 10–20 дисков, масштабирование MyISAM при записи ограничивается табличными блокировками и выигрыша от наличия большого количества дисков нет.

Если требуется низкое время доступа, то большое количество дисков не даст эффекта, лучше быстрые диски. Можно в выдаче программы iostat количество ожидающих запросов велико, то можно добавить диски. 

При репликации, если slave может переводиться в master, то у них должны быть одинаковые конфигурации. Если нет, то можно пожертвовать свойтвами ACID, чтобы подчиненному серверу приходилось делать меньше работы.

**Использование** **RAID**. RAID (англ. redundant array of independent disks — избыточный массив независимых дисков) объединение нескольких дисков в логический элемент для избыточности и повышения производительности.

**RAID 0** (striping — «чередование») Информация разбивается на блоки и записывается на оба/несколько дисков поочередно, то есть один блок на первый диск, а второй блок на второй диск. Плюс: скорость считывания файлов увеличивается в n раз, минус:: увеличивается вероятность потери данных в n раз. Рекомендуется лишь для серверов, которые более-менее безразличны, например для подчиненных серверов, которые легко клонировать из другого подчиненного сервера.

**RAID 1** (mirroring — «зеркалирование») — массив из двух (или более) дисков, являющихся полными копиями друг друга. Плюс: обеспечивает такую же скорость записи как без дублирования и выигрыш по скорости чтения при распараллеливании запросов, высокая надёжность. Минус: по цене двух дисков получаем один. 

**RAID** **5**. Данные с чередование пишутся на диски, также с чередованием на все диски пишутся контрольные суммы, т.е. каждая часть данных поддерживается контрольной суммой (XOR) на каком-то из дисков. При отказе одного диска. хранившаяся на нем информация может быть восстановлена по данным на других дисках и контрольным блокам. Самая экономичная из всех конфигураций с избыточностью, на обеспечение избыточности расходуется пространство эквивалентное одному диску. Плюс: чтение быстрое, как и в RAID 0, Минус: произвольная запись дорогая, требует прочитать данные со всех дисков, посчитать контрольную сумму и записать данные и контрольную сумму, в случае отказа диска накладные расходы очень высоки и требуется полное чтение всех дисков. 

**RAID 10 (или 1+0)** — это RAID 0, составленный из нескольких (или хотя бы двух) RAID 1 (зеркалированных пар). Плюс: отлично масштабируется и для чтения, и для записи. Минус: требуется дисков 2*N

**RAID 50** каждый из участников RAID 0 верхнего уровня представляет собой массив RAID 5. При отказе диска проблемы возникают не у всего массива, а у его части. Например,  RAID 50 из двух RAID 5 по 16 дисков с RAID 0 верхнего уровня. Из общей емкости выпадает 2 диска. Получается надежней, чем RAID 5 (но дисков больше для избыточности), и экономичней, чем RAID 10 (но надежность ниже).

**Использование нескольких дисковых томов.** По умолчанию все файлы, принадлежащие одной базе данных (схеме), помещаются в один каталог. Однако существуют конфигурационные параметры, позволяющие поместить индекс над таблицей типа MyISAM в другое место, разложить данные по секционированным таблицам. 

В InnoDB все данные и индексы размещаются в одном наборе файлов, табличном пространстве, можно задать набор файлов так:

innodb_data_file_path = /disk1/ibdata1:1G;/disk2/ibdata2:1G;...

В каталоге базы данных хранятся лишь файлы с определениями таблиц. Поэтому обычно все данные и индексы помещают на один том. Однако в некоторых случаях, для того чтобы справиться с высокой нагрузкой, имеет смысл задействовать несколько томов. Например, если имеется некоторое пакетное задание, которые записывает данные в массивную таблицу, то лучше разместить ее на отдельном томе, чтобы не отнимать у других запросов драгоценную пропускную способность. 

Выбор между организацией RAID и отделением журнала транзакций на отдельный диск: если дисков мало, то имеет смысл сделать из них raid массив, т.к. выделенные под журнал транзакций отдельные диски могут быть незаполнены, а места под данные будет не хватать. Если дисков много, то относительная стоимость выделения части из них под журналы транзакций уменьшается, и такое решение может стать оправданным. 

**Конфигурация сети.** Для сетевого соединения лимитирующими факторами являются задержка и полоса пропускания (пропускная способность). Как правило основную проблему составляет время задержки. т.к. типичное приложение выполняет много коротких операций передачи по сети, поэтому незначительные задержки для каждой транзакции суммируются. Multi Router Traffic Grapher, (MRTG, [http://oss.oetiker.ch/mrtg/](https://vk.com/away.php?to=http%3A%2F%2Foss.oetiker.ch%2Fmrtg%2F&cc_key=) для мониторинга устройств), мониторинг производительности сети: Smokeping ([http://oss.oetiker.ch/smokeping/](https://vk.com/away.php?to=http%3A%2F%2Foss.oetiker.ch%2Fsmokeping%2F&cc_key=)) и Cacti ([http://www.cacti.net](https://vk.com/away.php?to=http%3A%2F%2Fwww.cacti.net&cc_key=)).

**Многопоточность.** MySQL выделяет по одному потоку на каждое соединение. Дополнительно существуют служебные потоки, потоки специального назначения и потоки, создаваемые подсистемами хранения.

**Свопинг** очень плохо отражается на производительности MySQL. Он сводит на нет весь смысл кэширования, и эффективность оказывается ниже, чем в случае, когда для кэшей отведено слишком мало памяти. В сервере MySQL и подсистемах хранения реализованы алгоритмы, которые по разному работают с данными, находящимися в памяти и на диске, поскольку предполагается, что доступ к хранящимся в ОЗУ данным обходится дешево. Поскольку свопинг не виден пользовательским процессам, ни MySQL, ни подсистема хранения не знают, что данные, которые они считают находящимися в памяти, на самом деле выгружены на диск.

Например, полагая, что данные все еще в ОЗУ, подсистема хранения может захватить глобальный мьютекс (например, мьютекс, защищающий пул буферов в InnoDB) на время «короткой» операции с памятью. Но если эта операция выливается в дисковый ввод/вывод, то все остальное замирает в ожидании его завершения. Следовательно, свопинг приводит к гораздо более тяжким последствиям, чем обычный ввод/вывод, выполняемый по мере необходимости.

В ОС GNU/Linux за свопингом можно следить с помощью утилиты vmstat. Интерес представляют столбцы si и so, отражающие динамику свопинга, а не столбец swpd, в котором показан объем использованного пространства в файле подкачки. Величина в столбце swpd может включать информацию о процессах, которые были загружены в память, но сейчас не работают, а, стало быть, и проблем не создают. Желательно, чтобы в столбцах si и so стояли нули.

Многие проблемы, связанные со свопингом, можно решить путем правильного конфигурирования буферов MySQL. Некоторые считают, что файл подкачки вообще следует отключить. В некоторых крайних случаях, когда иначе ядро просто отказывается вести себя «порядочно», это помогает. Однак отключение свопинга означает установку жесткого ограничения на объем виртуальной памяти. Если MySQL испытывает кратковременную потребность в большом количестве памяти или на той же машине время от времени запускаются процессы, потребляющие много ресурсов (скажем, ночные пакетные задания), то память у MySQL может кончиться, что приведет к аварийному завершению. Указание системе выполняется путем установки следующего значения в 0 или 1:

$ cat /proc/sys/vm/swappiness 
 60 
 $ echo 0 > /proc/sys/vm/swappiness

## Репликация

Позволяет сконфигурировать один или несколько серверов (реплик, слейвов) в качестве подчиненных другому серверу (мастер). У одного слейва может быть один мастер.

Накладные расходы репликации на главном сервере невелики. Правда, на нем требуется включить двоичный журнал, однако это нужно сделать для съема резервных копий. Небольшую нагрузку (в основном, на сеть) дает добавление каждого подчиненного сервера.

Репликация применима только для масштабирования операций чтения, которые можно адресовать подчиненному серверу, но для масштабирования записи она не подходит, т.к. запись выполняется только на мастере. Система ограничена количеством операций записи, которые может выполнить самое слабое ее звено.

Применение:

·   Выпоняется асинхронно, поэтому можно хранить копию данных в географически удаленном пункте, например, в другом центре обработки данных с непостоянным соединением.

·   Реплику можно разместить поближе к бекенду, например, разместить ее локально с бекендом, что уберет сетевые задержки.

·   Распределение запросов на чтение между несколькими серверами MySQL. Балансирование может выполняться либо на уровне приложения, либоDNS- round-robin.

·   Для резервного копирования. Сама реплика не является резервной копией, однако с нее можно снять резервную копию. 

·   Высокая доступность и аварийное переключение на резервный сервер (failover). Сервер перестает быть точкой отказа.

·   Тестирование новых версий MySQL. На подчиненный сервер устанавливают новую версию.

Принцип работы:

·   Главный сервер записывает изменения данных перед фиксацией транзакции в двоичный журнал. MySQL сериализует транзакции (записывает последовательно), даже если во время выполнения перемежаются команды из разных транзакций.

·   Подчиненный сервер копирует события двоичного журнала в свой журнал ретрансляции (relay log). Реализуется потоком, держащим соединение с мастером. Обнаружив конец журнала, процесс выгрузки дампа засыпает и ждет, пока главный сервер не просигнализирует о появлении новых событий.

·   Подчиненный сервер воспроизводит события из журнала ретрансляции, применяя изменения к собственным данным. Реализуется отдельным потоком SQL.

·   События, исполняемые потоком SQL, могут также записываться в собственный двоичный журнал подчиненного сервера

Возможно включение режима GTID. Глобальный идентификатор транзакции (GTID) - это уникальный идентификатор, связанный с каждой транзакцией на master. Этот идентификатор уникален для всех серверов в заданной настройке репликации. GTID гарантирует, что одна транзакция не будет выполнена дважды.

GTID = source_id:transaction_id

Такая архитектура позволяет развязать процессы выборки и воспроизведения событий на подчиненном сервере и сделать их асинхронными. Не гарантируется, что копия данных на подчиненном сервере актуальна, возможно отставание. Обновления, производившиеся на главном сервере, возможно, параллельно (в разных потоках), на подчиненном сервере распараллелены быть не могут (сериализуются).

### Настройка репликации

Создание учетных записей на серверах. 

Настройка master.

log_bin = /path/mysql-bin //путь к логу

server_id = 10 //номер сервера

Проверка master

mysql> SHOW MASTER STATUS; 
 +------------------+----------+--------------+------------------+ 
 | File       | Position | Binlog_Do_DB | Binlog_Ignore_DB | 
 +------------------+----------+--------------+------------------+ 
 | mysql-bin.000001 |    98 |        |          | 
 +------------------+----------+--------------+------------------+

Настройка slave

log_bin = mysql-bin

server_id = 2 //обязательный

relay_log = mysql-relay-bin //место журнала ретрансляции

log_slave_updates = 1 //писать реплицированные события в свой двоичный журнал

read_only = 1 //отключить модификацию данных

Сообщить подчиненному серверу о том, как соединиться с главным

mysql> CHANGE MASTER TO MASTER_HOST=’server1’, 
 -> MASTER_USER=’repl’, 
 -> MASTER_PASSWORD=’p4ssword’, 
 -> MASTER_LOG_FILE=’mysql-bin.000001’, 
 -> MASTER_LOG_POS=0;

Проверка slave

mysql> SHOW SLAVE STATUS\G 
 Master_Host: server1 
 Read_Master_Log_Pos: 4 
 Seconds_Behind_Master: NULL

...

Запуск репликации:

mysql> START SLAVE;

Потоки репликации видны на главном и подчиненном серверах через show processlist.

Способы клонирования подчиненного сервера:: копирование данных с главного, клонирование другого подчиненного сервера и загрузка данных из резервной копии.

### Виды репликации

**Покомандная** - протоколируются все выполненные главным сервером команды изменения данных. Slave отрабатывает в точности ту же команду, которая была ранее выполнена на главном сервере. Плюс: легкость реализации, понятность, маленький размер записей в двоичный журнал. Можно анализировать лог через mysqlbinlog.  Минус: моменты выполнения и порядок команд на master и slave отличается, команды сериализуются. 

binlog_format = 'STATEMENT'

**Построчная** в двоичный журнал записываются фактические изменения данных. Плюс: гораздо надежней и эффективней. Минус: увеличение размера двоичного журнала, особенно для запросов, затрагивающих много строк. 

binlog_format = 'ROW';

**Смешанный** переключение с одного на другой по мере необходимости. По умолчанию применяется покомандная репликация, но если обнаруживается событие, которое невозможно корректно реплицировать командой, то сервер переходит на построчную репликацию. 

binlog_format = 'MIXED'

Параметр log_slave_updates позволяет использовать подчиненный сервер в роли главного для других подчиненных. Изменения, произведенные на главном сервере, распространяются по цепочке подчиненных серверов, не подключенных напрямую к главному.

Обязательно нужно присваивать серверу идентификатор, чтобы предотвратить бесконечные циклы с передачей событий между журналами, т.к. сервер отбрасывает все события, в которых идентификатор совпадает с его идентификатором. 

**Фильтры репликации.** Два вида фильтров: при записи событий в двоичный журнал на master (binlog_do_db, binlog_ignore_db). при чтении событий из журнала ретрансляции на slave (replicate_*).

### Топологии репликации. 

**Один главный сервер с несколькими подчиненными.** Применяется, если операций записи мало, а операций чтения много. Варианты применения:

·   Подчиненные серверы имеют другую конфигурацию: другие индексы или другие подсистемы хранения.

·   Подчиненный сервер используется для резервного копирования, обучения, разработки, тестирования новых версий.

·   Для совместного использования данных с удаленным офисом

**Главный–главный в режиме активный–активный** (с двумя главными, или двунаправленная репликация) подразумевает наличие двух серверов, каждый из которых сконфигурирован одновременно как главный и подчиненный по отношению к другому.Применения узкоспециализированные: в географически разнесенных отделениях, в каждом из которых необходимо изменять данные. Проблема – как обрабатывать конфликтующие изменения, например, одна и та же строка одновременно изменяется на обоих серверах или в один и тот же момент времени производится вставка в таблицу с автоинкрементным столбцом.

**Главный–главный в режиме активный–пассивный**. Один из двух серверов «пассивен», то есть может только читать данные. Схема позволяет без труда менять активный и пассивный серверы ролями, поскольку конфигурации серверов симметричны. Облегчает обновление структуры таблиц: останавливается поток репликации на активном сервере, выполняется изменение таблицы на пассивном сервере, затем смена серверов ролями (пассивный становится активным), запуск потока репликации на сервер, торый раньше был активным. Он читает свой журнал ретрансляции и выполнит ту же самую команду ALTER TABLE. Такой вариант репликации широко распространен и очень полезен.

**Главный–главный с подчиненными**. Необходимо добавить к каждому главному серверу один или несколько подчиненных. Используется между географически удаленными центрами, позволяя устранить единственную точку отказа в каждом центре в виде главного сервера.

**Кольцо (круговая репликация, circular replication)**. Три или более главных серверов. Каждый сервер выступает в роли подчиненного для предшествующего ему сервера и в роли главного для последующего. Проблема: если удалить из кольца один узел, то события, порожденные этим узлом, могут курсировать по кольцу бесконечно, так как отфильтровать событие может лишь создавший его сервер. Кольца по природе своей хрупки и лучше к ним не прибегать.

**Главный, главный–распространитель и подчиненные**. При наличии большого количества подчиненных серверов нагрузка на главный может оказаться чрезмерной. Каждый подчиненный сервер создает на главном отдельный поток. При трансляции подчиненному серверу огромного события у главного сервера может даже закончиться память. В схему можно ввести главный сервер распространитель (distribution master). Он выступает в роли подчиненного и читает двоичные журналы с главного сервера и передавает их далее. К серверу-распространителю можно подключить много подчиненных, сняв тем самым нагрузку с основного сервера. А чтобы не тратить ресурсы распространителя на выполнение запросов, нужно задать на нем для всех таблиц подсистему хранения Blackhole. Такую схему стоит использовать, если к главному серверу присоединяется больше 10 подчиненных. Можно несколько уровней распространителей, можно организовать на одном уровне фильтрацию потока.

**Дерево или пирамида из подчиненных.** Недостаток – отказ на промежуточном уровне
 распространяется сразу на несколько серверов. 

### Приемы

#### Репликация для уменьшения рабочего множества

Чтобы уместить рабочее множество для запросов на чтение в памяти, можно реплицировать части данных на различные подчиненные сервера. Эта схема напоминает шардирование, но ее достоинство в том, что имеется мастер, на котором хранятся все данные.. Это позволяет эффективней использовать память на слейвах, в памяти разных слейвов не дублируются данные. Также на каждый подчиненный сервер будет приходиться лишь часть общей нагрузки, порождаемой операциями записи на главном сервере, так что главный сервер можно будет сделать более мощным, не опасаясь, что подчиненные отстанут. 

Эту схему можно реализовать следующими способами:

·   настроить соответствующим образом фильтры для репликации только некоторых таблиц на каждый slave-сервер.

·   поместить информацию в разные базы на главном сервере, а потом реплицировать каждую базу на разные подчиненные сервера.

 

Можно реплицировать данные с OLTP-сервера на подчиненные серверы, настроенные для работы в условиях OLAP-нагрузки. На них может быть установлено другое оборудование, построены другие индексы (например, полнотекстовые) и применена другая подсистема хранения.

На подчиненном сервере можно хранить архив данных, удаленных с главного. Для этого нужно выполнить на главном сервере команду удаления так, чтобы она не была повторена на подчиненном.

Можно ли репликацию применить к линейному масштабированию записи, так же как и чтения? Ответ – нет. Тут поможет только шардирование.

**Рассогласование**. При покомандной репликации высока вероятность расхождения мастера и реплики. Например, для недетерменированных операций, например такая без ORDER BY, зависит от порядка хранения строк:

UPDATE table1 SET a=2 LIMIT 1

При этом расхождения имеют тенденцию перекидываться на другие таблицы, например, после предыдущей команды эта перекинет расхождение на table2:

INSERT INTO table2 SELECT * FROM table1; 

Результат такого разрастания рассогласованности - сообщение о нарушении ограничения уникальности. Решить проблему можно только заново синхронизировав данные с главным сервером.

**Временные таблицы**. Несовместимы с покомандной репликацией. В случае сбоя или останова подчиненного сервера все временные таблицы, которые использовались в потоке репликации исчезают. Свойства временных таблиц можно эмулировать, зарезервировав специальную базу данных для псевдовременных таблиц. И вместо:

CREATE TEMPORARY TABLE top_users(...) 

можно написать 

CREATE TABLE temp.top_users_1234(...) 

где 1234 – значение, возвращенное функцией CONNECTION_ID(). Можно автоматизировать процесс удаления проверяя список активных соединений с помощью команды SHOW PROCESSLIST и сравнить их с идентификаторами в именах таблиц.

Подчиненный сервер должен быть мощнее главного, т.к. единственный поток обычно задействует лишь один процессор и диск. Ускорить работу подчиненного сервера можно  отключением чего-нибудь, например, уменьшить частоту сброса на диск в подсистеме InnoDB, вследствие чего транзакции станут фиксироваться быстрее (параметр innodb_flush_log_at_trx_commit=2)

## Масштабирование и высокая доступность

**Доступность** - доля времени, в течение которого приложение может отвечать на запросы. Измеряется в «девятках»; так, «пять девяток» 99.999% времени, то есть время простоя составляет примерно пять минут в год.

**Основные определения: производительность, пропускная способность, масштабируемость, отказоустойчивость.**

Увеличение нагрузки постепенно приведит к появлению узких мест и, как следствие, к снижению производительности. Варианты решения:

·   **Scale up** («масштабирование по вертикали», «вертикальное масштабирование») покупают более мощные серверы. 

·   **Scale out** («масштабирование по горизонтали») распределить работу между несколькими компьютерами

·   **Scale back** («масштабирование наоборот») удалить или заархивировать данные, которые используются редко или не используются вовсе

Необходимость масштабироваться проявляется как снижение производительности – в виде замедления обработки запросов, большего потребления процессора, ввода/вывода, роста конкуренции между запросами. Причина этого в увеличении сложности запросов, в том, что какая-то часть данных или индекса, которая раньше помещалась в память, теперь не помещается.

Перед проектированием системы нужно оценить, с какой нагрузкой придется иметь дело. Если оценка завышена, то будет зря потрачено некоторое время на разработку, а если занижено, то возросшая нагрузка застанет вас врасплох. При этом нужно учитывать не среднюю, а ожидаемую пиковую нагрузку. Приложение должно ее выдерживать.

**Предварительные приемы**. Правильно проиндексировать таблицы, выбрать подходящую подсистему хранения, проанализировать журнал медленных запросов. Однако существует точка сокращения отдачи, когда каждая следующая оптимизация требует все больше усилий и дает все менее заметный результат, хотя сложность приложения при этом быстро возрастает.

### Scale up

Имеет смысл для того, чтобы выиграть время и переделать архитектуру системы. Работает в течение некоторого времени, но лишь до тех пор, пока масштаб приложения не превысит критическую отметку. В какой-то момент наращивание мощности оборудования становится неприемлемым из финансовых соображений. Существует некий диапазон аппаратных решений с оптимальным соотношением цены и производительности. За пределами этого диапазона находится в основном специализированное и, соответственно, более дорогое оборудование.

MySQL не слишком хорошо масштабируется по вертикали, поскольку его трудно заставить эффективно использовать несколько процессоров и дисков. Для текущих версий MySQL пределом является 8 ЦП и 14 дисков. В схеме с репликацией имеет смысл усилить подчиненный сервер, т.к. поток репликации на подчиненном сервере не может толком задействовать несколько процессоров и дисков.

Обычно приложения, работающие на одном сервере, сначала упираются в ограничения при чтении, особенно при обработке сложных запросов выборки. Такие запросы внутри MySQL функционируют в однопоточном режиме и если не хватает памяти и данные не помещаются в кеше, то возникает интенсивное обращения к дискам.

### Scale out

Варианты:

·   Репликация. Чтение выполняется на подчиненных серверах. Эта техника хорошо работает в приложениях, где много запросов на чтение.

·   Секционировать рабочую нагрузку по нескольким «узлам». Это единственный способ масштабировать запись.

Под узлом (репликасет, node) понимается функциональная единица. Это может быть:

·   в простейшем случае один сервер

·   главный-главный в режиме активный-пассивный

·   главный и много подчиненных серверов

#### Функциональное секционирование

Функциональное секционирование, или разделение обязанностей означает, что под разные задачи выделяются разные узлы. Например, можно разделить данные на серверах для OLTP- и OLAP-запросов. В более общем смысле, на каждом узле хранятся данные, необходимые конкретному приложению. Например, отделяются данные новостного раздела, форума, технической поддержки, базы знаний и т. д. Однако рано или поздно какое-нибудь приложение или функциональная область разрастется слишком сильно, и тогда придется искать другую стратегию.

#### Шардирование

Смотреть Шардирование

#### Генерация глобально уникальных идентификаторов

Варианты:

·   Использовать  конфигурационные  параметры  auto_increment_increment и auto_increment_offset, которые говорят серверу MySQL, на какую величину увеличивать автоинкрементный столбец и с какого значения начинать нумерацию. Можно их настроить, например, на чередование. Недостаток – требует внимания при конфигурировании серверов.

·   Использовать ключ в сервере memcached, удобно использовать функция incr(). При перезагрузке сервера memcached придется заново инициализировать начальное значение.

При использовании глобального генератора, необходимо следить за тем, чтобы эта единственная точка конкурентного доступа не стала узким местом приложения. Для снижения нагрузки с узла генерации идентификаторов можно выделять значения шардам не одиночно, а сериями. 

·   Создать таблицу на глобальном узле с автоинкрементным столбцом. Можно использовать для ускорения обработки таблицу MyISAM с одной строкой и одним автоинкрементным столбцом:

CREATE TABLE single_row ( 
 col1 int NOT NULL AUTO_INCREMENT, 
 col2 int NOT NULL, 
 PRIMARY KEY(col1), 
 UNIQUE KEY(col2) 
 ) ENGINE=MyISAM;

mysql> REPLACE INTO single_row(col2) VALUES(1);

·   Использовать комбинацию значений, например, номер секции и увеличивающееся число. 

Только для MyISAM можно использовать автоинкрементные ключи по двум столбцам

mysql> CREATE TABLE inc_test( 
 -> a INT NOT NULL, 
 -> b INT NOT NULL AUTO_INCREMENT, 
 -> PRIMARY KEY(a, b) 
 -> ) ENGINE=MyISAM; 
 mysql> INSERT INTO inc_test(a) VALUES(1), (1), (2), (2); 
 | a | b | 
 +---+---+ 
 | 1 | 1 | 
 | 1 | 2 | 
 | 2 | 1 | 
 | 2 | 2 |

·   Сгенерировать GUID (глобально уникальные идентификаторы) с помощью функции UUID_SHORT(), которая возвращает короткие и последовательные значения, приемлемые в качестве первичных ключей (в отличии от функции UUID, возвращающей длинные непоследовательные значения).

### Scale back

Масштабирование наоборот, идея: архивировать и удалять информацию, ставшую ненужной, чтобы убрать данные с сильно нагруженного OLTP-сервера. Можно спроектировать приложение так, чтобы оно архивировало данные, к которым редко обращаются. Архивированные данные можно хранить в отдельных таблицах и обращаться к ним через представления или даже полностью переместить на другой сервер. Например, в Badoo неактивные пользователи перемещаются на «кладбище».

Наличие связей между данными может усложнить архивирование и удаление. Хорошо спроектированная программа архивирования сохраняет логическую согласованность. В процессе масштабирования приходится на время идти на нарушение ограничений внешних ключей при перемещении связных данных.

Зачастую можно убрать значительно больше данных, если процедура архивирования дополняется стратегией извлечения информации из архива (разархивирование). Если вход невозможен из-за отсутствия пользователя, то программа посмотрит, нет ли такого пользователя в архиве (в badoo, на «кладбище»), и если есть, то извлечет его оттуда и продолжит выполнение процедуры входа.

Можно не перемещать пользователя из архива, а использовать его данные прямо оттуда, это позволяет отделить активные данные от неактивных (разделить таблицу users на active_users и inactive_users). Это повышает эффективность использования кэша (активные пользователи не вытесняются из кеша массой неактивных) и позволяет применять для активных и неактивных данных различные аппаратные и программные архитектуры (память и диск, HDD и SSD).

В InnoDB единицей кэширования является страница. Если на одной странице умещается 100 пользователей и только 10% всех пользователей активны, то с точки зрения InnoDB каждая страница будет «горячей», и тем не менее 90% данных на странице – пустая трата памяти.

Можно использовать встроенный механизм секционированния таблиц.

Наиболее универсальный механизм разделения данных на горячие – по времени, т.к. недавние данные наверняка будут гораздо активнее более старых. Новые значения поступают на «активный» узел, в котором очень много памяти и быстрые диски. Старые данные уходят на узлы с большими, но сравнительно медленными дисками. Это реализуется через динамическое секционирование, например, указанием в таблице пользователей: 

CREATE TABLE users ( 

user_id int unsigned not null, 

shard_new int unsigned not null, 

shard_archive int unsigned not null, 

archive_timestamp timestamp, 

PRIMARY KEY (user_id) 

);

### Балансирование нагрузки

Прием: хранить весь объем данных на всех серверах, но на одном подчиненном сервере выполнять запросы к одному множеству секций, а на другом – к другому. При этом один сервер полностью резервирует другой. По сути это секционирование операций чтения, например, для пользователей, чьи фамилии начинаются с букв A–M, направлять запросы на один подчиненный сервер, а запросы для всех остальных пользователей – на другой. Кэш каждого сервера будет использоваться эффективнее, так как более вероятно, что данные для повторяющихся запросов уже находятся в кэше. В лучшем случае стратегия дает кэш, размер которого равен сумме размеров кэшей обоих серверов. Если распределять запросы на чтение между серверами случайно, то данные в кэше каждого сервера дублируются, поэтому его полный эффективный размер не превышает размер самого большого кэша на всех подчиненных серверах.

Балансирование нагрузки при репликации: 

·   направлять все запросы на запись, а также те критические запросы на чтение, для которых неактуальные данные неприемлемы, активному или главному серверу. Все остальные запросы на чтение попадают на подчиненный или пассивный сервер. 

·   вести учет отставания реплики в приложении.

·   учитывать, кто запрашивает данные. Установить в сессии флажок, который показывает, что в сеансе было произведено изменение, и в течение некоторого времени после этого события направлять запросы на чтение, главному серверу. Можно сочетать с учетом отставания реплики, если реплика успевает за изменения текущего пользователя, то читать с реплики.

·   Записывать в таблицу номер версии или временную метку объекта и по ней определять свежесть данных. Номером версии может быть координата в журнале транзакций на мастере (получить через SHOW MASTER STATUS). При чтении ее можно сверить с координатой на реплике (через  SHOW SLAVE STATUS) 

При добавлении сервера в пул необходимо в течении некоторого времени его прогреть, например, повторять на новом сервере все запросы SELECT с какого-нибудь активного сервера и только потом известить о нем балансировщик нагрузки.

### Высокая доступность

Высокая доступность в системе гарантируется избыточностью и в случае выхода сервера из строя, подключением резервного. Каждое следующее увеличение степени доступности, как правило, обходится дороже предыдущего, т.е. отношение доступности к потраченным усилиям и стоимости нелинейно. 

Самый важный принцип в деле обеспечения высокой доступности – выявить и устранить единые точки отказа в системе за счет избыточных ресурсов в системе. Избыточность системы может принимать две формы: 

·   запасная пропускная способность

·   дублирование компонентов. Пример – поднять реплику, и при падении master поднять уровень slave до master.

При этом не нужно загружать компоненты «под завязку», поскольку в этом случае у вас остается запас для поддержания требуемой производительности при возрастании нагрузки или отказе некоторых компонентов.

Failover – переключение на резервный сервер при отказе основного. Failback – «возврат на основной сервер». Распределение нагрузки вышедшего из строя сервера по другим приводит к работе системы в режиме с ухудшенными характеристиками (degrade mode).

## Оптимизация на уровне приложения

·   При оптимизации нужно изучить запросы и бизнес-процессы, например, подсчет строк нужно доверить БД, а сложные обработки регулярными выражениями – приложению. Иногда некоторые функции надо перенести в приложение, например, «ручное соединение» в приложении, позволяет реализовать более детальное и эффективное кэширование, уменьшить количество блокировок (особенно в случае использования MyISAM), ускорить работу приложения за счет эмуляции хеш-соединений в прикладном коде. 

·   На подключение тратится время, поэтому лучше использовать одно и то же соединение на протяжении всего запроса (или использовать постоянные соединения, хотя выбор соединения из пула требует также времени на сброс состояния).

·   Убрать мусорные запросы, типа выбор требуемой базы данных перед каждым запросом. Если требуется менять базы, то можно писать полное именя базы перед таблицей. Убрать команду SET NAMES UTF8, которая в любом случае не нужна (она не изменяет кодировку в клиентской библиотеке, а воздействует только на сервер). Кодировку нужно настроить по умолчанию на сервере.

·   Использовать пул соединений. Однако  может образовываться слишком много соединений с MySQL. В общем случае пул не рекомендуется, за исключением ситуации, когда подключение к MySQL обходится слишком дорого  из-за мед- 
 ленной сети (хотя MySQL спроектирован на быстрое соединение), или когда соединение используется всего для одного двух быст рых запросов, или когда подключение производится настолько часто, что не хватает номеров локальных портов Важно правильно сконфигурировать MySQL, в частности устанавливайте достаточно большое значение параметра количество потоков в кеше  thread_cache.

·   Следует закрывать соединения, если они не нужны. Потоки из кеша MySQL могли бы пригодиться другим процессам.

### Оптимизация веб-сервера

Сценарии на PHP очень требовательны к ресурсам и процесс Apache может потреблять десятки мегабайт. По завершении обработки запроса НЕ вся память возвращается операционной системе, т.к. Apache повторно использует ее для последующих запросов. Следовательно, если следующим поступит запрос на статический ресурс, например CSS-файл или изображение, то этот простенький запрос будет обслуживаться очень «толстым» процессом. Поэтому для легких задач, вроде отдачи статики, перед apache лучше раместить nginx.

Варианты ускорения: 

·   Перед apache можно разместить кэширующий прокси-сервер (Squid или Varnish), чтобы вообще не допустить запросы до веб-сервера.

·   Отключить ненужные модули Apache в httpd.conf, удалить ненужные модули PHP из php.ini.

·   Включить вечное кеширование CSS и JS. Для обновления файлов использовать номер версии в имени файла, например ?123 или 123_style.css.-

·   Не допускать длительное время жизни процесса Apache, не позволять Apache «кормить клиента с ложечки». Например, балансировщик нагрузки может буферизовать ответы веб-сервера, поэтому Apache может завершить свою часть работы быстро, а уж балансировщик будет потихоньку отдавать клиенту содержимое из буфера. 

·   Включить gzip-сжатие. Для современных процессоров эти накладные расходы ничтожны,

### Кеширование

Требования к кэшируемым данным:

·   большое количество запросов на чтение

·   малое количество вариантов кешируемых данных (например, результаты поиска нет смысла кешировать)

·   редкие изменения (инвалидация)

Согласно закону Парето 20/80 – 80% запросов приходятся на 20% данных. И задача стоит выявить эти 20% данных и разместить их в кеше, в быстрой памяти.

Кеширование можно также рассматривать, как один из способов снизить time cost в обмен на space cost (в space-time trade-off), т.е. мемоизированные функции уменьшает время выполнения в обмен на использование дополнительной памяти. 

Результат работы функции может быть закеширован только в том случае, если функция обладает *ссылочной прозрачностью* (referentially transparent); то есть, если вызов функции имеет тот же эффект, что и просто возврат результата этой функции (я думаю, это связано с нульпотентностью).

Расчет накладных расходов:

Кэширование не всегда полезно, т.к. с кэшированием связаны определенные накладные расходы: 

·   необходимо проверить наличие данных в кэше и обслужить запрос оттуда в случае попадания. 

·   необходимо поместить данные в кэш или сделать их недействительными.

·   усложняется логика работы приложения

Кэширование полезно лишь в том случае, когда эти издержки не превышают стоимость генерации и обслуживания страницы без кэша. Стоимость обслуживания без кэша – это стоимость генерации данных при каждом запросе. Стоимость обслуживания с кэшем:

  

  называется hit,   – miss. 

Как правило, эффективность работы системы кеширования оценивают по hit ratio. Считается, что если hit>95% - отлично, hit<80 – плохо.

 

Типы кешей по активности:

Кэши можно подразделить на пассивные и активные. Запрашивая что-то из пассивного кэша, вы либо получаете результат, либо сообщение «такого у меня нет» (пример memcached). Активный кэш передает поступивший запрос какой-то другой части приложения, которая и генерирует затребованный результат. Затем кэш сохраняет его и возвращает запросившей программе (пример - кэширующий прокси-сервер Squid). Активные кэши являются прозрачными и скрывают логику проверки, генерации и сохранения. Активные кэши строятся поверх пассивных.

Недостатки:

Кеширование иногда маскирует проблемы в системе, которые в обычные периоды времени (cache hit ratio высокий) не заметны. Но при нарастании нагрузки чаще выполняется инвалидация кеша, большее количество потоков занято перегенерацией кеша и система падает из-за того, что значительно вырастает время обработки одного запроса, не хватает потоков для обработки всех запросов (подробнее про анализ нагрузки Анализ нагрузки).

Паттерн реализации кеширования в PHP:

Кеширование может вручную явно прописываться в каждую функцию.

**function** getData()
 {
   **if** (**false** === ($data = $memcache->get($key))) {
     $data = calculate();
     $memcache->set($key, $data);
   }

   **return** $data;
 }

Но по сути процедура кеширования является сквозной функциональностью (cross cuting concern). Поэтому более удобны механизмы автоматического кеширования, когда исходная функция вызывает внутри стандартного шаблона кеширования. Для это могут быть использованы стандартные паттерны (decorator, observer) или библиотеки АОП (об этом подробнее Аспектно-ориентированное программирование (АОП))

#### Уровни кеширования

Существует много уровней кэширования. Кэширование производится на всем пути следования, включая браузер пользователя. 

Чем ближе кэш к клиенту, тем больше ресурсов в нем хранится и тем он эффективнее, но тем сложнее выполнять его инвалидацию. Извлекать изображение из кэша броузера лучше, чем из памяти веб-сервера, а последнее лучше, чем читать его с диска сервера. 

Каждому типу кэша присущи свои характеристики, например размер и задержка.

##### Кэширование на уровне БД

Возможны следующие виды:

·   Встроенные кеши MySQL (пул буферов InnoDB, кэш ключей MyISAM, кэш уровня ОС, query cache)

·   Управляемые пользователем кэширующие и сводные таблицы. Кэширующие таблицы существуют дольше, чем большинство кэшей на уровне приложения, поскольку они не исчезают при перезапуске сервера, персистентны.

##### Кэширование на уровне приложения

Кэш уровня приложения обычно размещается в памяти на том же самом компьютере или в памяти другого компьютера, доступного по сети. Чем глубже обработка данных перед кэшированием, тем больше времени удается сэкономить при попадании в кэш, самая глубокая обработка – готовые HTML-фрагменты.

###### Типы кэшей по месту хранения:

Кеша на время запроса в памяти воркера

Данные кешируются в памяти одного воркера на протяжении обработки одного запроса (как правило, в статической переменной PHP). Принцип работы также называется мемоизация (memoization) — сохранение результатов выполнения функций для предотвращения повторных вычислений. 

Реализации функции строится по следующему алгоритму:

·   если функция ранее не вызывалась, то она вызывается и результат её выполнения сохраняется в переменную;

·   если функция вызывалась, используется сохранённый результат.

**function** get_name_from_id($user_id) {
   **static** $name;
   **if** (!**isset**($name[$user_id])) {
     $name[$user_id] = $db->select(**'...'**); *// Выбрать из базы данных 
\*   }
   **return** $name[$user_id];

} 

В некоторых языках есть модуль Memoize.

Кэши в локальной разделяемой памяти

Высокая скорость доступа, но локальны и требуют согласования. Реализация: библиотеки *shmop,* *shm*. Примеры: таблица шардирования

Распределенные кэши в памяти

Пример: memcached. Не нужно проблемы согласования, возникающие, когда одна и та же информация кэшируется в разных местах. Время задержки у таких кэшей гораздо выше, проблемы конкуренции.

Кэши на диске

Медленные, лучше кэшировать объекты, не помещающиеся в памяти, или статическое содержимое: предварительно сгенерированные изображения, tn-ки, статические страницы. 

Приемы:

·   как сделано у нас с TN: проверять на диске наличие файла с картинкой TN, а если картинка отсутствует отправлять запрос на бекенд для генерации картинки в PHP. Бекенд сгенерирует изображение, поместит его на диск и вернет в браузер. Все последующие запросы будут просто возвращать картинку из файла. Сброс кеша осуществляется простым удаление файла.

·   сохранить массив данных в  JS файл, и сослаться на него в html. JS будет закешировано в браузере. Сброс кеша выполняется изменением файла и сменой версии файла в html. 

Периодически запускаемый скрипт может реализовывать любую стратегию управления кешем: TTL (удаление файлов, созданных более N минут назад), ограничения размера кэша (LRU, с учетом времени последнего доступа, MRU, LFU).

Таблицы баз данных в оперативной памяти

Этот механихм релизуется через таблицы в подсистеме хранения данных MEMORY. Хотя данные будут очищены после перезагрузки сервера - схемы таблиц будут сохраняться. 

Преимущества:

·   поддерживает SQL

·   хранением данных в памяти

**·**   создания индексов на основе хеш-таблицы

Недостатки:

·   проигрывает более простым методам доступа CRUD, типа Memcached.

###### Типы кешей по уровню обработки

Кэширование HTML-страницы целиком. 

Преимущества:

·   Наиболее эффективный вариант кеширования. 

Недостатки: 

·   отсутствует гибкость, например, невозможно менять какие-то части страницы под конкретного пользователя. 

Применение:

·   для страницы гостевого пользователя, которая для всех гостей одинакова

·   в случае maintenance и failure

Техники

Можно формировать статические страницы в фоновом процессе и сохранять в какую-то папку. Необходимо подобрать формат для имени статических страниц, который позволит при запросе серверу Nginx проверить наличие статической страницы в папке для запрашиваемого URI.

Если вся страница не является полностью статической, то можно хотя бы закешировать в статические файлы отдельные ее части. Для сборки страницы целиком из статических блоков необходимо применить технологию включения на стороне сервера (server-side include – SSI).

Скорее всего кешированные целиком страницы размещаются на диске, поэтому к ним применимы техники из Кэши на диске. Для статических страниц можно применять описанную там технику с TN (смотреть наличие статической страницы, а если ее нет, то формировать на бекенде).

Кэширование результатов компиляции php-файлов

Подробнее Акселераторы

Кэширование отдельных блоков страницы

Наиболее гибкий и доступный для управления программисту вариант кеширования. Позволяет менять содержимое страницы в зависимости от полученного запроса (сессий, кук, заголовков). 

##### На уровне браузера (browser) и в сети (proxy, gateway, CDN)

Это кеши, которые встроены в браузер (browse cache), и находятся между веб-сервером и браузером в сети (proxy cache, gateway cache). Наиболее эффективный тип кеша, т.к. находится близко к клиенту. Однако наиболее сложный для инвалидации, поэтому в него необходимо помещать статические данные (например, изображения).

Преимущества использования:

·   Уменьшение времени получения контента в браузере. Важно для клиента.

·   снижение сетевого трафика. Для клиента – в случае browser cache, для сервера – в случае любых cache в сети.

Управление кешированием выполняется с помощью заголовков ответа HTTP (подробнее Для управления кешированием). Исторически заголовки кэшировании относились лишь к браузеру клиента, но сегодня следует учитывать их влияние на промежуточные точки в соединении.

###### Свежий (freshness) и валидный (validation) контент

**Свежий** (freshness) контент извлекатся непосредственно из кэша без всяких проверок и взаимодействия с сервером-источником этого контента.

**Валидный** (validation) контент – контент, который уже устарел, т.е. несвежий, но прошедший процесс валидации на сервере, который потдвердил, что контент актуален и соответственно не требует повторной загрузки на клиент. 

Процесс **валидации** несвежего закешированного контента заключается в дополнении запроса специальными заголовками-валидаторами (If-Modified-Since, If-None-Match). Если контент браузера актуален, то сервер может его не возвращать, а ответить заголовком 304 Not modified. Такой запрос называют условным, т.к. процесс его обработки зависит от условия.

###### Кэш браузера (browser cache)

Располагается на компьютере клиента, управляется браузером. Браузер один раз за сессию (текущем сеансе) проверяется свежесть контента, при необходимости валидирует его или загружает. 

###### Прокси-кэш (Proxy cache)

Кеш на прокси-сервере в сети, обслуживающем множество клиентов. Может настраиваться вручную в браузере. Запрошенные одним клиентом контент будет сохранен в кеше и может отдаваться другим клиентам. 

###### Кэш-шлюз (Gateway Cache)

Так же называются “реверсивные прокси-кэши” (reverse proxy cache) или “суррогаты” (surrogate cache) шлюзы. Используются для снижения нагрузки на сервер. Включают в себя балансировщик нагрузки. 

Примером является сеть доставки (дистрибуции) содержимого (Content Delivery (Distribution) Network, CDN) — географически распределённая сетевая инфраструктура, позволяющая оптимизировать доставку и дистрибуцию [содержимого](https://ru.wikipedia.org/wiki/Данные_(вычислительная_техника)) пользователям. При правильной настройке, CDN передаёт контент клиентам через самый быстрый и ближайший к нему сервер. Бонус: если вдруг падают сервера, CDN отдает данные из кэша так, что пользователи этого могут и не заметить.

###### Алгоритм работы кеша

\1.  Проверяется свежесть (freshness) контента. Свежим считается контент, у которого установлено время истечения (Expires) или другой заголовок (Cache-Control), контролирующий время жизни, и он еще не истек. Свежий контент берется непосредственно из кэша, без взаимодействия с сервером-источником этого контента.

\2. Если контент является устаревшим, серверу-источнику будет предложено проверить его валидность, для того чтобы не загружать контент целиком заново. 

\3. Если контент не свежий и не валидный он загружается. 

\4. Если заголовки ответа сообщают кэшу не сохранять ответ, он не сохранит.

\5. Если в ответе нет информации о свежести контента (Expires или Cache-Control) и не присутствует валидатор (Last-Modified или ETag), контент считается некэшируемым.

\6. Иначе контент кешируется. HTTPS кешируется также как и HTTP.

###### Стратегия кэширования

Динамический контент как правило не кешируется выставлением заголовка:

**Cache-Control**: max-age=0, no-cache, no-store

Однако иногда динамический контент не меняется какое-то время. В этом случае контент можно закешировать в браузере, если пользователь обращается к странице несколько раз, либо на промежуточных прокси-серверах.

Приемы:

·   Если ресурс необходимо перекешировать, то его нужно переименовать, добавив к имени  увеличивающийся номер версии, временной ярлык, хэш.

·   Один и тот же контент должен быть доступен по одному URL-адресу

·   Динамический контент имеет смысл кешировать, если он статичен некоторое время и зависит только от URL-адреса. Отправку заголовков кеширования и валидацию по запросу (If-No-Match) должен обеспечивать скрипт на сервер. 

·   Контент, который зависит от куков, информации об аутентификации или от какого-то другого внешнего фактора, нельзя кешировать. 

·   Можно сделать динамический контент статическим, т.е. выгрузить его содержимое в файл при очередном изменении и переложить кеширование на веб-сервер.

·   Запросы POST не кешируются большинством кэшей

·   Если требуется на закешированную страницу поставить счетчик, то возможные варианты:

o  Скриптом дергать счетчик и отправлять данные для подсчета (URL).

o  Разместить на кешированной странице **некешируемый** zeropyxel, URL страницы можно получить из параметров запроса к zeropyxel или из заголовка Referer.

·   Если хочется кешировать страницы, индивидуальные для каждого пользователя, можно с помощью заголовка Cache-Control указать, что требуется проводить валидацию страницы при каждом запросе с помощью заголовка (обязательно нужно использовать также ETag)

**Cache****-Control**: public, **no****-cache**

В запросе на валидацию вместе с заголовком If-None-Match будут переданы куки с аутентификацией пользователя. В скрипте можно решить по данным в сессии пользователя: вернуть контент целиком или 304 Not Modified.

·   Если на странице есть элементы, отображение которых отличается для разных пользователей, можно их загружать скриптом с помощью технологии AJAX.

#### Инвалидация кэша

Инвалидация кеша – это компромисс между полнотой, избыточностью и сложностью этой процедуры. **Полнота инвалидации** — насколько часто в кеше будут содержаться грязные данные. **Избыточность** – как часто кеш будет инвалидироваться без необходимости.

##### Инвалидация по времени

Выполняется установкой времени жизни кэша (TTL). Вместе с кэшированным объектом хранится момент истечения срока хранения; Удаление выполняет либо сама система кеширования, либо ручной фоновый процесс, либо в момент обращения запроса. 

Гарантирует, что сразу после изменения данных кеш грязен. Время, которое кеш остаётся грязным, мы можем легко ограничить, уменьшив время жизни (что в свою очередь сократит процент попаданий). Т.е. при сокращении времени жизни кеша полнота инвалидации улучшается, а избыточность ухудшается. Подходит для редко изменяющихся данных или для которых требования к актуальности не критичны.

##### Инвалидация по событию

Если кэширование устаревших данных неприемлемо, то необходимо сразу инвалидировать данные в процессе, которые их изменяет. 

Возможны два варианта:

Инвалидация при записи

Варианты: 

·   просто помечать во всех инвалидируемых ключах, что данные недействительны, грязные, а перегенерировать в момент чтения

·   сразу обновить данные во всех ключах, которые стали недействительными. 

Желательно обновление кеша производить в фоновом режиме, не связанном с запросами пользователей. Недостаток фонового обновления: усложнение кода, на каждый кешируемый объект требуется написать инвалидирующий код. 

Есть попытки встроить инвалидирующий код прямо в библиотеку работы с запросами, т.е. отслеживать какие запросы кешировались и при изменении этих данных инвалидировать этот кеш, например, кешируется запрос

where category_id=2 and published=true

на все изменяющие запросы, попадающие под это условие делаем инвалидацию кеша. 

Инвалидация при чтении

Вместе с объектом сохраняется **номер его версии** или временная метка, от которых зависит кэшированный объект. Хранение номеров версий также называется тегированным кешем. 

Преимущество: 

·   операции пересчета связанных данных «размазываются» по времени.

Примеры:

·   вместе со stat пользователя в кеш помещается номер версии пользователя. При каждом обновлении данных пользователя user обновляется номер его версии (например, сохраняется также в кеше). При отображении статистики мы сравниваем версию пользователя в stat c версией пользователя в user, и при необходимости пересчитываем статистику пользователя. 

·   кэшировать вместе с комментариями к книге версии пользователя и версии книги, например, user_ver=1234 и book_ver=5678. И в кеше отдельно хранить текущую версию пользователя и книги. 

#### Кэширование иерархий объектов

Зачастую удобней кешировать не полную выборку из всех таблиц, а данные из связанных таблиц разместить в отдельных кешах и ссылаться на них по первичному ключу. 

Пример: при кешировании результатов поиска у нас можно кешировать список первичных ключей постов, а сами посты хранить в отдельном кеше. 

Преимущество:

·   позволяет не дублировать описание постов в нескольких кешах. 

·   позволяет легко выполнять инвалидацию кешей с отдельными постами, изменение поста не требует пересмотра всех кешей, где он хранится. 

Недостатки: 

·   требуется несколько запросов в кеш на одну выборку, однако можно реализовать в два запроса: 

o  выбрать список ID постов

o  сделать multi_get в memcached за информацией о нескольких постах по их ID

·   возможны проблемы нарушения согласованности данных в кеше, т.к. список постов и отдельные посты в кеше могут правиться независимо. Например, может измениться заголовок поста таким образом, что перестанет содержать ключевые слова, отвечающие условиям поиска, однако результат поиска еще не удален из кэша. Если такая ситуация неприемлема, то можно воспользоваться кэшированием с версиями и хранить версии товаров вместе с результатами поиска. 

## Резервное копирование и восстановление

Выделяют:

·   горячее резервное копирование – без остановки сервера

·   холодное резервное копирование – с остановкой сервера.

Особености резервного копирования:

·   необходимо постоянно проверять не только корректность резервного копирования, но и корректность восстановления из резервных копий

·   Реплика не является резервной копией

Холодное резервное копирование

Если холодное резервное колпирование допустимо, то это самый безопасный и наилучший способ получить копию данных с минимальными шансами внести искажения или несогласованность. Это позволяет не беспокоиться о том, что данные модифицируются в процессе резервного копирования.

Однако перевод сервера в холодный режим и включение назад может быть очень длительным:

·   в процессе останова сервера: возможно в пуле буферов InnoDB много «грязных» буферов, которые в памяти уже модифицированы, но на диск еще не записаны. Для их сохранения у InnoDB может уйти много времени.

·   в процессе старта сервера: требуется открытие всех таблиц и прогрев кэшей, в том числе пул буферов InnoDB.

Горячее резервное копирование

Горячее резервное копирование часто рекомендуют начинать с выполнения команды 

FLUSH TABLES WITH READ LOCK

Тем самым мы говорим MySQL, чтобы он сбросил и заблокировал все таблицы, а также опустошил кэш запросов. Команда FLUSH TABLES WITH READ LOCK обходится не так дорого, как останов сервера, потому что большая часть данных остается кэшированной в памяти, и сервер «прогрет», но все равно она мешает нормальной работе.

После окончания резервного копирования таблицы должны быть разблокированы командой:

UNLOCK TABLES;

Использование репликации

Часто резервную копия снимается с подчиненного сервера репликации, так как его можно останавливать и перезапускать со сравнительно небольшими издержками.

### Логическое и физическое копирование

Существует два основных способа резервного копирования данных: 

·   логическое – такая копия называется также «дампом»

·   физическое – копирования исходных файлов. 

Логическое копирование

В логической резервной копии данные представлены как SQL-команды или как текст с разделителями. 

Преимущества:

·   процедуру можно очень гибко настраивать. mysqldump принимает множество параметров, например фразу WHERE

·   снятый дамп никак не отражает физическую структуру таблиц. Дамп можно править и изучать в текстовом редакторе. Это позволяет снять копию таблицы типа InnoDB и восстановить ее в таблицу типа MyISAM, или даже вообще в другую СУБД.

Недостатки:

·   Для их генерации требуется работа сервера, так что процессор загружается сильнее.

·   В некоторых случаях логические копии оказываются объемнее исходных физических файлов. ASCII-представление данных не всегда так же эффективно, как внутреннее представление в подсистеме хранения. Зачастую логические копии хорошо поддаются сжатию, но для этого нужно дополнительное процессорное время.

·   Для восстановления данных из логической копии необходимо загружать и интерпретировать команды и перестраивать индексы, что возлагает на сервер еще больше работы.

Физическое копирование

Физическое резервное копирование – это копирование файлов базы данных, в том виде, в каком они находятся на диске.

Преимушества:

·   Простота резервного копирования: достататочно просто скопировать файлы базы данных в другое место.

·   Простота восстановления: достаточно просто скопировать файлы с таблицами назад в папку базы данных. Причем в случае MyISAM можно не нужно останавливать веб-сервер, а в случае InnoDB нужно перезапустить сервер. 

·   Как снятие так и восстановление гораздо быстрее и не нагружают сервер, т.к. серверу не нужно выполнять SQL-команды и строить индексы.

Недостатки:

·   Размер физической копии InnoDB больше объема логической, т.к. в табличном пространстве InnoDB очень много неиспользуемого места.

·   Физическую копию очень сложно переносить на другой узел, с отличающейся версией MySQL, ОС и т.д.

После восстановления из физической резервной копии следует выполнить проверку базы данных с помощью команды:

CHECK TABLES 

Как правило, быстрее и менее трудоемко снять физическую резервную копию. Однако физические копии не переносимы между системами и могут скрывать труднообнаруживаемые повреждения.

Можно скомбинировать преимущества обоих подходов, выполнив следующий алгоритм: 

·   снять физическую копию

·   восстановить ее на отдельном сервере с MySQL

·   снять на отдельном сервере логическую копию. 

### Согласованность данных

При снятии резервной копии необходимо гарантировать, что данные в копии согласованы по времени. Например, в базе данных Фишек недопустимо, чтобы существовал Пост, но не существовало пользователя-автора. 

Согласованность при снятии логической копии

Нельзя просто блокировать и копировать таблицы по одной. Для нетранзакционной системы MyIsam не остается другого выбора, как выполнить команду LOCK TABLES для всех таб лиц, которые должны копироваться вместе, и освободить блокировки только после того, как процедура будет полностью завершена.

В InnoDB можно использовать технологию MVCC следующим образом: 

·   начать транзакцию, 

·   выгрузить таблицы в резервную копию 

·   зафиксировать транзакцию. 

Это позволяет получить идеально согласованный по времени снимок данных, не блокируя при этом работу сервера на время снятия копии. С помощью mysqldump можно выполнить описанный выше алгоритм автоматически, добавив флаг –single-transaction.

Согласованность при снятии физической копии

В случае нетранзакционной подсис темы хранения MyISAM, единственный вариант выполнить последовательность команд:

·   заблокировать таблицы

LOCK TABLES

·   сбросить накопившиеся в памяти изменения на диск. 

FLUSH TABLES

Также можно это сделать за одну команду FLUSH TABLES WITH READ LOCK. 

После этого можно безопасно копировать физические файлы, в которых хранятся таблицы MyISAM.

В случае InnoDB снять согласованный снимок таким образом невозможно, т.к. даже после команды FLUSH TABLES WITH READ LOCK InnoDB не прекращает работу в фоновом режиме: фоновые потоки продолжают вносить изменения в журнал и файлы табличного пространства.

### Двоичные журналы сервера

Двоичный журнал – это набор файлов, который содержит в бинарном виде последовательное описание событий модификации содержимого базы данных. В MySQL двоичный журнал используется для репликации. Также двоичный журнал полезен для восстановления на определенный момент времени. Если существует резервная копия информации, снятая в какой-то момент времени, и все двоичные журналы, накопившиеся с этого момента, то эти журналы можно воспроизвести, то есть «накатить» изменения, произведенные с момента последней полной резервной копии.

Пример включения двоичного журнала:

log_bin = mysql-bin # Путь и базовое имя лог-файлов (конкретные имена mysql-bin.000001, mysql-bin.000002 и т.д.)

sync_binlog = 1 # Синхронизировать бин-лог после каждой транзакции

Для просмотра содержимого двоичного журнала можно воспользоваться инструментом mysqlbinlog. 

Пример вывода утилиты:

shell> mysqlbinlog *log**_**file*

*...*

1 # at 277 
 2 #071030 10:47:21 server id 3 end_log_pos 369 Query thread_id=13 
 exec_time=0 error_code=0 
 3 SET TIMESTAMP=1193755641/*!*/; 
 4 insert into test(a) values(2)/*!*/; 

Строка 1: указано смещение в байтах от начала файла журнала (в данном случае, 277).

Строка 2: приведена следующая информация: 

o  дата и время события, которые используются для генерации команды SET TIMESTAMP ниже. 

o  server_id – идентификатор исходного сервера, который необходим для предотвращения зацикливания репликации.

o  end_log_pos – смещение начала следующего события

o  thread_id – идентификатор потока, обработавшего событие на исходном сервере.

o  exec_time – время, затраченное на выполнение команды

o  error_code – код ошибки, возникшей при обработке события на исходном сервере.

В остальных строках печатаются SQL-команды, необходимые для воспроизведения события.

При использовании построчной репликации событие не содержит текста SQL-команд, а является «образом» модификаций, произведенных данной командой в таблице. Эти события не предназначены для чтения человеком.

Настройка expire_logs_days позволяет указать, через сколько дней следует удалять двоичные журналы. Желательно иметь все двоичные журналы с момента снятия полной резервной копии.

### Способы снятия резервной копии

#### Общая схема снятия резервной копии

\1.  Сбросить накопившиеся в памяти изменения на диск и заблокировать таблицы:

mysql> FLUSH TABLES WITH READ LOCK

Если выполняется этот шаг, то доступ к данным блокируется на время снятия снимка. При этом может быть затрачено много времени на захват блокировки. 

\2. Попросить сервер начать новый двоичный журнал. Восстановление и инкрементное резервное копирование будут проще, если не придется думать о том, с какого места в середине файла журнала начинать:

mysql> FLUSH LOGS;

\3. Записать в файл состояние сервера, в его роли как главного, так и подчиненного. Позиция в файле двоичного журнала, выдаваемая этой командой, может понадобиться для восстановления.

bash# mysql -e “SHOW MASTER STATUS” --vertical > /backup/master.info;

bash# mysql -e “SHOW SLAVE STATUS” --vertical > /backup/slave.info;

\4. выгрузить логическую или физическую копию

\5. разблокировать таблицы

mysql> UNLOCK TABLES;

#### Логическая резервная копия

Если при снятии логической копии, не выполнить шаг 1, то согласованность таблиц не гарантируется. Но отдельные таблицы будут записаны в резервную копию корректно.

##### SQL-дамп через mysqldump

Утилита mysqldump осуществляет вывод в стандартный поток (экран монитора). Вывод следует перенаправить в файл. при помощи оператора >. 

Оператор >> добавляет резервную копию в конец файла. Это может быть удобно, если требуется дозаписать таблицу.

Рекомендуется исключать из дампа GTID (идентификатора транзакций) с помощью ключа:

--set-gtid-purged=OFF

Пример снятия дампа базы данных в файл:

mysqldump --set-gtid-purged=OFF` -uUSER -pPASSWORD DATABASE > /path/to/file/dump.sql```

Дамп только одной или нескольких таблиц

mysqldump --set-gtid-purged=OFF` -uUSER -pPASSWORD DATABASE TABLE1 TABLE2 TABLE3 > /path/to/file/dump_table.sql`

Создаём бекап и сразу его архивируем

mysqldump` -uUSER -pPASSWORD DATABASE | `gzip` > /path/to/outputfile.sql.gz`

Копирование таблицы с одного сервера на другой:

mysqldump –hSERVER1 DATABASE TABLE | mysql –hSERVER2 DATABASE

Снятие дампа всех баз данных:

mysqldump --all-databases > dump.sql

Так же есть набор опций для управления блокировками во время снятия резервной копии:

| --lock-all-tables | Блокировать все  таблицы во всех базах данных         |
| ----------------- | ----------------------------------------------------- |
| --lock-tables     | Блокировать  только указанные таблицы из базы данных. |

 

Дамп части таблицы и выбор данных из связанных таблиц скриптом на bash

DATABASE=newfishki

DB_FILE=/www/dump_fishki.sql

LIMIT=10000

 

mysqldump --set-gtid-purged=OFF ${DATABASE} fishki_post --where "1=1 ORDER BY id DESC LIMIT ${LIMIT} " >> ${DB_FILE}

mysqldump --set-gtid-purged=OFF ${DATABASE} fishki_pg_data --where "post_id IN (SELECT * FROM (SELECT id FROM fishki_post ORDER BY id DESC LIMIT ${LIMIT})t)" --single-transaction >> ${DB_FILE}

mysqldump --set-gtid-purged=OFF ${DATABASE} fishki_gallery --where "post_id IN (SELECT * FROM (SELECT id FROM fishki_post ORDER BY id DESC LIMIT ${LIMIT})t)" --single-transaction >> ${DB_FILE}

Недостатки:

·   получается один гигантский файл. Из него сложно вычленить только схему БД или какую-то одну таблицу.

·   Очень дорого создание резервной копии, т.к. фактически делаются выборки SELECT из таблиц. А это не самый лучший способ вытащить данные из таблиц. 

·   Очень дорого загружать резервную копию, т.к. требуется выполнять SQL-команды. Т.е. от сервера требуется выполнить шаги: рабор запроса, планирование запроса и т.д.

Поэтому для огромных таблиц использование SQL-дампа неприемлимо. Более эффективным способом является использование резервных копий в виде файлов с разделителями.

##### Резервные копии в виде файлов с разделителями

Используется команда SELECT INTO OUTFILE SQL. 

Пример параметров команды, для получения результата в формате CSV – с разделителями-запятыми:

mysql>   SELECT * INTO OUTFILE '/tmp/t1.txt'

​     FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

​     LINES TERMINATED BY '\n'

​     FROM test.t1;

Итоговый файл содержат только значения без SQL-команд, комментариев и имен столбцов.

Для восстановления данных назад в эту же таблицу предназначена команда LOAD DATA INFILE, которой следует указать те же параметры, что при выгрузке:

mysql>   LOAD DATA INFILE '/tmp/t1.txt'

​     INTO TABLE test.t1 

​     FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'

​     LINES TERMINATED BY '\n';

Автоматизирует выгрузку всех таблиц из базы данных программа mysqldump, запущенная с параметром --tab. 

mysqldump --tab=/path/to/dir/ -uLogin -pPass DBName

Значением параметра --tab является путь к папке, в которой будут созданы для каждой таблицы:

·   файл tbl_name.sql с [CREATE TABLE](https://dev.mysql.com/doc/refman/5.7/en/create-table.html) оператором создания таблицы

·   файл tbl_name.txt с данными таблицы.

Преимущества:

·   по тестам время резервного копирования и восстановления данных меньше в 1,5-2 раза, чем для SQL-дампа

·   результирующий файл меньше по объему примерно на 10% и разбит по таблицам

Т.к. запись в файл данных выполняет сам MySQL, а не запущенное пользователем приложение есть ряд ограничений:

·   MySQL может писать в файл только локально

·   MySQL не может сразу сжимать результат 

##### Параллельное резервное копирование в несколько процессов

Можно быстрее выгружать и загружать данные, если делать это в несколько процессов на многоядерном процессоре. Имеет смысл параллельно производить выгрузку и загрузку различных таблиц, а не параллельную выгрузку/загрузку одной таблицы.

Параллельную выгрузку можно организовать вручную, запустив несколько экземпляров программы резервного копирования. В папке mysql/bin также имеется утилита mysqlimport для загрузки данных из текстового файла, поддерживающая параллельную загрузку в несколько потоков.

#### Физическая резервная копия

Если при снятии физической копии, не выполняется 1 шаг, то не тратится время на получение блокировки. При это для файлов нетранзакционной MyISAM нет никаких гарантий согласованности. Для InnoDB выполнение этой команды не имеет существенного значения, т.к. даже после нее в пул буферов InnoDB продолжают вноситься изменения.

Фоновые потоки InnoDB продолжают работать даже после блокировки таблиц. Поэтому файлы в снимке будут выглядеть так, будто сервер аварийно завершил работу. 

Однако это не проблема, поскольку InnoDB – транзакционная подсистема хранения. Любая зафиксированная транзакция – долговечна (ACID) и зафиксирована либо в файлах данных InnoDB, либо в файле журнала InnoDB. После того как MySQL будет запущен на восстановленном снимке, InnoDB инициирует процедуру восстановления точно так же, как в случае отключения питания сервера. Она найдет в журнале все зафиксированные транзакции, которые еще не попали в файлы данных, и применит их, поэтому потери транзакций не произойдет. 

##### Стандартный алгоритм

Необходимо просто скопировать данные (шаг 4 общего алгоритма):

bash# cp -a /var/lib/mysql/sakila /backup/sakila;

##### Снимки файловой системы

Снимки файловой системы очень удобны для создания согласованного образа содержимого, который затем можно использовать в качестве резервной копии. Снимки файловой системы поддержимаются. Снимки поддерживаются в Unix-системах, в том числе Ubuntu, через дополнительный пакет lvm2.

Принцип работы

Для создания снимка применяется технология копирования при записи (Copy-On-Write, COW). Вместо того чтобы копировать информацию в снимок, LVM лишь фиксирует момент снятия снимка. При чтении данных из снимка, они продолжают читаться из исходного местоположения. Если в данные по исходному местоположению вносятся изменения, то LVM копирует прежнее содержимое блоков в область, зарезервированную для снимка, и лишь затем вносит модификации.

Таким образом, снимок выполняется мгновенно и атомарно. Т.к. операция снятия снимка атомарна, вся информация на снимке согласована на момент снятия снимка.

Однако, снятие снимков LVM не бесплатно. Чем больше сервер пишет на исходный том, тем больше накладные расходы. Когда сервер модифицирует много блоков, расположенных в случайном порядке, головка диска должна постоянно перемещаться в зарезервированную для копирования область, чтобы записать туда старую версию данных. Чтение из снимка также сопряжено с издержками, так как большую часть информации LVM читает с исходного тома, а из зарезервированной области – только по необходимости. Таким образом, логически последовательное чтение из снимка на самом деле приводит к хаотичному перемещению головки.

Для того чтобы оценить количество места для снимка, нужно учесть:

·   количестве изменяемых и создаваемых блоков в секунду с помощью утилит vmstat или iostat

·   сколько времени потребуется держать снимок LVM открытым.

Пример команды создания снимка LVM. Размер места для копирования при записи – 16 Гбайт, имя снимка – backup_mysql: 

\# lvcreate —size 16G —snapshot —name backup_mysql /dev/vg/mysql

### Восстановление из резервной копии

#### Восстановление из физической резервной копии

Восстановление из физической резевной копии сводится к простому копированию файлов. 

Файлы MyISAM не зависят друг от друга, поэтому простого копирования файлов с расширениями .frm, .MYI и .MYD для каждой таблицы достаточно, даже на работающем сервере. Сервер найдет таб лицу, как только к ней поступит запрос

Для InnoDB все зависит от того, как размещены таблицы (настройка innodb_file_per_table): в одном табличном пространстве или каждая таблица в своем файле:

·   Если в одном табличном пространстве, то нужно остановить MySQL, скопировать или переместить файлы на место, а затем перезапустить сервер. 

·   Если каждая таблица размещена в отдельном файле с расширением .ibd, то такой файл содержит данные и индексы для каждой таблицы, т.е. что-то вроде комбинации MYI и MYD-файлов в подсистеме MyISAM. Восстановление из резервной копии выполняется простым копированием этих файлов, и делать это можно на работающем сервере, но не так просто, как в случае MyISAM. Отдельные файлы не являются независимыми от InnoDB в целом. В каждом IBD-файле записана информация, говорящая InnoDB о том, как этот файл связан с основным (общим) таб личным пространством. При возврате такого файла необходимо попросить InnoDB «импортировать» его с помощью специальной процедуры, описанной в документации.

Помимо ручного копирования файлов физической копии с таблицами InnoDB, процесс восстановления включает еще процедуру автоматического восстановления  самого движка InnoDB. При каждом запуске, MySQL проверяет файлы данных и журналов InnoDB, чтобы понять, нужно ли начинать процедуру восстановления. Такая процедура будет запущена при восстановлении из физической копии, точно так же, как в случае отключения питания сервера. Эта процедура найдет в журнале все зафиксированные транзакции, которые еще не попали в файлы данных, и применит их, а незафиксированные транзакции будут откачены.

В процессе восстановления необходимо следить за журналом ошибок MySQL:

tail -f /var/log/mysql/mysql.err

#### Восстановление из логической копии

Т.к. восстановление выполняется с участием MySQL сервера, желательно ускорить его работу, отключив некоторые функции:

- отключить запись в двоичный журнал


- в транзакционную InnoDB следует загружать данные порциями и фиксировать транзакцию после загрузки каждой из них. Иначе образуется огромный сегмент отката. 


##### Восстановление из SQL-дампа

1 вариант. Нужно подать SQL-дамп на `mysql`:

```bash
mysql < sakila-backup.sql
```

2 вариант. Можно также загрузить файл из клиента `mysql` командой `SOURCE`. При этом можно сделать нужные настройки в том же сеансе, например, отключить двоичный журнал:

```mysql
mysql> SET SQL_LOG_BIN = 0; 
mysql> SOURCE sakila-backup.sql; 
mysql> SET SQL_LOG_BIN = 1;
```

Если восстановление происходит из сжатого файла, то нужно после распаковки данные через *pipe* перенаправить на `mysql`:

```bash
gunzip -c sakila-backup.sql.gz | mysql
```

Если требуется загрузить данные только для одной таб лицы и INSERT занимает строку целиком без переносов,  то можно воспользоваться grep:

$ grep 'INSERT INTO `actor`' sakila-backup.sql | mysql sakila

для сжатого файла, требуется его предварительно разжать:

$ gunzip -c sakila-backup.sql.gz | grep 'INSERT INTO `actor`' | mysql sakila

Команды CREATE TABLE разбиты на несколько строк, поэтому их невозможно вытащить через grep. Нужно либо использовать более хитрые утилиты, либо редактировать файл вручную. 

Если часто требуется загружать отдельные таблицы, проще их сразу выгрузить в разные файлы, а еще лучше в отдельные файлы выгрузить CREATE TABLE.

##### Восстановление из файла с разделителями

Для загрузки используется команда LOAD DATA INFILE. Эту команду нужно запускать с теми же параметрами, чтобы были указаны при выгрузке в SELECT INTO OUTFILE. Можно также воспользоваться программой mysqlimport, которая является оберткой вокруг LOAD DATA INFILE и поддерживает многопоточную загрузку.

Для того чтобы загрузить данные из сжатого файла с разделителями потребуется вначале создать именованный канал и направить в него распакованные данные: 

$ mkfifo /tmp/backup/payment.fifo 
 $ chmod 666 /tmp/backup/payment.fifo 
 $ gunzip -c /tmp/backup/payment.txt.gz > /tmp/backup/payment.fifo

Для передачи распакованных данных в именнованный канал (файл payment.fifo) обязательно использовать знак '>', а не знак '|' для анонимных каналов. 

Канал ждет, пока какая-нибудь программа откроет его и начнет читать данные с другого конца. Сервер MySQL может получать распакованные данные из канала точно так же, как из обычного файла: 

mysql>   LOAD DATA INFILE '/tmp/backup/payment.fifo' 

​     INTO TABLE sakila.payment;

После загрузки данных именованный канал нужно удалить. 

Такой же прием может использоваться для загрузки сжатых файлов SQL-дампа через команду SOURCE.

#### Восстановление на конкретный момент времени

Если вдруг кто-то выполнил ошибочную команду, например:

DROP TABLE sakila.payment;

Нужно восстановиться на конкретный момент времени. Для этого необходимо:

·   восстановиться с резервной копии

·   воспроизвести двоичные журналы до нужного момента, для этого выполнить следующий алгоритм:

o  с помощью grep найти ошибочную команду в бинлоге и позицию этой команды в бинлоге и следующей за ней команды:

bash# mysqlbinlog --database=sakila /var/log/mysql/mysql-bin.000215 |

grep -B 3 -i 'drop table sakila.payment'

\# at 352

\#070919 16:11:23 server id 1 end_log_pos 429 Query thread_id=16 exec_time=0

error_code=0

SET TIMESTAMP=1190232683/*!*/;

DROP TABLE sakila.payment/*!*/;

o  Воспроизвести журнал с начала до позиции ошибочной команды (352), а потом воспроизвести журнал с позиции следующей команды (429) и до конца:

bash# mysqlbinlog —database=sakila /var/log/mysql/mysql-bin.000215 
 --stop-position=352 | mysql -uroot -p 
 bash# mysqlbinlog —database=sakila /var/log/mysql/mysql-bin.000215 
 --start-position=429 | mysql -uroot –p

#### Восстановление при настроенной отложенной репликации

Можно настроить подчиненный сервер, таким образом чтобы он воспрозводил команды из журнала ретрансляции с задержкой. Если ошибочная команда еще не была исполнена на подчиненном сервере, то можно ее пропустить следующим образом:

·   останавливаем подчиненный сервер

·   выполняем команду START SLAVE UNTIL, чтобы воспроизвести события до ошибочной команды.

·   выполняем команду CHANGE MASTER, чтобы сдвинуть вперед позицию, с которой подчиненный сервер читает журнал).

·   стартуем снова подчиенный сервер START SLAVE 

После того как на подчиненном сервер получена корректная версия база данных, делаем подчиненный сервер главным – и восстановление закончено,

## Управление пользователями

MySQL поддерживает задание привелегий для пользователей.

Рекомендуется следующий принцип (и он используется у нас) – создается пользователь под конкретный Web-проект с правами на БД этого проекта.

### Внутренняя организация

Информация о выданных привелений хранится в специальных таблицах  привилегий (grant  table). Это обычные таблицы типа MyISAM, находящиеся в базе данных mysql.

При проверке привилегий MySQL просматривает таблицы привилегий в порядке, показанном на схеме ниже. 

Обнаружив первое же соответствие, разрешающее искомую привилегию, сервер прекращает проверку. Например, если в таб лице db найдена запись, разрешающая запрошенный вид доступа, то таблицы tables_priv и columns_prev не просматриваются.

  

Перечень таблиц:

·   user – в каждой строке хранятся учетные данные пользователя (имя, местоположение и зашифрованный пароль) и его глобальные привилегии. Глобальные привилегии применяются ко всем базам данных на указанном сервере.

·   db – в каждой строке хранятся привилегии уровня базы данных для одного пользователя. Привилегии базы данных применяются ко всем таблицам указанной базы данных.

·   tables_priv – в каждой строке хранятся привилегии доступа одного пользователя к одной таблице. Привилегии таблицы применяются ко всем столбцам указанной таблицы.

·   columns_priv – в каждой строке хранятся привилегии доступа одного пользователя к одному столбцу.

Из такой схемы вытекают следующие особенности

·    В MySQL невозможно задать «явно запрещенные привилегии».

·   Группы пользователей не поддерживаются. 

### Структура имени пользователя

В MySQL учетная запись MySQL является составной 

'username'@'host'

где username— имя пользователя, a host— наименование хоста (имя компьютера, IP-адрес или маска адреса), с которого пользователю username разрешено обращаться к серверу MySQL

Для задания диапазона в имени хоста используется специальный символ %. Так, учетная запись 'wet'@'%’ разрешает пользователю 'wet' обращаться к серверу MySQL с любых компьютеров сети. Учетная запись 'wet'@'62.78.69.%.’ позволяет обращаться из целой подсети.

В качестве суперпользователя при установке MySQL создается пользователь 'root'@'localhost', который может получить доступ только с localhost.

Если адрес хоста не указан, то вместо имени хоста подставляется '%' (т.е. в примере ниже запрашиваются права пользователя 'root'@'%') :

mysql> SHOW GRANTS FOR 'root';

ERROR 1141: There is no such grant defined for user 'root' on host '%'

### Create user

Обычно вначале пользователь создается с помощью команды CREATE USER, а затем пользователю назначаются привелегии с помощью команды GRANT. Пароль пользователя назначается конструкций IDENTIFIED BY

CREATE USER 'username'@'localhost' IDENTIFIED BY 'password';

GRANT ALL PRIVELEGES ON db1.* TO 'jeffrey'@'localhost';

Можно обойтись без команды CREATE USER. Команда GRANT может автоматически создавать пользователь, если он не существует.

GRANT ALL PRIVELEGES ON db1.* TO 'username'@'localhost' IDENTIFIED BY 'password';

Затем при необходимости, изменить пароль можно с помощью следующей команды:

SET PASSWORD FOR 'username'@'localhost' = PASSWORD('password');

Если утерян пароль root, необходимо в конфигурационный файл my.cnf в секцию [mysqld] добавить директиву skip-grant-tables. В этом режиме сервер игнорирует таблицу привилегий и любой пользователь имеет полные привелегии. 

### GRANT

Команда осуществляет выдачу привелегий. 

GRANT (privileges) ON (objects) TO (user) [IDENTIFIED BY (password)];

#### Часто используемые привелегии

Привелегии указываются после слова GRANT. Может быть указано несколько привелегий через запятую.

Привилегии можно разделить на дву группы: 

·   глобальные привилегии – не ассоциированные с объектами. Например, SHOW DATABASES, SUPER.  Эти привелегии можно установить только на глобальном уровне.

·   привелегии по обработке каких-то объектов. Например, ALTER, SELECT. Эти привелегии можно установить на любом уровне.

| Привелегия                                                   | Значение                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| ALL [PRIVILEGES]                                             | Предоставить  все привилегии на указанном в команде уровне за исключением привилегии GRANT OPTION |
| ALTER                                                        | Разрешить ALTER TABLE                                        |
| CREATE                                                       | Разрешить создание  баз данных и таблиц                      |
| DELETE                                                       | Разрешить DELETE                                             |
| DROP                                                         | Разрешить  удаление баз данных, таблиц и представлений       |
| INDEX                                                        | Позволяет  работать с индексами, использовать операторы CREATE INDEX И DROP INDEX |
| INSERT                                                       | Разрешить INSERT                                             |
| SELECT                                                       | Разрешить SELECT                                             |
| SHOW DATABASES                                               | Разрешить SHOW DATABASES  для вывода списка баз данных       |
| SUPER                                                        | Разрешить использование  некоторых административных операций , например KILL. |
| UPDATE                                                       | Разрешить UPDATE                                             |
| USAGE                                                        | Отсутствие  привелегий                                       |
| задается как  отдельная опция:  GRANT` ``GRANT OPTION `ON...``  или с другими  опциями в конце команды:  GRANT ...  `WITH GRANT OPTION` | Разрешает  пользователю наделять других пользователей любыми привилегиями, которые он  сам владеет (т.е. выполнять GRANT и REVOKE). |

#### Уровень назначения привелегий

Уровень привелегий указывается после слова ON. 

| Ключевое слово ON                   | Уровень                                                      |
| ----------------------------------- | ------------------------------------------------------------ |
| ON *.*                              | Глобальный  уровень. На этом уровне устанавливаются глобальные привелегии, объектные  привелегии изменяют доступ ко всем базам данных и таблицам. |
| ON *                                | ·     Если текущая база данных не была выбрана при  помощи оператора USE, данное предложение эквивалентно ON *.*;  ·     если текущая база данных выбрана, то привелегии  устанавливаются для этой базы данных |
| ON db.*                             | Уровень базы  данных. Привилегии устанавливаются для  таблиц базы данных db. |
| ON db.tbl                           | Уровень  таблицы. Предложение устанваливаются на таблицу tbl базы данных db |
| GRANT privileges(columns) ON db.tbl | Уровень  столбца. Привилегии устанавливаются на конкретный столбец(ы) в таблице tbl базы данных  db. |

#### Примеры

Задание глобальных привелегий

Создание учетной записи администратора с полными правами:

GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY 'root' WITH GRANT OPTION;

Задание привелегий уровня базы данных

Создание учетной записи редактора определенной базы данных:

GRANT ALL PRIVILEGES ON test.* TO editor 

Задание привелегий уровня таблицы

Создание учетной записи с правами INSERT, UPDATE, на базу данных fishki, на таблицу fishki_user:

GRANT INSERT, UPDATE ON fishki.fishki_user TO 'tera'@'localhost' IDENTIFIED BY 'root';

Задание привелегий уровня столбца

Создание учетной записи с правами SELECT на некоторые столбцы таблицы fishki_user:

GRANT SELECT(usergroup, login) ON fishki.fishki_user TO 'tera'@'localhost' IDENTIFIED BY 'root';

Создание пользователя без привелегий

Создание пользователя без привелегий и без пароля, который может только подключаться к серверу:

GRANT USAGE ON *.* TO dummy@localhost;

Метасимволы '_' и '%'

В имени базы данных можно использовать метасимволы '_' и '%', имеющие тот же смысл, что и в операторе LIKE. При использовании в названии базы данных символов '_' и '%', их нужно экранировать (например '\_'). Если требуется выдать права на группу баз данных, то удобно в имя баз данных включить общий префикс, и при выдаче привилегий указать этот префикс с метасимволом '%':

GRANT SELECT ON `fishki\_%`.* TO 'tera'@'localhost';

### REVOKE

Удаление привелегий.

REVOKE (privileges) ON (objects) FROM (user);

Т.к. привелегии – это просто записи в служебных таблицах о правах на базы данных, таблицы, поля, отозвать можно только точно те привелегии, которые выдавались. Например, невозможно выдать привилегию на всю базу данных, а отозвать на какую-то одну таблицу:

GRANT SELECT ON `fishki`.* TO 'tera'@'localhost';

REVOKE SELECT ON `fishki`.fishki_user FROM 'tera'@'localhost';

ERROR 1147 (42000): There is no such grant defined for user 'tera' on host 'localhost' on table 'fishki_user'

Чтобы удалить у пользователя привелегию на какой-то объект (глобальные привилегии, на базу, на таблицу) необходимо указать ALL PRIVILEGES и объект:

REVOKE ALL PRIVILEGES ON `fishki`.* FROM 'tera'@'localhost';

При этом также можно отзывать привелегии только у тех объектов, на которые они выдавались. Например, нет команды, чтобы отзывать привилегии у всех таблиц внутри базы данных. Привилегии нужно удалять по одной, указывая в точности те таблицы, на которые привилегии выдавались.

Команда REVOKE не удаляет учетные записи. Для удаления учетной записи необходимо использовать команду DROP USER.

### SHOW GRANTS

Показать команду, которая воссоздает привилегии указанного пользователя.

По умолчанию выводятся привелегии текущего пользователя.

mysql> SHOW GRANTS;

+--------------------------------------------------------------------------------------------------+

| Grants for root@localhost                                    |

+--------------------------------------------------------------------------------------------------+

| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY PASSWORD '...' WITH GRANT OPTION |

+--------------------------------------------------------------------------------------------------+ 

Для просмотра привилегий другого пользователя необходимо указать его имя и адрес хоста.

mysql> SHOW GRANTS FOR 'root'@'localhost';

+------------------------------------------------------------------------+

| Grants for root@localhost                       |

+------------------------------------------------------------------------+

| GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' .. WITH GRANT OPTION |

+------------------------------------------------------------------------+

### Влияние привелегий на производительность

Следующие факторы снижают производительность обработки запросов:

·   Слишком много привилегий. Наличие очень большого количества записей в таб лицах привилегий приводит к ощутимым накладным расходам на их проверку.

·   Слишком детальные привилегии. Желательно определять привилегии на уровне пользователя, т.к. они наиболее дешевые в проверке. Если определены привилегии на уровне столбца, то MySQL вынуждена проверять каждый запрос по всей иерархии привилегий.

Прием: Если действительно пользователю нужны детальные привелегии, можно создать для этого пользователя отдельную базу данных и выдать пользователю привилегии на эту базу данных. А уже в эту базу данных поместить представления, которые обращаются к нужным полям в других базах данных:

GRANT SELECT ON views.* TO 'tera'@'localhost' IDENTIFIED BY 'root';

CREATE VIEW views.user AS SELECT login FROM fishki.fishki_user;

## Состояние сервера MySQL

Изучение состояния является основным способом мониторинга сервера MySQL.

Существует два варианта изучить состояние сервера:

- команды `SHOW XXX` – традиционный способ для MySQL


- системная база данных `INFORMATION_SCHEMA` (более новый вариант)


### System Variables

*System Variables* (системные переменные) – это различные конфигурационные параметры, которые настраивают работу сервера.

<u>Способы установки *System Variables*</u>:

- при запуске сервера в параметрах командной строки:

  ```bash
  mysqld --innodb_log_file_size=16M
  ```

- в конфигурационном файле `my.cnf`:

  ```apache
  [mysqld]
  innodb_log_file_size=16M
  ```

- во время выполнения с помощью команды `SET`. Команда `SET` используется также и для пользовательских переменных, однако пользовательские переменные начинаются с символа `@`:

  ```mysql
  SET [GLOBAL | PERSIST | SESSION] innodb_log_file_size=16M
  ```

  - `GLOBAL` – глобальная системная переменная
  - `SESSION` – сессионная системная переменная
  - `PERSIST` – глобальная системная переменная, сохраненная в файл

Способы вывода значения *System Variables*

- команда:

  ```mysql
  SHOW [GLOBAL | SESSION] VARIABLES [LIKE 'pattern']
  ```

- обратится к таблицам `INFORMATION_SCHEMA.global_variables` и `INFORMATION_SCHEMA.session_variables`.

[Документация к *System Variables*](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html) и [InnoDB System Variables](https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html)

### Переменные состояния

Переменные состояния сервера – это разные счетчики, которые содержат значение какой-то метрики. Счетчики чаще всего увеличиваются, когда MySQL выполняет некоторое действие (например, полное сканирование таблицы Select_scan). Некоторые метрики могут как увеличиваться, так и уменьшаться (например, количество открытых соединений [Threads_connected](https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html#statvar_Threads_connected)).

Для вывода списка списка переменных состояния сервера и их значений можно использовать команду MySQL. 

SHOW [GLOBAL | SESSION] STATUS

·   SESSION – значение по умолчанию. Отображение значений переменных состояния текущего соединения. Также отображаются глобальные переменные состояния, которые не имеют сессионных значений (относятся к серверу).

·   GLOBAL – отображение глобальных значений переменных состояния. Это либо переменные о состоянии самого сервера (например, Aborted_connects), либо агрегированное значение по все соединениям (например, Bytes_received)

Эти же данные можно считать из таблиц INFORMATION_SCHEMA.global_status и INFORMATION_SCHEMA.session_status.

Для мониторинга лучше всего отслеживать состояние этих переменных в течении какого-то времени. Также полезно находить значение   , чтобы узнать рост значения метрики в 1 секунду.

Ниже переменные состояния разбиты на группы.

#### Статистика потоков и соединений

·   Connections – количество попыток соединения (успешных и нет)

·   Max_used_connections – максимальное количество одновременно использованных подключений

·   Threads_connected – количество открытых соединений сейчас

·   Aborted_clients – количество некорректно закрытых клиентом соединений. 

·   Aborted_connects – количество неудачных попыток подключения к серверу. Если значение велико, то возможно проводится подбор пароля.

·   Bytes_received – количество полученных сервером байт

·   Bytes_sent – количество байт, отправленных сервером

·   Threads_cached – количество потоков в кеше потоков

·   Threads_created – количество созданных потоков с момента старта сервера.

·   Threads_running – количество потоков, которые не спят

#### Статистика binlog

Binlog_cache_use – количество транзакций было сохранено в кэше двоичного журнала

Binlog_cache_disk_use – количество транзакций, размер которых превысил размер кеша двоичного журнала  [binlog_cache_size](https://dev.mysql.com/doc/refman/8.0/en/replication-options-binary-log.html#sysvar_binlog_cache_size), и поэтому их пришлось записывать на диск.

Настройка: если значение Binlog_cache_disk_use – следует увеличивать размер кеша двоичного журнала до тех пор пока Binlog_cache_disk_use будет уменьшаться. Когда дальнейшее увеличение кеша не будет давать эффекта, следует прекратить увеличение кеша.



---

 

UNIQUE индекс служит двойной цели. Он работает точно так же, как и любой другой индекс, тем не менее, он также проверяет каждое значение при попытке вставить или обновить запись, чтобы гарантировать, что это значение еще не существует. Таким образом, UNIQUE индекс действует как ограничение.

В таблицах MyIsam нет разницы между первичным ключом и уникальным индексом. `NOT` `NULL` `UNIQUE` `INDEX` назван `PRIMARY. `Для таблиц InnoDB и BDB требуются первичные ключи для каждой таблицы. Они могут быть скрыто созданы самой СУБД.

 

 

Порядок столбцов в многоколоночном индексе в случае если по всем полям равенство не имеет значения от кардинальности столбцов.

## Настройки my.ini

### table_cache

 

table_cache старое название для переменной table_open_cache,Количество открытых таблиц для всех потоков Можете проверить, нужно ли вам увеличивать кеш таблицы, проверяя переменную состояния **Opened_tables**. Если значение **Opened_tables** велико, вы должны увеличить значение переменной table_open_cache. Увеличение этого значения увеличивает количество дескрипторов файлов, которые требуется mysqld. Нужно проверить, что количество открытых файлов разрешено не менее 4096 в переменной «open-files-limit» в разделе [mysqld_safe].  Советуют рассчитывать по формуле: количество одновременных соединений * количество открытых таблиц в соединении. Т.е. для каждого соединения используется свои ячейки из кэша.

table_cache (table_open_cache с версии 5.1.3) — количество кэшированных открытых таблиц для всех потоков. Открытие файла таблицы может быть достаточно ресурсоемкой операцией, поэтому лучше держать открытые таблицы в кэше. Следует учесть, что каждая запись в этом кэше использует системный дескриптор, поэтому возможно придется увеличивать ограничения на количество дескрипторов (ulimit). Значение по умолчанию 64, его лучше всего увеличить до общего количества таблиц, если их количество в допустимых рамках. Переменная состояния Opened_tables позволяет отслеживать число таблиц, открытых в обход кэша, желательно, чтобы ее значение было как можно ниже.

 

table_cache = 256

## Состояние сервера MySQL

### [`Переменные`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_table_open_cache) состояния

 

# Синтаксис

## Statements манипуляции данными

### `SELECT`

```mysql
SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr ...]
    [FROM table_references
      [PARTITION partition_list]
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}, ... [WITH ROLLUP]]
    [HAVING where_condition]
    [WINDOW window_name AS (window_spec)
        [, window_name AS (window_spec)] ...]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
    [INTO OUTFILE 'file_name'
        [CHARACTER SET charset_name]
        export_options
      | INTO DUMPFILE 'file_name'
      | INTO var_name [, var_name]]
    [FOR {UPDATE | SHARE} [OF tbl_name [, tbl_name] ...] [NOWAIT | SKIP LOCKED] 
      | LOCK IN SHARE MODE]]
```

#### Условия в `JOIN ON` и `WHERE`

Где располагать условие соединения - в `JOIN ON` или `WHERE`? Зависит от типа соединения:

* Для `INNER JOIN` – разницы нет. Оптимизатор скорее всего построит одинаковый план для любого варианта.

* Для `OUTER JOIN` – разница есть:

  * условие в `WHERE` выполняется *после* соединения. Таблицы вначале соединяются, а потом строки фильтруются по условию.

    ```mysql
    SELECT *
    FROM t1 LEFT JOIN t2 ON t1.id = t2.id
    WHERE t2.id = 1
    +--------+--------+
    | t1.id  | t2.id  |
    +--------+--------+
    | 1      | 1      |
    +--------+--------+
    ```

* условие в `JOIN ON` выполняется *до* соединения. При этом будут отфильтрованы только строки из правой таблицы, а строкам из левой таблицы может быть подставлен `NULL`.

  ```mysql
  SELECT *
  FROM t1 LEFT JOIN t2 ON t1.id = t2.id ON t2.id = 1
  +--------+--------+
  | t1.id  | t2.id  |
    +--------+--------+
    | 1      | 1      |
    | 2      | NULL   |
    +--------+--------+
  ```

Для удобства чтения запроса следует придерживаться правил:

* условие соединения помещается в `JOIN ON`
* условия фильтрации помещаются в `WHERE`.

#### `COUNT`

`COUNT` может применяться для подсчетов.

- Количество не `NULL` значений выражения `expr`

  ```mysql
  COUNT(expr)
  ```

  Если нет соответствующих строк, `COUNT()` возвращает 0.

  Например, найти все строки, где `id IS NOT NULL`

  ```mysql
  COUNT(id)
  ```

- Количество строк с *различными* не `NULL` значениями `expr`

  ```mysql
  COUNT(DISTINCT expr)
  ```

##### Подсчет количества строк в таблице

  Лучше всего использовать специальную форму:

  ```mysql
  COUNT(*)
  ```

которая вовсе не сводится к подстановке вместо метасимвола `*` полного списка столбцов таблицы, столбцы вообще игнорируются, а подсчитываются только строки.

Если MySQL точно знает, что выражение внутри скобок не может быть равно `NULL`, то также просто подсчитывает строки. Поэтому также можно использовать аналоги, вроде `COUNT(1)`, т.к. в скобках записана константа и значений `NULL` нет.

Одна из наиболее часто встречающихся ошибок – задание имени столбца в скобках, когда требуется подсчитать строки. Если нужно узнать, сколько строк в результирующем наборе, всегда употребляйте `COUNT(*)`. Тем самым вы избежите возможного падения производительности.

Для *MyISAM* `COUNT(*)` выполняется очень быстро, если 

- `SELECT` извлекает данные из одной таблицы
- никакие другие столбцы не извлекаются
- нет `WHERE`. 

```mysql
SELECT COUNT(*) FROM student;
```

Это возможно, потому что *MyISAM* хранит точное количество строк в таблице. *MyISAM* не обладает никакими магическими возможностями для другого подсчета строк, например если в запросе есть фраза `WHERE`.

Иногда оптимизацию `COUNT(*)` в *MyISAM* можно использовать, если требуется подсчитать все строки, кроме очень небольшого числа, т.е. заменить

```mysql
SELECT COUNT(*) FROM world.city WHERE ID > 5;
```

на

```
SELECT (SELECT COUNT(*) FROM world.city)- COUNT(*)
FROM world.City 
WHERE ID <= 5; 
```

В этом варианте читается меньше строк, поскольку на стадии оптимизации подзапрос преобразуется в константу: 

```
+----+-------------+-------+...+------+------------------------------+ 
| id | select_type | table |...| rows | Extra                        | 
+----+-------------+-------+...+------+------------------------------+ 
| 1  | PRIMARY     | City  |...| 6    | Using where; Using index     | 
| 2  | SUBQUERY    | NULL  |...| NULL | Select tables optimized away | 
+----+-------------+-------+...+------+------------------------------+
```

Для транзакционной InnoDB невозможно хранение точного количества строк, т.к. одновременно могут совершаться несколько транзакций, каждый из которых может влиять на количество. Если достаточно приблизительного количества строк, то можно использовать команду [SHOW TABLE STATUS](https://dev.mysql.com/doc/refman/5.7/en/show-table-status.html).

##### Оптимизация запросов с COUNT

Запросы, содержащие `COUNT()`, с трудом поддаются оптимизации, поскольку обычно они должны подсчитать много строк (то есть «прошерстить» большой объем данных). При таком запросе требуется поднять все данные в кеш (например, в `innodb_buffer_pool`), если они там не находятся.

Единственная возможность оптимизации внутри самого сервера MySQL – воспользоваться покрывающим индексом. 

Если этого недостаточно, рекомендуется внести изменения в архитектуру приложения. Например, самостоятельно реализовать счетчик количества строк и вручную этот счетчик изменять. Однако, такой счетчик может стать узким местом, если таблица активно изменяется. Счетчик может храниться:

- в сводной таблице в самой базе данных (пример – таблица `fishki_user_stat`).
- в *in-memory* кеше (например, *memcached*). 

Придется выбрать 2 из трех:

* быстро
* точно
* просто.

#### `HAVING`

Идет сразу после `GROUP BY`. Аналог `WHERE` для группированных полей.

#### Примеры

Допустим есть таблица user_group(user_id, group_id), которая связывает таблицы user и group. Необходимо найти количество уникальных групп, в которых состоят пользователи :user1 и :user2. При вычитании будет убрано то количество групп, которое встречалось в списке 2 раза.

SELECT

​     COUNT(`*group_id*`) - COUNT(DISTINCT `group_id`)

FROM

​     `user_group`

WHERE

​     `user_id` IN (:user1,:user2)

### `INSERT`

Возможны три формы синтаксиса:

```mysql
INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [(col_name [, col_name] ...)]
    {VALUES | VALUE} (value_list) [, (value_list)] ...
    [ON DUPLICATE KEY UPDATE assignment_list]

INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    SET assignment_list
    [ON DUPLICATE KEY UPDATE assignment_list]

INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]
    [INTO] tbl_name
    [PARTITION (partition_name [, partition_name] ...)]
    [(col_name [, col_name] ...)]
    SELECT ...
    [ON DUPLICATE KEY UPDATE assignment_list]

value:
    {expr | DEFAULT}

value_list:
    value [, value] ...

assignment:
    col_name = value

assignment_list:
    assignment [, assignment] ...
```

- `IGNORE` –  игнорировать ошибки, возникающие при выполнении, и не прерывать выполнение оператора. Например, при дублировании `UNIQUE` индекса строка просто пропускается.

### `UPDATE`

Возможно две формы синтаксиса:

- одно-табличный синтаксис:

  ```mysql
  UPDATE [LOW_PRIORITY] [IGNORE] table_reference
      SET assignment_list
      [WHERE where_condition]
      [ORDER BY ...]
      [LIMIT row_count]
  
  value:
      {expr | DEFAULT}
  
  assignment:
      col_name = value
  
  assignment_list:
      assignment [, assignment] ...
  ```

- много-табличный синтаксис:

  ```mysql
  UPDATE [LOW_PRIORITY] [IGNORE] table_references
      SET assignment_list
      [WHERE where_condition]
  ```

`value: DEFAULT` – использование значения по умолчанию для данного столбца. 

Если обновляются несколько столбцов и значение ранее обновленного столбца используются в последующих обновлениях, то используются уже новое значение, а не исходное. Например, здесь:

```mysql
UPDATE t1 SET col1 = col1 + 1, col2 = col1;
```

`col2=col1+1`, т.е. второе присваивание использует уже новое (обновленное) `col1` значение. Это поведение отличается от стандарта SQL.

Операторы

### Functions and operators

#### `GROUP_CONCAT`

Возвращает:

- строку с конкатенированными не `NULL` значениями из группы, 
- `NULL`, если все значения – `NULL`. 

Синтаксис:

```mysql
GROUP_CONCAT([DISTINCT] expr [,expr ...]
             [ORDER BY {unsigned_integer | col_name | expr}
                 [ASC | DESC] [,col_name ...]]
             [SEPARATOR str_val])
```

Простой пример:

```mysql
SELECT student_name, GROUP_CONCAT(test_score)
FROM student
GROUP BY student_name;
```

Пример с указанием сортировки значений `ORDER BY` и разделителя `SEPARATOR`:

```mysql
SELECT student_name,
       GROUP_CONCAT(DISTINCT test_score
                    ORDER BY test_score DESC SEPARATOR ' ')
FROM student
GROUP BY student_name
```

#### `IF`

```mysql
IF(expr1, expr2, expr3)
```

Возвращает:

- если `expr1=TRUE` ( `expr1 <> 0` и `expr1 <> NULL`) возвращает `expr2`
- иначе – возвращает `expr3`.

#### `CASE WHEN THEN`

- Первая форма:

  ```mysql
  CASE value
  	WHEN compare_value_1 THEN result_1
  	WHEN compare_value_2 THEN result_2
  	…
  	ELSE result 
  END
  ```

  Если `value == compare_value_X `, то возвращается соответствующий результат `result_X`.  Если value не соответствует ни одному compare_value, возвращает результат, указанный в ELSE предложении.

Вторая форма:

CASE

​     WHEN condition_1 THEN result_1

​     WHEN condition_2 THEN result_2

​     …

​     ELSE result 

END

Возвращает результат, соответствующий истинному condition. Если все условия ложны, то возвращается result из ELSE.

##### Примеры

\1.    Подсчет количества значений за один проход 

\2. Выполнить сортировку по полю state. Если значение поля state IS NULL использовать при сортировке значение поля country:

SELECT *

FROM customers

ORDER BY (

​     CASE

​          WHEN state IS NULL THEN country

​          ELSE state

​     END);

\3. Увеличить значение поля salary на 500, 1000 или 1500 в зависимости от значения в поле department. Классически это делает в три запроса, но можно свести в один запрос:

UPDATE worker SET salary = 

​     CASE dept

​          WHEN 'Sales'     THEN salary+1000

​          WHEN 'IT'        THEN salary+500

​          WHEN 'Marketing' THEN salary+500

​          ELSE salary 

​     END;

### Подзапросы с ANY, SOME, IN, ALL

operand comparison_operator (ANY | SOME) (subquery)

comparison_operator это один из следующих операторов

= > < >= <= <> !=

**SOME** (некоторая) и **ANY** (любая) являются синонимами, SOME более понятно при использовании с <>. Результатом подзапроса является один столбец величин (как для IN). Если хотя бы для одного значения из подзапроса сравнение дает **TRUE**, то результат **TRUE**. Можно реализовать через **EXISTS**.

Пример: найти комментарии, которые написаны позже любой из рассылок:

SELECT * FROM comment WHERE time > ANY (SELECT time FROM mailing)

IN это псевдоним для  = ANY. NOT IN это не псевдоним для <>ANY, а псевдоним для <>ALL.

### Работа с NULL

Для проверки на NULL необходимо использовать операторы IS NULL и IS NOT NULL.

mysql> SELECT 1 IS NULL, 1 IS NOT NULL;

+-----------+---------------+

| 1 IS NULL | 1 IS NOT NULL |

+-----------+---------------+

|         0 |             1 |

+-----------+---------------+

Для проверки на NULL нельзя использовать операторы сравнения (типа = или <>), т.к. в результат проверки всегда тоже NULL.

mysql> SELECT 1 = NULL, 1 <> NULL, 1 < NULL, 1 > NULL;

+----------+-----------+----------+----------+

| 1 = NULL | 1 <> NULL | 1 < NULL | 1 > NULL |

+----------+-----------+----------+----------+

|     NULL |      NULL |     NULL |     NULL |

+----------+-----------+----------+----------+

При GROUP BY два NULLзначения считаются равными.

**select** a, *sum*(b) **FROM** (
     **select NULL** a, 1 b
     **UNION ALL      select NULL**, 2
 ) t
 **group by** a 

+------+--------+

| a    | sum(b) |

+------+--------+

| NULL |      3 |

+------+--------+

При выполнении ORDER BY ... ASC NULLзначения будут идти первыми, при выполнении ORDER BY ... DESC – последними.

## Типичные задачи

### Подсчет количества значений за один проход

Если требуется с помощью одного запроса подсчитать, сколько раз встречаются несколько разных значений в одном столбце.

SELECT 

​     SUM(IF(color = ‘blue’, 1, 0)) AS blue, 

​     SUM(IF(color = ‘red’, 1, 0)) AS red 

FROM items;

Или, учитывает что COUNT не считает значения NULL

SELECT 

​     COUNT(color = ‘blue’ OR NULL) AS blue, 

​     COUNT(color = ‘red’ OR NULL) AS red 

FROM items;

можно также короткий вариант и группировка:

select month, sum(amount>100000) from sales group by month;

SUM возвращается для каждой строки TRUE или FALSE. Булево значение приводится к числу 1 и 0, т.к. SUM оперирует числами. 

Аналог через WHEN THEN

SELECT 

​     SUM(CASE

​          WHEN color = 'blue' THEN 1

​          ELSE 0

​     END) AS 'blue',

​     SUM(CASE

​          WHEN color = 'red' THEN 1

​          ELSE 0

​     END) AS 'red'

FROM

​     items;

Посчитать лайки отмодерированных и нет:

SELECT 

​     SUM(CASE WHEN moder = 1 THEN likes END) AS moder_likes, 

​     SUM(CASE WHEN moder = 0 THEN likes END) AS unmodern_likes 

FROM posts

;

### Условная логика при проходе по строкам

Необходимо использовать when-then.

#### Нахождение корня, внутренних узлов и листьев

Дана таблица с двумя столбцами: id – номер узла, p_id – номер родительского узла. Варианты решения от худших к лучшим

**1 вариант.** Использование подзапроса с IN

SELECT id,

case 

when p_id is null then 'root'

when id in (select p_id from tree) then 'inner'

else 'leaf'

end as str

from tree

**2 вариант.** Использование подзапроса с NOT EXISTS

SELECT id,

case 

when p_id is null then 'root'

when not exists (select * from tree r WHERE r.p_id=f.id) then 'leaf'

else 'inner'

end as str

from tree f

**3 вариант**. Использование left join с колонкой p_id

SELECT f.id,

case 

when f.p_id is null then 'root'

when r.p_id is null then 'leaf'

else 'inner'

end as str

from tree f left join (select distinct p_id from tree) r on r.p_id=f.id

Можно вывести имя родителя через подзапрос:

SELECT

​     CASE

​          WHEN tree.p_id = '0' THEN tree.p_id

​          ELSE (SELECT parent.name FROM tree parent WHERE parent.id = tree.p_id)

​     END AS parentName

FROM tree

### Подсчитать количество строк в InnoDB

 

 

IN может использоваться для сравнения конструкторов строк:

mysql> SELECT (3,4) IN ((1,2), (3,4));

​        -> 1

Удалить все дубликаты из таблицы за исключением одной строки

1) Если вы хотите сохранить строку с наименьшим id:

DELETE n1 FROM names n1, names n2 WHERE n1.id > n2.id AND n1.name = n2.name

2) Если вы хотите сохранить строку с наибольшим id:

DELETE n1 FROM names n1, names n2 WHERE n1.id < n2.id AND n1.name = n2.name

Гораздо быстрее через временную таблицу

INSERT INTO tempTableName(cellId,attributeId,entityRowId,value)

​    SELECT DISTINCT cellId,attributeId,entityRowId,value

​    FROM tableName;

Функция CASE

1 вариант

SELECT CASE 1 WHEN 1 THEN 'one' 

WHEN 2 THEN 'two' 

ELSE 'more' END; 

-> 'one' 

2 вариант

SELECT CASE WHEN 1>0 THEN 'true' 

ELSE 'false' END; 

-> 'true' 

mysql> SELECT CASE BINARY 'B' 

WHEN 'a' THEN 1 

WHEN 'b' THEN 2 END; 

-> NULL

Оператор IF

mysql> SELECT IF(1>2,2,3); 

-> 3 

mysql> SELECT IF(1<2,'yes','no'); 

-> 'yes' 

mysql> SELECT IF(STRCMP('test','test1'),'no','yes');

 -> 'no'

Оператор IFNULL

Если expr1 не NULL, IFNULL() возвращает expr1; в противном случае expr2.

mysql> SELECT IFNULL(1,0); 

-> 1 

mysql> SELECT IFNULL(NULL,10); 

-> 10 

mysql> SELECT IFNULL(1/0,10); 

-> 10 

BINARY *str* сокращение для CAST(*str* AS BINARY).

Оператор BINARY приводит строку после него к двоичной строке. Это простой способ вынудить сравнение быть выполненным байт в байт, а не символ в символ. BINARY также заставляет конечные пробелы быть значительными.

mysql> SELECT 'a' = 'A';

– > 1

mysql> SELECT BINARY 'a' = 'A';

– > 0

mysql> SELECT 'a' = 'a ';

– > 1

mysql> SELECT BINARY 'a' = 'a ';

– > 0

Запрос, получить количество значений в таблице больше или меньше текущего значения

Можно через коррелированный подзапрос, также можно его раскрыть через JOIN

SELECT t1.num_marks, 

​    (SELECT count(t2.couple_id) 

​    FROM table_name t2 

​    WHERE t2.num_marks >= t1.num_marks ) AS num_couples 

FROM table_name t1 

GROUP BY t1.num_marks 

ORDER BY t1.num_marks DESC;

### DELETE JOIN

Примеры

Удаление строк из двух таблиц t1и t2:

DELETE t1, t2

FROM t1

​     INNER JOIN t2 ON t1.key = t2.key

WHERE condition;

Удаление строк с id=1 в таблице t1 и строки с ref=1 в таблице t2:

DELETE t1 , t2 

FROM t1

​     INNER JOIN t2 ON t2.ref = t1.id

WHERE t1.id = 1;

Удаление строки из таблицы t1, не имеющих соответствующих строк в таблице t2:

DELETE t1

FROM t1

​     LEFT JOIN t2 ON t1.key = t2.key 

WHERE t2.key IS NULL;

### UPDATE JOIN

Синтаксис UPDATE с несколькими таблицами:

UPDATE [LOW_PRIORITY] [IGNORE] table_references

​    SET assignment_list

​    [WHERE where_condition]

В table_references указываются таблицы, участвующие в соединении. Могут использовать любые типы соединений, разрешенные в операторе SELECT, например LEFT JOIN. Обновляются только те таблицы и те таблицы, которые указаны в блоке SET.

Обновление двух таблиц:

UPDATE t1, t2

SET  t1.c2 = t2.c2,

​     T2.c3 = expr

WHERE T1.c1 = T2.c1 AND condition

Можно явно написать JOIN:

UPDATE T1,T2

​     INNER JOIN T2 ON T1.C1 = T2.C1

SET  T1.C2 = T2.C2,

​     T2.C3 = expr

WHERE condition

Обновление записей, которые не имеют соответствующих в другой таблице

UPDATE  t1 

​     LEFT JOIN t2 ON t1.id = t2.id

SET t1.col1 = newvalue

WHERE t2.id IS NULL

## Команды SHOW

### Show table status

Информация о таблице 

mysql> show table status like 'fishki_pg_data' \G;

*************************** 1. row ***************************

​           Name: fishki_pg_data

​         Engine: InnoDB  //подсистема

​        Version: 10

​     Row_format: Compact //формат строки, возможно dynamic, compressed

​           Rows: 40067 //число строк

 Avg_row_length: 170  //средняя длина строки в байтах

​    Data_length: 6832128 //объем данных в байтах

Max_data_length: 0 //макс объем данных

   Index_length: 77725696 //размер индексов

​      Data_free: 18304991232

 Auto_increment: 40001

​    Create_time: 2015-11-07 18:08:55

​    Update_time: NULL

​     Check_time: NULL

​      Collation: utf8_general_ci

​       Checksum: NULL

 Create_options:

​        Comment:

1 row in set (5.92 sec)

### Show engines

Доступные движки

​                                                  

### Show databases

Cписок названий всех доступных текущему пользователю баз данных. 

SHOW DATABASES [LIKE 'pattern']

mysql> SHOW DATABASES;

+--------------------+

| Database           |

+--------------------+

| information_schema |

| fishki_utf8        |

| newfishki          |

| test               |

+--------------------+

### Show tables

Список таблиц конкретной базы данных db_name.

SHOW TABLES [{FROM | IN} db_name] [LIKE 'pattern']

mysql> SHOW TABLES;

+----------------------------------+

| Tables_in_newfishki              |

+----------------------------------+

| fishki_account                   |

| fishki_admin_message             |

+----------------------------------+

### Show columns

Список полей таблицы

SHOW [FULL] COLUMNS {FROM | IN} tbl_name [{FROM | IN} db_name] [LIKE 'pattern']

или полные алиасы этой команды (без FULL)

SHOW FIELDS FROM tbl_name

 

DESCRIBE tbl_name

 

DESC tbl_name

 

mysql> SHOW COLUMNS FROM fishki_tag;

+--------------+------------------+------+-----+---------+----------------+

| Field        | Type             | Null | Key | Default | Extra          |

+--------------+------------------+------+-----+---------+----------------+

| id           | int(11)          | NO   | PRI | NULL    | auto_increment |

| post_id      | int(11)          | NO   | MUL | 0       |                |

| gallery_id   | int(11)          | NO   |     | NULL    |                |

| category_id  | int(11)          | NO   | MUL | 0       |                |

| tag_old      | varchar(100)     | YES  | MUL | NULL    |                |

| tag_id       | int(11) unsigned | NO   | MUL | NULL    |                |

| community_id | int(11)          | NO   | MUL | 0       |                |

+--------------+------------------+------+-----+---------+----------------+

 

