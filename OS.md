# `Memory

Программа использует следующие виды *memory*:

- область для загрузки *bytecode*
- *stack*
- *heap*



## Stack

https://gribblelab.org/teaching/CBootCamp/7_Memory_Stack_vs_Heap.html

*Stack* – это:

- область памяти, в которой хранятся временные (локальные) переменные, созданные каждой функцией (включая функцию `main()`)
- ипользуется для *static memory allocation*

Работает по принципу *stack*'а (LIFO). Вызов одной функции из другой функции помещает (*push*) в *stack* новый *frame*, который будет содержать *value*'s этой новой функции и так далее. Каждый раз, когда функция объявляет новую *variable*, она *pushed* в самый верхний блок *stack*'а. 

Когда функция завершается, ее *stack frame* (содержащий все *value*'s, помещенные (*pushed*) этой функцией в *stack*) удаляется. После освобождения этой части *stack*'а, память становится доступной для других переменных *stack*'а.

Особенности:

- *Multi-thread* приложения часто имеют *stack* для каждого *thread*'а.

- Типичными данными, которые хранятся в *stack*'е, являются:

  - *local variable*'s (*value*)
  - *pointer*'ы
  - *function frame*.

- при переполнении происходит *stack overflow error* (ошибка переполнения стека)

  

Преимущества использования *stack*'а:

- не нужно самостоятельно управлять памятью (не нужно вручную делать *allocate* и *free*), не нужно выполнять GC
- т.к. CPU эффективно управляет *stack memory*, чтение и запись переменных в *stack* происходит очень быстро.
- данные в *stack*'е доступны локально, в пределах *local scope*. 

Недостатки:

- любые данные, хранящиеся в *stack*'е, должны быть *finite* (ограниченный по размеру, размер данных известен во время компиляции) и *static*.

- существует ограничение (зависит от ОС) на размер переменных, которые могут быть размещены в *stack*'е.

- не поддерживает динамическое выделение памяти

- размер *stack*'а ограничен по сравнению с *heap* (который ограничен только размером *memory*)

  

  



TODO!!!

- https://deepu.tech/memory-management-in-programming/





## Heap

*Heap* - это:

- область памяти, которая не управляется автоматически
- используется для *dynamic memory allocation*
- в отличие от стека, программе необходимо искать данные в *heap* с помощью *pointer*'ов

Особенности:

- *Heap* шарится между *thread*'ами приложения (а также между *goroutine*'s приложения).
- при недостатке памяти возникает *out of memory* ошибка (может запустится GC).

В С++ память в *heap* выделяется явно с помощью `malloc()`. После выделения памяти, ее необходимо явно освободить с помощью `free()`. Иначе произойдет *memory leak* (утечка памяти). 

Когда программист определяет объект, который помещается в *heap*, выделяется необходимый объем *memory* и возвращается *pointer* на него. 

В отличие от *stack*'а, *variable*, созданная в *heap*, доступна любой функции в любом месте вашей программы. *Variable* в *heap* по сути глобальна по своему охвату.

*Heap* — это граф, где объекты– это *node*'s, а *pointer*'ы между объектами – ребра. На объекты в *heap* может ссылаться код или другие объекты в *heap*. 

![heap](img/heap.png)

Преимущества:

- динамическое выделение памяти
- В отличие от *stack*'а, *heap* не имеет ограничений размера (кроме очевидных физических ограничений вашего компьютера). 
- Как правило, нет ограничений на размер значения, которое может храниться в *heap*.

Недостатки:

- *heap* сложнее управлять из-за ее динамической природы. Справиться с этой сложностью помогают решения по автоматическому управлению памятью (GC).
- память *heap* немного медленнее для *read/write* потому что для доступа к памяти в *heap* необходимо использовать *pointer*'ы.

В *heap* помещаются:

- глобальные переменные
- *reference* типы (*object, string, map, ...*)

- 

## *Stack* и *heap* в Go

Место хранения variable (stack или heap) не влияет на семантику программы. Однако влияет на ее эффективность.

Когда это возможно, компилятор будет *allocate variable*, которая является локальной для *function* в *stack frame* этой *function*. Однако, если компилятор не может доказать, что на *variable* не остаются *reference* после возврата из *function*, компилятор должен *allocate variable* в *heap*. Кроме того, если *local variable* очень велика, может иметь смысл хранить ее в *heap*, а не в *stack*'е.

Если *local variable*, объявленная в функции, *allocate* в *heap*, мы можем сказать, что *variable escape* (убегает) в *heap*. Можно запустить `go build -gcflags -m`, чтобы увидеть, какие *local variable*'s будут *escape* в *heap* во время выполнения.

Некоторые факты:

- Если для *variable* извлекается адрес, то она обычно размещается в *heap*. Однако базовый *escape analysis* распознает некоторые случаи, когда такие *variable* не будут жить после возврата из функции и могут находиться в *stack*'е.
- если поле *struct value* – *escape* в *heap*, то *struct value* целиком – также *escape* в *heap*.
- ...
- *variable*, созданная через вызов `new()`, может быть *allocate* в *heap* или *stack* (в отличии от C++, там всегда в *heap*????).





https://medium.com/eureka-engineering/understanding-allocations-in-go-stack-heap-memory-9a2631b5035d

https://stackoverflow.com/questions/10866195/stack-vs-heap-allocation-of-structs-in-go-and-how-they-relate-to-garbage-collec

https://segment.com/blog/allocation-efficiency-in-high-performance-go-services/

https://stackoverflow.com/questions/28484976/storing-a-pointer-to-a-stack-value-golang

https://stackoverflow.com/questions/38234487/returning-a-pointer-on-stack

