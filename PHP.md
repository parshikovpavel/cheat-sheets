# Общая характеристика языка

- *stateless* по умолчанию. Это очень удобно, когда растущий проект перестает помещаться на один сервер. В этом случае [в]() PHP мы гарантировано не завязаны на взаимодействие потоков на одном сервер, на хранение данных в локальной памяти.

- низкий порог вхождения.  Удобен для набора команд, которые зачастую состоят из *junior* и *middle*.

## PECL

*PECL* (транск. 'pickle', PEAR Extension Code Library) это:

-  репозиторий компилируемых расширений самого интерпретатора PHP. 
- консольная утилита `pecl`, которая поставляется в одной папке с PHP

*PECL*  создан, чтобы упростить установку расширений, которые вынесены из стандартной поставки PHP. Расширения представлены в форме модулей *С* , которые подключаются к машине PHP. Поскольку расширение представляют собой программы на языке *С* , то как правило выполняются быстрее и более эффективно по сравнению с расширениями на *PHP*.

Установка расширения:

```bash
pecl install <extension_name>
```

Узнать каталог где PECL хранит *extension*'ы, чтобы прописать  `extension_dir` в `php.ini`

```bash
pecl config-get ext_dir
```

Какие-то ошибки исправляет:

```bash
mkdir -p /tmp/pear/cache
```

## PEAR

*PEAR* - это предшественник *Composer* для добавления библиотек PHP.

Устарел, вместо него используются *Composer* и *packagist*.

## Xdebug

### Установка

- `pecl install xdebug`

  Автоматически в `php.ini` добавляются строки:

  ```
  zend_extension="xdebug.so"
  extension_dir = "/usr/local/lib/php/pecl/20190902"
  ```

  Путь к расширению `/usr/local/Cellar/php/7.4.2/pecl/20190902/xdebug.so'`

- 

## PHP.ini

### Местоположение

В *Ubuntu* используется несколько конфигурационных файлов `php.ini`:

- `/etc/php7/cli/php.ini` — конфигурационный файл консольной утилиты `php`;

- ` /etc/php7/apache2/php.ini` — конфигурационный файл для модуля РНР встроенного в Apache;

- `/etc/php7/fpm/php.ini` — конфигурационный файл для PHP-FPM , используемый *nginx*.

Расположение для *Mac*:

- `/usr/local/etc/php/<version>/php.ini`

Узнать местоположение используемого файла можно в отчете с настройками. Отчет можно получить через:

- в коде `phpinfo()`


- в консоли:

  ```bash
  php -i
  ```

### `memory_limit` 

максимальное количество оперативной памяти, которое может быть выделено скрипту. ВАЖНО!!! Это не лимит оперативной памяти выделяемой для всего PHP.

### `max_execution_time`

Максимальное время в секундах, в течение которого скрипт должен полностью загрузиться. Если этого не происходит, парсер завершает работу скрипта с `Fatal Error`. По умолчанию на загрузку дается 30 секунд. Если PHP запущен из командной строки, это значение по умолчанию равно `0`.

## Ключи в режиме командной строки

**Все параметры** **php**

php -h

Запуск встроенного в php веб-сервера

php -S localhost:8000

Если в конце указать PHP-файл, то он рассматривается как скрипт "маршрутизации". Скрипт выполняется в самом начале после каждого HTTP-запроса. Если этот скрипт возвращает FALSE, то запрашиваемый ресурс возвращается как есть. В противном случае браузеру будет возвращен вывод этого скрипта.

Для запуска на 80 порту нужен sudo. По умолчанию текущая папка является корневой для сервера.

Версия PHP

```bash
php -v
```

Вызвать `phpinfo()` и вывести его результат.

```bash
php -i
```

Вывод подключенных модулей

```bash
php -m
```

Вывод всех загруженных конфигурационных файлов

```bash
$ php --ini
Configuration File (php.ini) Path: /usr/local/etc/php/7.4
Loaded Configuration File:         /usr/local/etc/php/7.4/php.ini
Scan for additional .ini files in: /usr/local/etc/php/7.4/conf.d
Additional .ini files parsed:      /usr/local/etc/php/7.4/conf.d/ext-opcache.ini
```



## Синтаксис

При выводе больших блоков текста выход из режима синтаксического разбора PHP обычно более эффективен, чем отправка текста с помощью функций `echo` или `print`. Для обрамления кода допускаются только теги `<?php ?>` и `<?= ?>`.

Закрывающий тег блока PHP-кода автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с PHP-кодом. 

```php
<?php echo 'Это тест' ?>
```

PHP поддерживает комментарии в стиле 'C', 'C++' и оболочки *Unix* (стиль *Perl*). 

```php
echo "Последний тест"; # Это комментарий в стиле оболочки Unix
```

## Ключевые слова

### `static`

Используется в следующих конструкциях:

- [`static` переменные](#static-переменные)
- [`static`  свойства и методы классов](#static-свойства-и-методы)
- [позднее статическое связывание](#позднее-статическое-связывание)

## Типы

### Список типов

PHP поддерживает десять простых типов.

**Четыре скалярных типа:**

- `boolean`

- `integer`

- `float` (иногда называется `double`)

- `string`

**Четыре смешанных типа:**

- `array`

- `object`

- `callable`

- `iterable`

**Два специальных типа**:

- `resource`

- `null`

### Определение типа переменной

Тип переменной определяется динамически во время выполнения программы в зависимости от контекста использования. Проверка типа возможна следующими способами:

- `var_dump()`

- `gettype()`

```php
$a_bool = TRUE;   // логический
$a_str  = "foo";  // строковый

echo gettype($a_bool); // выводит: boolean
echo gettype($a_str);  // выводит: string
```

- группа функций, вроде `is_int()`, `is_string()`, `is_bool()`


### Перечень типов

#### `bool`

Для определения переменной типа `boolean` необходимо использовать константы `true` или `false`. Обе они регистронезависимы, т.е. можно и так:

```php
$foo = True; 
```

При преобразовании в `bool`, следующие значения рассматриваются как `false`:

- само значение `bool(false)`

- `int(0)`
- `float(0.0)`
- `string("")` и `string("0")`
- `array([])`
- `null`
- объекты `SimpleXML`, созданные из пустых тегов


Все остальные значения рассматриваются как `true` (включая любой `resource` и `nan`).

```php
var_dump((bool)"false");   // bool(true)
```

#### `int`

Для записи в восьмеричной системе счисления, необходимо поставить перед числом `0`. 

```php
$a = 0123;
```

Для записи в шестнадцатеричной системе счисления, необходимо поставить перед числом `0x`. 

```php
$a = 0x1A;
```

Для записи в двоичной системе счисления, необходимо поставить перед числом `0b` 

```php
$a = 0b11111111;
```

Целые числа в PHP всегда со знаком, PHP не поддерживает беззнаковые целые. Размер `int` зависит от платформы: 

- для 32-битной платформы максимальное значение 2<sup>31</sup>-1
- для 64-битной платформы 2<sup>63</sup>-1

Константы:

- `PHP_INT_SIZE` – размер `int` в байтах (как правило 8)
- `PHP_INT_MAX` – максимальное значение `int`
- `PHP_INT_MIN` – минимальное значение.

Если PHP обнаружил, что число превышает размер типа `int` или что в результате операции получается такое число, он будет интерпретировать его в качестве `float`:

```php
$large_number = 9223372036854775808;
var_dump($large_number);                     // float(9.2233720368548E+18)

$million = 1000000;
$large_number =  50000000000000 * $million;
var_dump($large_number);                     // float(5.0E+19)
```

##### Деление

Алгоритм оператора `/`:

- если деление выполняется нацело, то результат `int`
- если нет – `float`. 

```php
var_dump(25/5); # int(5)
var_dump(25/7); # float(3.5714285714286)
```

##### Приведение к `int`

Если привести значение к `int`, оно будет округлено вниз, то есть будет отброшена дробная часть числа. Если оператор или функция требуют `int`, то значение будет автоматически преобразовано в `int`.

```php
var_dump((int)false); // int(0)
var_dump((int)true);  // int(1)
var_dump((int)25.3);  // int(25), округление в меньшую сторону
var_dump((int)fopen('index.php','r')); // int(3), где 3 - это resource_id
```

Можно использовать функции `floor` (в меньшую сторону) и `ceil` ( в большую).

оператор целочисленного деления `intdiv(10,3)=3`



#### `float`

Числа с плавающей точкой могут быть определены следующими синтаксисами:

```php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
```

В PHP обычно используется формат двойной точности. Рациональные числа, например, `0.1` или `0.7`, не имеют точного внутреннего представления в качестве чисел с плавающей точкой с основанием `2`, вне зависимости от размера мантиссы.  Поэтому они и не могут быть преобразованы в их внутреннюю двоичную форму без небольшой потери точности. Это может привести к неожиданным результатам: например, `floor((0.1+0.7)*10)` скорее всего вернет `7` вместо ожидаемого `8`, так как результат внутреннего представления будет чем-то вроде `7.9999999999999991118....`

##### Разделитель числовых литералов

В числовых литералах (*numeric literal*) – числа с типом `int` и `float` , может использоваться символ подчеркивания `_` для визуального разделения групп цифр. Символ `_` может использоваться в любых формах записи *numeric literal*'ов.

Единственное требование – символ `_` может стоять только между двумя цифрами.

Это верные записи *numeric literal*'ов:

```php
1_000_000_000;  
107_925_284.88; 
135_00;
6.674_083e-11;
0xCAFE_F00D;
```

Это ошибочные записи:

```php
100_;
1_.0;
```



#### `NAN`

Некоторые числовые операции могут возвращать значение, представляемое константой `NAN` (*Not A Number*, не-число). Например, `sqrt(-1)`, `asin(2)` и `acosh(0)`.

Данный результат означает неопределенное или непредставимое значение в операциях с плавающей точкой. 

<u>Сравнение</u>

Так как `NAN` представляет собой неограниченное количество различных значений, то `NAN` не следует сравнивать с другими значениями, включая ее саму. Вместо этого, для определения ее наличия необходимо использовать функцию `is_nan()`.

Особенности сравнения:

- `NAN == true` и `NAN === true`
- во всех остальных случаях `false`, включая `NAN != NAN` и `NAN !== NAN`

```php
$nan = acos(8);

var_dump($nan);         # float(NAN)
var_dump($nan==TRUE);   # bool(true)
var_dump($nan==NAN);    # bool(false)
var_dump(is_nan($nan)); # bool(true)
```

#### `string`

В PHP строки, по умолчанию, рассматриваются как набор символов, каждый из которых – 1 байт. Т.е. PHP стандартно поддерживает 256 символов, и не поддерживает *Unicode*.

##### Способы записи

###### Deprecated

До PHP 7.1 можно было (но не рекомендовалось) записывать строки вообще без кавычек и каких-либо символов:

```php
$str = foo;

var_dump($str);  # string(3) "foo"

                 # C PHP 7.1:
                 # PHP Notice:  Use of undefined constant
```

Строка интерпретируется как константа, и, т.к. она не определена, по умолчанию возвращается ее имя в качестве значения. 

Начиная с PHP 7.1 генерируется предупреждение.

###### Одинарные кавычки

Специальные символы:

- `\'` – одинарная кавычка

- `\\` – обратный слеш

Во всех остальных случаях, обратный слеш `\` – обычный символ, например, `\r` и `\n` выводятся как есть.

Особенности:

- переменные не разворачиваются


- допускается запись в несколько строк

  ```php
  echo 'Вы можете вставлять в строки
  символ новой строки вот так,
  это нормально';
  
  // Выводит: Переменные $expand также $either не разворачиваются
  echo 'Переменные $expand также $either не разворачиваются';
  ```

###### Двойные кавычки

В двойных кавычках PHP распознает следующие специальные символы:

Поправить

| **Последовательность**                      | **Значение**                                                 |
| ------------------------------------------- | ------------------------------------------------------------ |
| `\n`                                        | новая строка                                                 |
| `\r`                                        | возврат   каретки                                            |
| `\t`                                        | горизонтальная   табуляция (HT или 0x09 (9) в ASCII)         |
| `\v`                                        | вертикальная   табуляция (VT или 0x0B (11) в ASCII) (с PHP 5.2.5) |
| `\e`                                        | escape-знак   (ESC или 0x1B (27) в ASCII) (с PHP 5.4.4)      |
| `\f`                                        | подача   страницы (FF или 0x0C (12) в ASCII) (с PHP 5.2.5)   |
| `\\`                                        | обратная   косая черта                                       |
| `\$`                                        | знак доллара                                                 |
| `\"`                                        | двойная   кавычка                                            |
| `\[0-7]{1,3}`                               | последовательность   символов, соответствующая регулярному выражению символа в восьмеричной   системе счисления, который молча переполняется, чтобы поместиться в байт   (т.е. "\400" === "\000") |
| `\x[0-9A-Fa-f]{1,2}`                        | последовательность   символов, соответствующая регулярному выражению символа в шестнадцатеричной   системе счисления |
| `\u{[0-9A-Fa-f]+}`   Например,   `\u{00BC}` | Символ Unicode, задаваемый своим кодом                       |

###### Heredoc

Структура:

- `<<<` + некоторый *identifier* + перевод строки 
- Сам текст
- На отдельной строке тот же самый *identifier* + `;`. Строка *должна* начинаться с закрывающего *identifier*'а, т.е. он должен стоять в первом столбце строки. Cтрока с закрывающим *identifier*'ом' не должна содержать других символов, за исключением точки с запятой `;`. Это означает, что *identifier* не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Первым символом перед закрывающим *identifier*'ом должен быть символ новой строки. Если это правило нарушено и закрывающий *identifier* не является "чистым", считается, что закрывающий *identifier* отсутствует и PHP продолжит его поиск дальше.

*Identifier* должен соответствовать тем же правилам именования, что и все остальные метки в PHP: 

- содержать только буквенно-цифровые символы и знак подчеркивания
- не должен начинаться с цифры (знак подчеркивания разрешается). 

```php
$bar = <<<EOT
bar
EOT;
```

С PHP7.3 ослаблены требования к структуре закрывающего *identifier*'а, прежде всего чтобы добавить отступы для улучшения читабельности кода. Особенности:

- закрывающий *identifier* может иметь отступ, и в этом случае:
  - отступ может быть сделан или пробелами или табами. Но не одновременно тем и другим.
  - точное количество пробелов/табов, используемых перед закрывающим  *identifier*'ом будет удалено из каждой строки
  - после закрывающего *identifier*'а может стоять `,` и продолжаться выражение.

```php
$foo = ['foo', 'bar', <<<EOT  
  baz  
   -  hello world! --  
  ahoy  
  EOT, 'qux', 'quux'  
];
```



*Heredoc-текст* ведет себя так же, как и строка в двойных кавычках, при этом их не имея.

Возможно использовать heredoc-синтаксис для передачи данных через аргументы функции.

```php
var_dump(array(<<<EOD
foobar!
EOD
));
```

Возможна инициализация статических переменных и свойств/констант класса с помощью синтаксиса *Heredoc*. 

```php
class ClassName
{
    const NAME = <<<STR
...
STR;

    public $property = <<<STR
...
STR;
}
```

Можно также окружать идентификатор *Heredoc* двойными кавычками.

###### Nowdoc

*Nowdoc* для строк в одинарных кавычках то же, что и *Heredoc* для строк в двойных кавычках. *Nowdoc* похож на *Heredoc*, но внутри него не осуществляется никаких подстановок. *Nowdoc* указывается той же последовательностью `<<<`, что используется в *Heredoc*, но последующий за ней идентификатор заключается в одинарные кавычки, например, `<<<'EOT'`. 

```php
$str = <<<'EOD'
EOD;
```

##### Обработка переменных

Если строка указывается в двойных кавычках, либо при помощи *Heredoc*, переменные внутри нее обрабатываются. Если интерпретатор встречает знак доллара `$`, он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. 

```php
$string = 'string';
echo "Символ с индексом -2 равен $string[-2].", PHP_EOL;

// Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределенная константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает
echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает $object->getName(): {${$object->getName()}}";
echo "{$foo->bar}\n";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";

```

С помощью этого синтаксиса также возможен доступ к свойствам объекта внутри строк.

```php
<?php
class foo {
  var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";  		# I am bar.
echo "{$foo->{$baz[1]}}\n";		# I am bar.
?>
```

##### Доступ к символу

К символу в строке следует обращаться с использование квадратных скобок `$str[42]`. Начиная с PHP7.4, доступ к символу через фигурные скобки `$str{42}` – *deprecated*. 

Поддерживаются отрицательные значения смещения – они задают смещение с конца строки. 

```php
"abcdef"[-2]
$string[-1]
```

Доступ к символу через `[]` – означает доступ к соответствующему байту строки. Поэтому:

- его корректно выполнять только для однобайтовых кодировок. 
- для многобайтовых кодировок (*UTF8*) он работает некорректно. 

Попытка записи в смещение за границами строки дополнит строку пробелами до этого смещения. При использовании в качестве смещения `float`, оно будет преобразовано в `int`. Смещение в строке должно задаваться либо `int`, либо `string`, содержащей цифры, иначе будет выдаваться предупреждение. 

При присвоении символу строки, используется только первый символ присваиваемой строки. 

##### Преобразование в строку

- `bool` – значение `true` преобразуется в строку `"1"`, а значение `false` преобразуется в `""` (пустую строку). Это позволяет преобразовывать значения в обе стороны - из булева типа в строковый и наоборот.

- `null` – преобразуется в `""` (пустую строку).

##### Преобразования строк в числа

Если строка не содержит какой-либо из символов `'.'`, `'e'` или `'E'`, и значение числа помещается в пределы целых чисел (определенных `PHP_INT_MAX`), строка будет распознана как целое число `int`. Во всех остальных случаях она считается числом с плавающей точкой `float`.

Значение определяется по начальной части строки. Если строка начинается с верного числового значения, будет использовано это значение. Иначе значением будет `0 `. Верное числовое значение – это одна или более цифр (могущих содержать десятичную точку), по желанию предваренных знаком, с последующим необязательным показателем степени. Показатель степени - это `'e'` или `'E'` с последующими одной или более цифрами.

```php
$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
```

Начиная с PHP 7.1, выдается предупреждение, если строка не содержит полностью корректное число.

##### Преобразования символа в число

Над символами нельзя выполнять арифметические операции, как в C. 

```php
var_dump('b' - 'a'); # int(0) + Warning: A non-numeric value encountered 
```

Получить код ASCII символа:

```php
ord ( string $string ) : int
```

Получить ASCII символ по коду:

```php
chr ( int $bytevalue ) : string
```





##### Реализация

Строковый тип `string` в PHP реализован в виде массива байт и целого числа, содержащего длину буфера. Поэтому функция `strlen()` имеет временную сложность `O(1)`. Найти длину конкатенированной строки быстрее, сложив длины отдельных строк и не получая саму конкатенированную строку:

```php
# Вместо
$len = strlen($a.$b);
# гораздо быстрее
$len = strlen($a)+strlen($b);
```

Данная природа строкового типа объясняет почему в PHP нет отдельного типа `byte` – строки играют эту роль. Функции, возвращающие нетекстовые данные – например, произвольный поток данных, считываемый из сетевого сокета, – на самом деле возвращают строки. 

Способ кодирования строки определяется тем, как она записана в файле скрипта. Например, строка `"á"` эквивалентна `"\xE1"` (ISO-8859-1), `"\xC3\xA1"` (UTF-8, форма нормализации C), "\x61\xCC\x81" (UTF-8, форма нормализации D). Написание корректных программ, работающих с *Unicode*, означает осторожное избегание функций, которые не работают с *Unicode* и, скорее всего, испортят данные, и использование вместо них корректных функций, обычно из расширений `intl` и `mbstring`.

#### `array`

Ключи массива могут иметь тип `array` или `string`.

При удалении элемента из середины массива ключи не пересчитываются.

При использовании в качестве ключей следующих типов выполняется преобразование:

- `string`, содержащее целое число (исключая случаи, когда число предваряется знаком `+`) будут преобразованы к типу `int`


- `float` будет преобразован к типу `int`, т.е. дробная часть будет отброшена. 
- `bool` будет преобразован к `int` (`0`  или `1`)
- `null` будет преобразован к пустой строке `""`. 
- `array` и `object` не могут использоваться в качестве ключей. 

```php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d", # В `$array` попадет только этот ключ
); 

```

Если при объявлении массива повторяется индекс, то более позднее значение переписывает более раннее.

Ключ для элемента массива не является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа `int`, увеличенное на 1.

```php
$array = array(
    "a",
    "b",
    6 => "c",
    "d",      # Ключ – 7
); 

```

Вместо квадратных скобок можно использовать фигурные: (т.е. и `$array[42]` и `$array{42}` равнозначны).

Если к переменной, тип которой не `string` или `array`, обратиться как к массиву с помощью `[]`, то будет возвращен `null` без какого либо оповещения об ошибке:

```php
$a = 123;
var_dump($a[1]); # null
```

Можно объявить массив прямо так:

```php
$arr[] = value;
```

Если элементы удаляются из массива, то максимальный номер ключа – тот который существовал когда-то. Например:

```php
$a[5] = 1;
unset($a[5]);
$a[] = 1;
var_dump($a); # array( [6] => 1 )
```

Внутри строки в двойных кавычках `"..."` можно не заключать индекс массива в одинарные кавычки

```php
"Fruit: {$a['fruit']}";  # OK
"Fruit: $a['fruit']":    # Error
"Fruit: $a[fruit]";      # OK
```



##### Преобразование `object` к `array`

При преобразовании `object` к `array`:

- ключами становятся свойства объекта
- к `private` свойствам спереди будет дописано имя класса, к `protected` свойствам спереди будет добавлен символ `*`. Эти добавленные значения с обоих сторон заключаются в нулевые байты.
- значения массива – значения свойств объекта

```php
class A {
    private $A; // Ключ - '\0A\0A'
}

class B extends A {
    private $A; // Ключ - '\0B\0A'
    public $AA; // Ключ - 'AA'
}
```

##### Присваивание по ссылке

При присваивании массива всегда происходит копирование значения. Чтобы скопировать массив по ссылке, нужно использовать оператор ссылки `&`.

##### Сложение массивов

###### Оператор `+`

Оператор `+` возвращает левый массив, к которому был присоединен правый массив. Для ключей, которые существуют в обоих массивах, будут использованы значения из левого массива, а соответствующие им элементы из правого массива будут проигнорированы. Обработка одинаковая и для числовых и для строковых ключей, никакие ключи не перенумеровываются.

```php
$a = ["a" => "apple", "b" => "banana"];
$b = ["a" => "pear", "b" => "strawberry", "c" => "cherry"];

var_dump($a + $b); # array(3) {
                   #.          ["a"] => string(5) "apple"
                   #           ["b"] => string(6) "banana"
                   #           ["c"] => string(6) "cherry"
                   # }
```

###### Функция `array_merge`

```php
array array_merge ( array $array1 [, array $... ] ))
```

Поведение:

-  `string` ключ – ключ и значение переносятся в результат. Если ключи совпадают в нескольких массивах, то каждое последующее значение заменяет предыдущее. 
- `int`  ключ – только значение переносится в результат. В качестве ключей для этих значений будут использованы числа, начиная с нуля. Т.е. `int` ключи не сохраняются вообще.

```php
$a = [5 => 'a'];
$b = [6 => 'c'];

var_dump(array_merge($a, $b)); # array(2) {
                               #    [0] => string(1) "a"
                               #    [1] => string(1) "c"
                               # }

```

###### Unpacking `iterable` внутри `array`

С PHP7.4 сложение `array` и `iterable` (в том числе `array`)  можно реализовать через *unpacking* `iterable` внутри  `array` с использованием многоточия `...` (*spread operator*) (также используется в [1](список-аргументов-переменной-длины))

```php
$array = ['b', 'c'];

var_dump(['a', ...$array, 'd']); # array(4) {
                                 #   [0] => string(1) "a"
                                 #   [1] => string(1) "b"
                                 #   [2] => string(1) "c"
                                 #   [3] => string(1) "d"
                                 # }
```

Можно делать *unpacking* несколько раз:

```php
$arr = [1, 2];
$array = [1, 2];

var_dump([...$array, ...$array]); # array(4) {
                                 #   [0] => int(1)
                                 #   [1] => int(2)
                                 #   [2] => int(1)
                                 #   [3] => int(2)
                                 # }
```

Обработка ключей из `iterable`, для которого выполняет *unpacking*:

- `string` ключи не поддерживаются. Если встречается `string` ключ, выбрасывается `Fatal error`.

  ```php
  $array = ['str' => 'c'];
  [1 => 'a', 'key' => 'b', ...$array]; # Error!
  ```

- `int` ключи игнорируются, переносится только значение. Ключ как будто не указан, поэтому будет взято предыдущее наибольшее значение ключа типа `int`, увеличенное на `1`, `2`,...

  ```php
  $array = [100 => 'c'];
  var_dump([1 => 'a', 'key' => 'b', ...$array]); # array(3) {
                                                 #  [1]   => string(1) "a"
                                                 #  'key' => string(1) "b"
                                                 #  [2]   => string(1) "c"
                                                 # }
  ```

  

Можно делать *unpacking* `iterable` значения, возвращаемого функцией:

```php
function generator() {
	for($i = 0; $i < 2; $i++) {
        yield $i;
    }
}
var_dump([...generator()]); # array(2) {
                            #   [0] => int(0)
                            #   [1] => int(1)
                            # }
```

*Unpacking* `iterable` *by reference* не работает.

```php
[...&$array];  # Error!
```

Преимущества сложения массивов через *spread operator* `...`  над сложением через `array_merge()`:

- сложение через *spread operator* `...`  работает быстрее, чем `array_merge()`, т.к. *spread operator* `...` – языковая конструкция, а `array_merge()` – функция.

- *spread operator* поддерживает любой `iterable`, а *array_merge()* только `array`. В `array_merge()` нужно при необходимости вначале привести `iterable` к `array`:

  ```php
  [ ...$iter1, ...$iter2 ]
  
  # аналогично
  array_merge(iterator_to_array($iter1), iterator_to_array($iter2))
  ```

  

##### Конструкции `list` и `[]`

Конструкции аналогичны, используются для того, чтобы присвоить списку переменных значения за одну операцию. Выполняют т.н. симметричную деструктуризацию массива.

```php
# Получение всех (или несколько первых) элементов массива
list($a, $b, $c) = $array;
[$a, $b, $c] = $array;

# Получение некоторых первых элементов массива
list($a, , $c) = $array;
[$a, , $c] = $array;

list(, , $c) = $array;
[, , $c] = $array;
```

Может использоваться с `foreach`:

```php
foreach ($array as list($a, $b)) 
    /* ... */
}

foreach ($array as [$a, $b]) 
    /* ... */
}
```

Поддерживаются ключи в операторе `list()` и в коротком синтаксисе `[]`. Это позволяет деструктурировать массивы со строковыми и непоследовательными числовыми ключами.

```php
list('a' => $a, 'b' => $b) = $array;
['a' => $a, 'b' => $b] = $array;

# с foreach
foreach ($array as list('a' => $a, 'b' => $b)) 
    /* ... */
}

foreach ($array as ['a' => $a, 'b' => $b]) 
    /* ... */
}
```

C PHP7.3 поддерживается присвоение по ссылке:

```php
list($a, &$b) = $array;
[$a, &$b] = $array;
```



#### `iterable`

К этому смешанному типу относятся:

```
iterable ---> array
          --> Traversable ---> Iterator
                           --> IteratorAggregate
                           --> Generator
```

Хотя `object` допускает `foreach` по `public`  свойствам, он не входит в `iterable`. 

`iterable` итерируется с помощью `foreach` и может быть использован с `yield from` в генераторах.

При использовании в параметрах функции значение по умолчанию может быть `array` типа или `null`:

```php
function foo(iterable $iterable = []) {}
function foo(iterable $iterable = null) {}
```

Использование в качестве типа возвращаемого значения:

```php
function bar(): iterable {
    return [1, 2, 3];
}
function gen(): iterable {
    yield 1;
    yield 2;
    yield 3;
}
```

Для `iterable` реализован [LSP](), т.е. дочерние классы:

- могут «расширять» тип параметра метода с `array` или `Traversable` до `iterable`
- могут «сужать» тип возвращаемого значения с `iterable` до `array` или `Traversable`.

#### `object`



#### `callable`

##### Способы создания callable

1. Анонимная функция ([подробнее](#анонимные-функции)). PHP автоматически преобразует анонимные функции в экземпляры внутреннего класса `Closure`. 

   ```php
   $closure = function() {};
   
   var_dump(is_object($closure));  # true
   var_dump($closure);             # object(Closure)#1 (0) {}
   ```

2. `string`. 

   1. `'functionName'`. 

      В этом случае интерпретатор будет искать обычную, неанонимную функцию с именем, совпадающим с данной строкой и, в случае успеха, вызовет такую функцию. Есть ряд ограничений — нельзя вызвать `isset()`, `empty()` и другие функции, которые фактически являются конструкциями языка. Важная особенность — скобки списка аргументов в таком случае не пишутся!

      Интересно, что функция `create_function()` создает именованную функцию с именем вроде `lambda_1` и возвращает ее имя. И вызов такой функции выполняет аналогично через `string`.

      ```php
      function func() {}
      
      $str = 'func';
      
      $str();
      ```

   2. `'ClassName::method'`

      Используется для вызова статических методов. 

      ```php
      class A {
          static function b() {}
      }
      
      $str = 'A::b';
      
      $str();
      ```

   3. Строки вида:

      - `'parent::method'`–  вызов метода в родительском классе
      - ` ‘self::method'` – вызов метода в том же классе
      -  `'static::method'` – вызов метода через позднее статическое связывание.

      Вызовы этих `callable` не работают через простой синтаксис `$str()`, а работают только через специальную функцию `call_user_func()`. Эта функция позволяет делать вызовы как в статическом контексте (через класс), так и в динамическом (через объект):

      ```php
      class A {
          static function name() {
              return 'A';
          }
      
          static function fSelf() {
              return call_user_func('self::name');
          }
      
          static function fStatic() {
              return call_user_func('static::name');
          }
      
      }
      
      class B extends A {
          static function name() {
              return 'B';
          }
      }
      
      $b = new B;
      
      # 1. parent::name
      #    1.1. Статический вызов
      var_dump(call_user_func(['B', 'parent::name'])); # string(1) "A"
      
      #    1.2. Динамический вызов
      var_dump(call_user_func([$b, 'parent::name'])); # string(1) "A"
      
      # 2. self::name
      var_dump(call_user_func(['B', 'fSelf'])); # string(1) "A"
      
      # 3. static::name
      var_dump(call_user_func(['B', 'fStatic'])); # string(1) "B"
      
      # Вызов через простой синтаксис
      $str = ['B', 'parent::name'];
      var_dump($str()); # PHP Fatal error:  Uncaught Error: Call to undefined method B::parent::f()
      ```

3. `array`. 

   Структура массива:

   ```
   [
   	0 => имя класса,
   	1 => имя статического метода
   ]
   ```

   или

   ```
   [
   	0 => объект,
   	1 => имя статического / динамического метода
   ]
   ```

   Доступ к `protected` и `private` методам разрешен изнутри класса.

   ```php
   class A {
       static function b() {}
   }
   
   $a = new A;
   
   $arr1 = ['A', 'b'];
   $arr2 = [$a, 'b'];
   
   $arr1();
   $arr2();
   ```

4. `object`. 

   Чтобы `object` был `callable` необходимо определить в классе магический метод `__invoke()`:

   ```php
   class A {
       public function __invoke($val) {
           return $val*2;
       }
   }
   
   var_dump((new A)(2)); # int(4)
   ```

##### Способы обращения к функции через `callable`

Подробнее и примеры в [Порядок обработки непрямого доступа](#порядок-обработки-непрямого-доступа)

Возможны два способа обращения к функции через `callable`:

1. Сохранить `callable` в переменную.

2. Не сохранять `callable` в переменную, а вызвать его напрямую 


https://stackoverflow.com/questions/7067536/how-to-call-a-closure-that-is-a-class-variable

https://wiki.php.net/rfc/uniform_variable_syntax

##### Функция `is_callable()`

Функция `is_callable()` проверяет — принадлежит ли переданное ей значение `callable` типу.

Если в классе `Foo` определен метод `__call()` или `__callStatic()`, то `is_callable($foo, 'bar')` или `is_callable(‘Foo’, 'bar')` всегда будет `true`. 

## Манипуляции с типами

Допускаются следующие приведения типов:

- `(int)`, `(integer)`, аналог – функция `intval()`

- `(bool)`, `(boolean)` – приведение к `bool`

- `(float)`, `(double)`, `(real)` – приведение к `float`

- `(string)`

- `(array)`

- `(object)`

## Переменные

Имя переменной чувствительно к регистру. 

По ссылке могут быть присвоены только именованные переменные. 

```php
$bar = &(24 * 7);  # Неверно; 
$bar = &test();    # Неверно.
```

Хорошей практикой считается инициализировать переменные, хотя в PHP это и не является обязательным требованием. Неинициализированные переменные принимают значение в соответствии с контекстом их первого использования: 

- `bool` – значение `false`
- `int` и `float` – `0`
- `string`  (например, при использовании в echo) – `""`
- `array` – `[]`

```php
var_dump($unset_var);                       # NULL
echo($unset_bool ? "true\n" : "false\n");   # false
$unset_int += 25;                           # 0 + 25 => 25
$unset_str .= 'abc';                        # ''.'abc' => 'abc'
$unset_arr[3] = "def";                      # [] + [3 => "def"] => [3 => "def"]
$unset_obj->foo = 'bar';            # object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
```

Существует только 2 *scope*'s': *local* и *global*.

### Global scope

Глобальные переменные автоматически недоступны в локальной области видимости. Это отличается от языка C, где глобальные переменные автоматически доступны функциям, если только они не были перезаписаны локальным определением:

```php
a = 1; # глобальная область видимости

function test()
{
    echo $a; # выведет пустую строку, переменная неинициализирована
}

test();
```

Фактически, можно рассматривать глобальные переменные как элементы массива `$GLOBALS`. Т.е. `$GLOBALS['variable']` – это непосредственно сама глобальная переменная `$variable`, а не ссылка на нее.

Способы доступа к глобальным переменным:

- создать ссылку на глобальную переменную в локальной области видимости:

  ```php
  global $var;
  ```

  эта конструкция равнозначна:

  ```php
  $var = &$GLOBALS["var"];
  ```

- использовать массив `$GLOBALS`

  ```php
  $GLOBALS['var']
  ```

### Local scope

Только тело `function` формирует *local scope*. Видимость переменных, объявленных внутри `function`, ограничена телом этой `function`. 

Это отличается от *Java* и *C*. Т.к. переменные, объявленные внутри тела циклов (`for`, `while`...), и условных операторов `if` будут доступны за пределами этого блока: 

```php
function func() 
{
  for (...) {
    if(...) {
      $a = 4;  
    }
  }
    
  var_dump($a); # int(4)    
}
```

### `static` переменные

Статическая переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости.

Статические переменные вычисляются во время компиляции скрипта и должны содержать выражения, которые могут быть вычислены в этот момент. Поэтому статические переменные нельзя инициализировать значением функции:

```php
static $int = 0;          # OK
static $int = 1+2;        # OK
static $int = sqrt(121);  # Error  (поскольку это функция)
```

Non-`static` методы в PHP существуют в контексте классов, а не объектов. И только лишь в рантайме происходит подстановка `$this = текущий_объект`. Поэтому статическая локальная переменная существует в единственном экземпляре:

```php
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

$a1 = new A;
$a2 = new A;

$a1->foo(); // 1
$a2->foo(); // 2
$a1->foo(); // 3
$a2->foo(); // 4
```

Наследование класса (и метода) приводит к тому, что всё-таки создается новый метод:

```php
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

class B extends A {
}

$a1 = new A;
$b1 = new B;

$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2

```

### Ссылки на `global` и `static` переменные

PHP использует определяет `static` и `global` переменные как ссылки. 

Ссылки на глобальные переменные, внедренные через `global`, и `static` переменные являются ссылками на исходные переменные и при присвоении им ссылок, они не изменяются. Они просто указывают на структуру zval и естественно при присвоении им другой ссылки, они начинают указывать на другую структуру ([подробнее](#присваивание-ссылке-ссылки)).

```php
function test_global_ref() {
    global $var;
    $local = 1;
    $var = &$local;
}

function test_global_noref() {
    global $var;
    $var = 1;
}

test_global_ref();
var_dump($var);         # NULL
test_global_noref();
var_dump($var);         # int(1)
```

Т.к. элементы массива `$GLOBALS` – это не ссылки, при присвоении им ссылок, глобальные переменные меняться будут:

```php
function test_global_ref() {
    global $var;
    $local = 1;
    $GLOBALS['var'] = &$local;
}

test_global_ref();

var_dump($var);         # int(1)
```

### Переменные переменных

Создание переменной `$a` и переменной переменной `$hello`:

```php
$a = 'hello';
$$a = 'world';
```

При обращении к переменной переменной в индексе массива необходимо разрешить неоднозначность:

```php
${$a[1]};
${$a}[1];
```

Возможно составление имени свойства через фигурные скобки:

```php
$start = 'b';
$end   = 'ar';
echo $foo->{$start . $end} . "\n";
```

### Переменные при POST запросе

Если в форме присутствуют поля, `name` которых содержит точки `.` или пробелы ` `:

```html
<input name="a.b" />
```

при получении POST запроса PHP преобразует их в знак подчеркивания `_`. 

Значение поля из примера будет доступно через `$_REQUEST['a_b']`.

## Константы

Принято писать имена констант в верхнем регистре `CONSTANT_NAME`

Константу можно определить:

- с помощью функции `define()`

  ```php
  define(string $name, mixed $value);
  define('CONSTANT_NAME', 1);    
  ```

  Такое объявление может находиться в любом месте скрипта.

- с помощью ключевого слова `const`

  ```php
  const CONSTANT_NAME = 1;
  ```

  Такое объявление должно быть размещено в самой верхней области видимости, потому что оно вычисляется при компилировании скрипта.

После того, как константа определена, ее значение не может быть изменено или аннулировано.

Как и суперглобальные массивы, константы доступны в любой области видимости. 

Функции для работы с константами:

- Определить значение константы по имени:

  ```php
  mixed constant(string $name) 
  ```

- Проверить, объявлена константа или нет:

  ```php
  defined(string $name): bool
  ```

В качестве значения константы можно задать:

- скалярное значение:

  ```php
  const CONSTANT = '123';
  ```

- `array`:

  ```php
  const CONSTANT = [1, 2];
  ```

- скалярные выражения:

  ```php
  const CONST_2 = CONST_1 . '123';
  ```

Константы регистрозависимы.

### Магические константы

Есть 9 магических констант, значение которых зависит от места, где они размещены.

| Имя                  | Описание                                                  |
| -------------------- | --------------------------------------------------------- |
| `__LINE__`           | Номер строки в файле                                      |
| `__FILE__`           | Полный путь к текущему файлу                              |
| `__DIR__`            | Директория текущего файла                                 |
| `__FUNCTION__`       | Имя функции                                               |
| `__CLASS__`          | Имя класса, включая пространство имен `ppFinal/ClassName` |
| `__TRAIT__`          | Имя треста, включая пространство имен                     |
| `__METHOD__`         | Имя метода класса                                         |
| `__NAMESPACE__`      | Текущее пространство имен                                 |
| `<ClassName>::class` | Имя класса, включая пространство имен                     |

Магические константы разрешаются во время компиляции.

## Операторы

### Приоритет и ассоциативность оператора

Ассоциативность оператора определяет порядок выполнения операторов с одинаковым приоритетом. Различают:

- лево-ассоциативные операторы – выполняются слева-направо. Например, оператор `-`, поэтому `1 - 2 - 3` сгруппируется как `(1 - 2) – 3`
- право-ассоциативные операторы – выполняются справа-налево. Например, оператор `=`, поэтому `$a = $b = $c` сгруппируется как `$a = ($b = $c)`.
- неассоциативный операторы – если в выражении несколько таких операторов имеют одинаковый приоритет, то выражение выдает ошибку. Например, `1 < 2 > 1` не будет работать, `(1 < 2) > 1` – будет. 

| Оператор       | Ассоциативность | Тип оператора                         |
| -------------- | --------------- | ------------------------------------- |
| `+` `-`  `.`   | левая           | арифметические, строковый             |
| `<<` `>>`      | левая           | побитовые                             |
| `.`            | левая           | строковые                             |
| `??`           | правая          | *null coalescing*                     |
| `?:`           | левая           | тернарный                             |
|                |                 |                                       |
|                |                 |                                       |
|                |                 |                                       |
| `fn () => ...` | правая          | arrow function ([1](#arrow-function)) |



С PHP7.4  оператор конкатенации `. ` имеет приоритет ниже, чем `+`, `-`, желательно использовать скобки для явного указания приоритета:

```php
var_dump( 'a' . 1 + 2 . 'b' ); # string(2) "a3b" 
var_dump( 'a' . (1 + 2) . 'b' ); # string(2) "a3b" 
```

### Порядок обработки непрямого доступа

Непрямой доступ – доступ через другое выражение.

Сложные выражения с непрямым доступом к переменным, свойствам и методам, начиная с PHP7, раскрываются строго слева-направо. Примеры в таблице ниже:

| Выражение             | Интерпретация   PHP 7   |
| --------------------- | ----------------------- |
| `$$foo['bar']['baz']` | `($$foo)['bar']['baz']` |
| `$foo->$bar['baz']`   | `($foo->$bar)['baz']`   |
| `$foo->$bar['baz']()` | `($foo->$bar)['baz']()` |
| `Foo::$bar['baz']()`  | `(Foo::$bar)['baz']()`  |

При этом, начиная с PHP7 допустимы следующие операции над любыми сложными выражениями:

```php
(...)['foo'] # Обращение к элементу массива
(...)->foo   # Доступ к свойству объекта 
(...)->foo() # Доступ к методу объекта
(...)::$foo  # Доступ к статическому свойству объекта
(...)::foo() # Доступ к статическому методу объекта
(...)()      # Вызов callable
(...){}      # Обращение к символу строки
```

Допустимы все приведенные ниже примеры. Они также раскрываются строго слева-направо:

```php
# Поддерживаются цепочки вызовов функций, обращений к элементам массивов,
# вызовов callable, обращений к символам строк и т.д.
$foo()['bar']()
[$obj1, $obj2][0]->prop
getStr(){0}

# поддерживаются цепочки из операторов ::
# для доступа к статическим членам класса
$foo['bar']::$baz
$foo::$bar::$baz
$foo->bar()::baz()

# поддерживаются цепочки вызовов функций ()
# каждая конструкция должна возвращаться callable
foo()()
$foo->bar()()
Foo::bar()()
$foo()()

# Вызов анонимной функции после ее определения
(function() { ... })()

# Вызов анонимной функции, сохраненной в свойстве объекта
($obj->closure)()

# вызов различных типов callable напрямую
[$obj, 'method']()
['Classname', 'method']()
$object->$methodName();    
    
# Обращение к статическим элементам класса    
'Foo'::$bar
```


### Арифметические операторы

- `+$a` (оператор индентичность) – конвертация `$a` в `int` или `float`, что более подходит:

  ```php
  $a = '123';
  var_dump(+$a); # int(123)
  ```

- `$a ** $b` – возведение `$a` в степень `$b`

- `$a / $b` (деление). Возвращает результат типа:

  - `int` – оба значения являются целыми числами (или строками, которые преобразуются в целые числа), которые делятся нацело
  - `float` – для всех остальных случаев

  Для гарантированного целочисленного деления необходимо использовать `intdiv()`.

- `$a % $b` (деление по модулю) – оба операнда преобразуются в целые числа путем удаления дробной части до начала операции. 

    ```php
    var_dump( 5.1 % 2.3 ); # int(1)
    ```

#### Побитовые операторы

- `$a & $b` – И

- `$a | $b` – ИЛИ

- `$a ^ $b` – Исключающее ИЛИ

  Особенности операторов  `&`, `|` и `^`:

  - если оба операнда `string`, то операция будет производиться с кодами ASCII всех символов строки и в результате вернет строку. 
  - во всех остальных случаях, оба операнда будут преобразованы к целому и результатом будет целое число.

  Пример:

  ```php
  echo 12 ^ 9;     // Выводит '5'
  
  echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                   // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8
  
  echo "hallo" ^ "hello"; // Выводит ascii значения #0 #4 #0 #0 #0
                          // 'a' ^ 'e' = #4
  
  echo 2 ^ "3"; // Выводит 1
                // 2 ^ ((int)"3") == 1
  
  echo "2" ^ 3; // Выводит 1
                // ((int)"2") ^ 3 == 1
  ```

- `~$a` – отрицание.

  Особенности:

  - Если операнд `string`, то операция будет производиться с кодами ASCII всех символов строки и в результате вернет строку
  - в остальных случаях операнд будет считать целым,  и результат будут целыми.

- `$a << $b` – сдвиг влево.

  Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа влево, что означает что знак операнда не сохраняется.

  ```
  Выражение: 4 << 29 = -2147483648
   Десятичный вид:
    val=4
    res=-2147483648
   Двоичный вид:
    val=00000000000000000000000000000100
    res=10000000000000000000000000000000
   ЗАМЕЧАНИЕ: знаковый бит не был сохранен
  ```

- `$a >> $b` – сдвиг вправо.

  Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает что знак операнда сохраняется.

  ```
  Выражение: -4 >> 1 = -2
   Десятичный вид:
    val=-4
    res=-2
   Двоичный вид:
    val=11111111111111111111111111111100
    res=11111111111111111111111111111110
   ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита
  ```

  Оба операнда и результат выполнения `<<` и ` >>` всегда считаются за целое.

#### Операторы сравнения

| Пример                    | Название                         | Результат                                                    |
| ------------------------- | -------------------------------- | ------------------------------------------------------------ |
| `$a == $b`                | Равно                            | `true`, если `$a` равно `$b` после преобразования типов.     |
| `$a != $b` или `$a <> $b` | Не равно                         | `true`, если `$a` не равно `$b` после преобразования типов.  |
| `$a === $b`               | Тождественно   равно             | `true`, если `$a` равно `$b` и имеет тот же тип.             |
| `$a <=> $b`               | Спейсшип   (космический корабль) | Число типа `integer` меньше, больше или равное нулю, когда `$a` соответственно меньше, больше или равно `$b`. Доступно PHP 7. |

##### Операторы `==` и `===`

При проверке равенства двух переменных, для которых предполагается один и тот же тип и не требуется никаких преобразований, нужно использовать обязательно операторы `===` и `!==`. Операторы `===` и `!==` не выполняют никаких преобразований типов. Также операторы `===` и `!==` работают быстрее, чем `==` и `!=` и функции (вроде `strcmp()`).

При сравнении оператором `==` возможно преобразование одного (или обоих) операндов к другому типу. Сравнение происходит в соответствии со следующей таблицей (по порядку).

| Тип операнда 1                                         | Тип операнда 2                                         | Результат                                                    |
| ------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| `null` или `string`                                    | `string`                                               | `null` преобразуется в `""`,   числовое или лексическое сравнение |
| `bool` или `null`                                      | что угодно                                             | Все операнды преобразуется в `bool`, `null` → `false`. При сравнении `false < true` |
| `object`                                               | `object`                                               | [Сравнение `object`](#сравнение-object)                      |
| `string` (содержащее число), `resource`   или `number` | `string` (содержащее число), `resource`   или `number` | Все переводится в `number` и выполняется численное сравнение. Подробнее ниже. |
| `array`                                                | `array`                                                | [Сравнение `array`](#сравнение-array)                        |
| `array`                                                | что угодно                                             | `array` всегда больше                                        |
| `object`                                               | что угодно                                             | `object` всегда больше                                       |

##### Сравнение `string`

При сравнении оператором `== `  операндов `number` с `string` (или два `string`), содержащие числа, каждая `string` будет преобразована в `number`, и сравниваться они будут как `number`. Эти правила также распространяются на оператор `switch`. 

```php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true
switch ("a") {
    case 0:
        echo "0";
        break;
    case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
        echo "a";
        break;
}

```

При использовании операторов `===` и `!==`  преобразование типов не происходит, а также проверяется соответствие типов.

При проверке равенства двух строк (если предполагается что они содержат только символы и не требуется преобразований) нужно использовать обязательно операторы `===` и `!==`. Также они работают быстрее, чем `==` и `!=` и функции (вроде `strcmp()`).

При сравнении `string` оператор `==` (если не было преобразования `string` в другой тип) и `===` делают побайтовое сравнение переменных. Поэтому операторы `==` и `===` выполняют *case sensitive* сравнение. 

##### Сравнение `bool` и `null`

Пример сравнения `bool` и `null` с другими типами:

```php
var_dump(1 == TRUE);  // TRUE - то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 это FALSE < TRUE
```

##### Сравнение `float`

Т.к. `float` – число с плавающей запятой, не нужно проверять на равенство два `float`-числа. Подробнее см. [float]().

##### Другие сравнения

Если происходит обращение к несуществующей переменной или несуществующему элементу массива, то вместо него подставляется `null` и выводится `Notice`:

```php
$a = [];
var_dump($a[1] != 2); # bool(true) + Notice
var_dump($a[1] == false); # bool(true) + Notice
```

[Сравнение `NAN`](#nan)

#### Тернарный оператор `?:`

<u>Полная форма</u>

```php
(expr1) ? (expr2) : (expr3) # если `expr1 == true`, то `expr2`, иначе `expr3`
```

В отличии от большинства языков программирования тернарный оператор в PHP является *left-associative*. Вложенная полная форма тернарного оператора может использоваться только с круглыми скобками `()`, явно указывающими приоритет:

```php
$a === $b ? 1 : ($a === $c ? 2 : 3) # OK
$a === $b ? 1 : ($a === $c ? 2 : 3) # Error
```

<u>Короткая форма</u>

```php
(expr1) ?: (expr3)          # если `expr1 == true`, то `expr1`, иначе `expr3`
```

Из короткой формы `?:` можно строить цепочки, возвращается первое значение, которое приводится к `true`:

```php
var_dump(0 ?: 0 ?: 2 ?: 3); # int(2) 
```


#### *Null coalescing operator* `??`

Оператор `??` (объединение с *null*, *null coalescing*) является синтаксическим сахаром:

```php
$a ?? $b;             # то же самое
isset($a) ? $a : $b;
```

Можно строить цепочки, возвращается первое значение, которое не `null`:

```php
var_dump(null ?? null ?? 1 ?? 2); # int(1) 
```

#### Null Coalescing Assignment Operator `??=`

Оператор `??=` (присваивающий оператор объединения с *null*) – синтаксический сахар:

```php
$a ??= $b;

# то же самое, что
# 1.
$a = $a ?? $b;

# или
# 2.
if (!isset($a)) {
    $a = $b;
}
# else - ничего не делается
```



#### Spaceship operator `<=>`

```php
$a <=> $b;
```

Алгоритм:

- если `$a > $b` – вернет `1`
- если `$a < $b` – вернет `-1`
- иначе, если `$a == $b` – вернет `0`

Сравнивать можно любые типы, например:

```php
# int
var_dump(1 <=> 2); # int(-1)

# float
var_dump(1.5 <=> 2.5); # int(-1)

# string
var_dump("a" <=> "b"); # int(-1)

# array
echo [] <=> [1,2,3]; # int(-1)

# object
var_dump((object) ["a" => 1] <=> (object) ["a" => 2]); # int(-1)
```

#### Сравнение `array`

<u>Операторы `==`, `<`, `>`</u>

`$a == $b` – `true`, если `$a` и `$b` содержат одни и те же пары ключ/значение.

Алгоритм:

- Если в первом `array` меньше элементов, возвращается `-1` (`$a < $b`), иначе `1` (`$a > $b`). 
- Если число элементов в `array`'s одинаковое, то сравниваются значения соответствующих ключей в порядке ключей первого `array`:
  - Если ключ из первого `array` не найден во втором – возвращается `null`
  - Если ключ в первом `array` меньше, возвращается `-1` (`$a < $b`), иначе `1` (`$a > $b`).

```php
if (count($op1) < count($op2)) {
    return -1; // $op1 < $op2
} elseif (count($op1) > count($op2)) {
    return 1; // $op1 > $op2
}
foreach ($op1 as $key => $val) {
    if (!array_key_exists($key, $op2)) {
        return null; // не могут быть сравнимы
    } elseif ($val < $op2[$key]) {
        return -1;
    } elseif ($val > $op2[$key]) {
        return 1;
    }
}
return 0; // $op1 == $op2
```

<u>Оператор `===`</u>

`$a === $b` – `true`, если `$a` и `$b` содержат одни и те же пары ключ/значение, в том же самом порядке и того же типа.

```php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");
var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
```

#### Сравнение `object`

Встроенные классы (например, `TDateTime`?) могут определять свои собственные правила сравнения.

- `object1 == $object2`, если они являются экземплярами одного и того же класса, содержат одинаковые свойства с одинаковыми значениями (значения так же сравниваются через `==`)
- `object1 === object2`, если они ссылаются на один и тот же *instance* одного и того же класса.
- `object1 < object2` и `object1 > object2` – для объектов одного класса сравниваются значения соответствующих свойств. (остальные случаи?)

#### Функция `empty`

```php
bool empty ( mixed $var )
```

Возвращает `true`, если аргумент `$var` не существует или его значение равно `false`, т.е. точный эквивалент конструкции:

```php
!isset($var) || $var == false
```

В качестве аргумента `$var` может передаваться выражение, например:

```php
empty(trim($name));
```

[Значения, которые приводятся к `false`](#bool)

#### Конструкция `isset`

```php
bool isset ( mixed $var [, mixed $... ] )
```

Это языковая конструкция, а не функция. Определяет, была ли установлена переменная значением отличным от `null`. Если были переданы несколько параметров, то `isset()` вернет `true` только в том случае, если все параметры определены. Проверка происходит слева направо и заканчивается, как только будет встречена неопределенная переменная.

При использовании `isset()` на недоступных свойствах объекта, будет вызываться перегруженный метод `__isset()`, если он существует.

#### `isset`, `empty` и неопределенные переменные

Если внутри проверяемой переменной используется другая неопределенная переменная, то будет выведена ошибка для всех конструкций: `??`, `empty`, `isset`:

```php
$a = [];
$a[$no] ?? 0;   # Notice!!!
isset($a[$no]); # Notice!!!
empty($a[$no]); # Notice!!!

isset($no, $a[$no]); # OK
```

Но если происходит обращение к несуществующей переменной, или к несуществующему индексу несуществующей переменной, то ошибок нет:

```php
# $a undefined
isset($a['a']);     # OK
empty($a['a'][1]);  # OK
$a['a'][1][2] ?? 0; # OK
```

### Управление ошибками

Может быть выполнено через знак `@` или `set_error_handler()`

### Операторы исполнения

PHP поддерживает один оператор исполнения: обратные кавычки ` `` `.   аналогично использованию функции `shell_exec()`.

### Инкремент `++`, декремент `--`

<u>Инкремент символьных переменных</u>

К символьным переменным можно применять операцию `++`, в то время как операцию `--`применять нельзя.  

Инкрементируются только *ASCII* символы (`a-z` и `A-Z`). Попытка инкремента/декремента других символьных переменных не будет иметь никакого эффекта.

В *C/C++* инкрементирование символа инкрементирует код символа. В PHP инкрементирование строки приводит к получение следующей по смыслу строки (например, для получения следующего символьного идентификатора)

- строка из символов (алгоритм, как в Excel):

  ```
  Y
  Z
  AA
  AB
  ```
  
- строка с цифрами на конце:

  ```
  A8
  A9
  B0
  B1
  ```

  ```
  A09
  A10
  A11
  A12
  ```

### Логические операторы

Перечень в порядке приоритета:

| Оператор    | Значение        |
| ----------- | --------------- |
| `!$a`       | Отрицание       |
| `$a && $b`  | И               |
| `$a || $b`  | ИЛИ             |
| `$a and $b` | И               |
| `$a xor $b` | Исключающее или |
| `$a or $b`  | ИЛИ             |

Смысл двух разных вариантов для операторов `and` и `or` в том, что они работают с различными приоритетами. У `and`, `xor` и `or` приоритет ниже, чем у всех операторов, даже ниже чем у присваивания):

```php
$a = true and false; # Действует как: (($a = true) and false)
var_dump($a);        # bool(true), хотя на первый взгляд должно быть false
```

### `instanceof`

Оператор `instanceof` используется для определения того, является ли текущий объект экземпляром или наследником указанного *class*'а или *interfac*'а.

Может проверяться по:

- название класса или интерфейса:

  ```php
  $a instanceof ClassName
  ```

- строка с названием класса или интерфейса: 

  ```php
  $a instanceof "ClassName"
  ```

- объект некоторого класса:

  ```php
  $a = new MyClass;
  $b = new MyClass;
  
  var_dump($a instanceof $b); // true, $b это объект класса MyClass
  ```

## Управляющие конструкции

### Основной и альтернативный синтаксис

Для операторов `if`, `while`, `for`, `foreach` и `switch` поддерживаются:

- основной синтаксис – с фигурными скобками `{` и `}`:

  ```php
  if (...) {
      ...
  }
  ```

- альтернативный синтаксис – с двоеточием `:` и закрывающим ключевым словом `endif`, `endwhile`, ...

  ```php
  if (...):
      ...
  endif;        
  ```

### `if`,`elseif`, `else`  

`elseif` желательно (по PSR) писать слитно. Тем более, что в альтернативном синтаксисе допустим только `elseif` без пробела.  

### `for`

Синтаксис:

```php
for (expr1; expr2; expr3) {
    ...
}
```

Любое из выражений `exprN` может не указываться, а также состоять из нескольких выражений, разделенных запятой `,`. 

В `expr2` все выражения, разделенные запятыми, вычисляются, но результат берется из последнего. 

Если выражение `expr2` отсутствует, это означает, что цикл будет выполняться бесконечно.

Если `expr2` не будет изменяться во время выполнения цикла, лучше его однократно вычислить до выполнения цикла и не считать на каждой итерации:

```php
$size = count($people);
for($i = 0; $i < $size; $i++) {
    ...
}
```

### `foreach`

Существует 2 синтаксиса:

```php
foreach (array_expression as $value) {
    // ...
}
```

```php
foreach (array_expression as $key => $value) {
	// ...    
}
```

В PHP5 `foreach` двигает внутренний указатель массива, в PHP7 в `foreach` не использует внутренний указатель.

```php
$array = [0, 1, 2];
foreach ($array as &$val) {
    var_dump(current($array)); # все время выводит 0
}
```

При доступе к элементу по ссылке нужно делать так:

```php
foreach ($arr as &$value) {
    ...
}
unset($value);
```

Иначе ссылка `$value` на последний элемент массива останется после окончания цикла `foreach` и возможны ошибки:

```php
foreach ($arr as &$value) {
    ...
}
foreach ($arr as $key => $value) {
    ...
}
// последний элемент $arr[] будет перезаписываться значениями $arr при каждой итерации цикла
```

`foreach` функционально идентично следующей конструкции `while`

```php
foreach ($arr as $key => $value) {
    ...
}
while ([$key, $value] = each($arr)) {
    ...
}
```

Есть возможность обхода массива массивов с распаковкой вложенного массива в переменные цикла:

```php
$a = [
    [12,12,34],
    [543,453,313],
];
foreach($a as [$post_id, $comment_id, $count]) {
    ...    
}
```

`foreach`  *by value*. Изменения, внесенные в массив внутри тела цикла, происходят не в исходном массиве, а в копии массива, т.е. не затронут перебираемые значения.. [Подробнее](#array-zval)

```php
foreach ($array as $val) {
    unset($array); # удаление массива внутри цикла не повлияет на перебор
}
```

`foreach`  *by reference*. Изменения, внесенные в массив внутри тела цикла, происходят в исходном массиве, т.е. затронут перебираемые значения. Причем изменения отслеживаются в процессе итераций.

```php
$array = [0];
foreach ($array as &$val) {
    $array[1] = 1; # добавляет итерацию на еще один элемент
}
```



### `break`

`break` прерывает выполнение конструкций `for`, `foreach`, `while`, `do-while` и `switch`. 

По умолчанию, прерывается ближайшая конструкция:

```php
break;
```

Можно прервать сразу несколько вложенных конструкций, указав числовой аргумент (по умолчанию, `1`):

```php
break 2;
```

### `switch`

В PHP конструкция `switch` считается циклической и внутри нее может использоваться `continue`. Если `continue` не передано аргументов, то он ведет себя аналогично `break`. Если `switch` расположен внутри цикла, `continue 2` продолжит выполнение внешнего цикла со следующей итерации.

Конструкция `switch` использует неточное сравнение (==).

Если не написать `break` в конце секции `case`, PHP будет продолжать исполнять команды следующей секции `case`. В примере будут исполнены все `case` секции:

```php
switch (0) {
    case 0:
        echo "1";
    case 1:
        echo "2";
}
```

Можно указать секцию по умолчанию, которая исполняется, если не сработал ни один `case`:

```php
switch (...) {
    ...
    default:
        ...
}
```

Возможно использование точки с запятой `:` вместо двоеточия `:` после оператора `case`:

```php
switch (...) {
    case 0;
    case 1;
        ...    
}

```

В альтернативном синтаксисе запрещаются любые символы (включая пробел) между `switch` и первым `case`:

```php
<?php switch ($foo): ?> # Error!!!
    <?php case 1: ?>
        ...
<?php endswitch ?>
```

Допускается только перевод строки после `switch`:

```php
<?php switch ($foo): ?>
<?php case 1: ?>
        ...
<?php endswitch ?>
```

### `return`

При вызове `return` без параметров из функции возвращается `null`.

```php
function func() {}

var_dump(func()); # null
```

`return` является специальной конструкцией, а не функцией. Выражение после `return` не надо заключать в скобки. 

### `goto`

```php
goto a;
...

a:
...
```

Требования:

- Целевая метка должна находиться в том же файле.  
- Нельзя выйти за границы функции или метода
- Нельзя перейти внутрь функции или метода
- Нельзя перейти внутрь любой циклической структуры или оператора `switch`, но можно выйти из них.

### `require`, `include`

Единственное отличие `require` и `include`:

- `include`, когда не может найти файл, выдает предупреждение `E_WARNING`
- `require`, когда не может найти файл, выдает фатальную ошибку `E_COMPILE_ERROR`

Может указываться путь:

- абсолютный
- относительный. В этом случае поиск производится в следующем порядке:
  - в папках из директивы `include_path` в `php.ini`
  - в папке с текущим включающим скриптом
  - текущей рабочей директории

Когда файл включается, его код наследует ту же область видимости переменых, что и строка, на которой произошло включение:

- Все переменные, доступные на этой строке во включающем файле будут также доступны во включаемом файле. 
- Все переменные, объявленные во включаемом файле будут доступны во включающем файле.

```php
# 1.php
$var1 = 1;
include "2.php";
var_dump($var2); # int(2)
```

```php
# 2.php
var_dump($var1); # int(1)
$var2 = 2;
```

Так как `include` и `require` – конструкции языка и круглые скобки не обязательны для заключения аргумента.

Если `return` вызывается из глобальной области видимости, выполнение текущего файла скрипта прекращается.  Если текущий файл скрипта был подключен с помощью `include` (`require`), тогда значение переданное `return` будет возвращено в качестве значения вызова `include` (`require`).

```php
# 1.php
return 5;
```

```php
# 2.php
var_dump(include "1.php"); # int(5)
```

Если включаемый файл не содержит `return`, то `include` (`require`) возвращает `1`:

```php
# включение пустого файла
var_dump(include "empty.php"); # int(1)
```

Функции (и классы)? из включаемого файла могут быть использованы во включающем файле, даже если они объявлены после `return`.  

Повторное подключение одного и того же файла с помощью `include` (`require`) выбрасывает ошибку. Необходимо использовать `include_once` (`require_once`).

`include_once` при повторном включении того же файла, ничего не делает и возвращает `true`.

Простейший шаблонизатор на базе `include`:

```php
public function render($view, $params = [])
{
    extract($params);
    ob_start();
    include __DIR__.'/'.$view;
    return ob_get_clean();
}
```

## Функции / методы

Внутри функции может использоваться любой PHP-код, в том числе:

- определение функций
- определение классов (например, *Composer* делает `include` файла внутри функции)

Функции могут вызываться до того, как они были определены в файле. За исключением случая, когда они определены внутри внутри блока, который выполняется в зависимости от условия.  В этом случае такое условие должно сработать раньше вызова функции.

```php
foo();  # Ошибка

if (true) {
    function foo() {}
}

foo();  # OK
```

Все функции и классы PHP имеют глобальную область видимости – они могут быть вызваны вне функции, даже если были определены внутри и наоборот.

```php
function foo()
{
    function bar()
    {
        echo "Я не существую пока не будет вызвана foo().\n";
    }
}

/* Мы пока не можем обратиться к bar(),
поскольку она еще не определена. */
foo();

/* Теперь мы можем вызвать функцию bar(),
обработка foo() сделала ее доступной. */
bar();

```

Отсутствует возможность переопределить или удалить объявленную ранее функцию.

Имена функций регистронезависимы (в отличии от переменных). Тем не менее, более предпочтительно вызывать функции так, как они были объявлены.

### Аргументы функции

Функция принимает список аргументов, разделенных запятой `,`. 

С PHP7.3 можно ставить запятую `,` после последнего аргумента. Это делает вызов функции похожим на синтаксис объявления `array`.

```php
func(
    $arg1, 
    $arg2,
);
```

<u>Нельзя:</u>

- использовать эту возможность в объявлениях функций:

  ```php
  function foo($arg1, $arg2, ) {} # Error!
  ```

- использовать более одной запятой в конце:

  ```php
  func($arg1, $arg2,,); # Error!
  ```

- использовать запятые для пропуска аргументов:

  ```php
  func($arg1, , $arg3); # Error!
  ```

  

Функция, принимающая значение по ссылке:

```php
function func(&$arg) {}
```

Значение по умолчанию функции должно быть константным выражением, а не (к примеру) переменной или вызовом функции/метода класса. Значения по умолчанию могут быть переданы по ссылке

```php
function func(&$arg = 1) {}
```

#### Список аргументов переменной длины

Функция может быть определена с переменным числом аргументов  `...`. Аргументы собираются в `array`:

```php
function func(...$args) {
    var_dump($args); # array(3) {
                     #      0 => 1,
                     #      1 => 2
                     # } 
}

func(1, 2);
```

Многоточие `...`  (*unpacking operator*, оператор распаковки, также *spread operator*, также используется в [1](#unpacking-внутри-array)) можно использовать при вызове функции, чтобы распаковать `iterable` в список аргументов: Можно использовать как замену `call_user_func_array()`:

```php
function add($a, $b) {}
add(...[1, 2]);
```

Можно указать несколько аргументов обычным образом, а в конце добавить `...`. В этом случае `...` поместит в массив только те аргументы, которые не нашли соответствия аргументам в объявлении функции.

Также можно добавить *TypeHinting* перед `...`. В этом случае PHP будет следить, чтобы все аргументы, обработанные многоточием `...`, были указанного типа:

```php
function func(string $a, int ...$b) {}
```

Каждый из списка аргументов может передаваться по ссылке. Для этого перед `...` нужно поставить амперсанд `&`.

```php
function func(int &...$b) {}
```

### Возврат значения

Если нужно вернуть несколько значений из функции, то следует использовать `array`:

```php
function func()
{
    return [0, 1];
}
[$zero, $one] = func();
```

Для того, чтобы функция возвращала результат по ссылке, необходимо:

- использовать оператор `&` при описании функции
- использовать оператор `&` при присвоении переменной возвращаемого значения:

```php
function &returns_reference() {}

$reference =& returns_reference();
```

### TypeHinting

Для аргументов функции и возвращаемого значения могут быть указан *TypeHinting*. 

Допустимые TypeHinting:

| **Тип**                               | **Минимальная версия PHP** |
| ------------------------------------- | -------------------------- |
| Имя класса/интерфейса                 | PHP 5.0                    |
| `self`                                | PHP 5.0                    |
| `array`                               | PHP 5.1                    |
| `callable`                            | PHP 5.4                    |
| `bool`                                | PHP 7.0                    |
| `float`                               | PHP 7.0                    |
| `int`                                 | PHP 7.0                    |
| `string`                              | PHP 7.0                    |
| `iterable`                            | PHP 7.1                    |
| `void` (только возвращаемое значение) | PHP 7.1                    |
| `object`                              | PHP 7.2                    |

#### `void`

Применяется только для возвращаемого значения. 

Функция не должна ничего возвращать:

- не содержать ни одного оператора `return`

- использовать `return` без параметра:

  ```php
  return;
  ```

  

#### Nullable type

Тип аргумента (возвращаемого значения) может быть указан, как обнуляемый (*nullable*) – этот аргумент (возвращаемое значение) могут быть указанного типа или `null`.

Способы указать аргумент, как обнуляемый:

- задать значение по умолчанию `null`:

  ```php
  function f(C $c = null) {}
  ```

- добавить перед типом знак вопроса `?`:

  ```php
  function testReturn(): ?string
  {
      return null;
  }
  
  function test(?string $name) {}
  
  ```

#### Режимы типизации

Возможны два режима типизации:

- слабая
- строгая (*strict*)

<u>Слабая типизация</u>

По умолчанию, используется слабая типизация – PHP будет пытаться привести значения несоответствующих типов к скалярному типу, если это возможно. Например:

- если в функцию передается `int`, а тип аргумента объявлен `string` – функция получит приведенное к `string` значение:

- значение `bool` может быть приведено к `int`:

  ```php
  function a(?int $b) {
      return $b;
  }
  
  var_dump(a(false)); // int(0)
  var_dump(a(true));  // int(1)
  ```

<u>Строгая типизация</u>

Может быть включен режим строгой типизации. Он распространяется на вызовы функций совершенные из файла, в котором этот режим включен, а не на функции, которые в этом файле объявлены.

```php
declare(strict_types=1);
```

В этом режиме в функцию можно передавать (и возвращать) значения только тех типов, которые объявлены для аргументов. Одно исключение: можно передать `int` в функцию, в ожидающую `float`.  Строгая типизация применима только к скалярным типам (т.е. не влияет на приведение классов к родительскому типу?).

### Анонимные функции

Анонимные функции (замыкания) могут быть использованы в качестве значений переменных; PHP автоматически преобразует такие выражения в экземпляры внутреннего класса `Closure`. 

Замыкания могут наследовать переменные из родительской области видимости с помощью конструкции `use`. 

При наследовании по значению, унаследованная переменная является копией и не меняется, при изменении значения в родительской области.

```php
$message = 'hello';
# Наследование по значению
$example = function () use ($message) {
    var_dump($message);
};

# Меняем $message
$message = 'world';
$example(); // выводит hello
```

При наследовании по ссылке, значение переменной в родительской области и в замыкании меняются вместе.

```php
$message = 'hello';
# Наследование по ссылке
$example = function () use (&$message) {
    var_dump($message);
};
# Меняем $message
$message = 'world';
$example(); //выводит world
```

Замыкания могут принимать обычные аргументы

```php
$example = function ($arg) use ($message) {};
```



Сохранение переменной между вызовами возможно так:

```php
function getTotal()
{
    static $count = 0;
    $callback =
        function() use (&$count) {};
    $callback();
}

getTotal();
getTotal();
```

или так:

```php
function getTotal()
{
    $count = 0;
    
    $callback =
        function() use (&$count) {}
    return $callback;
}

$a = getTotal();
$a();
$a();
```

По умолчанию, если анонимная функция объявлена в методе класса, то эта функция будет автоматически связана с этим классом и внутри функции будет доступна переменная `$this`. Если такое автоматическое связывание нежелательно, то можно объявить анонимную функцию как статическую (ниже написано).

```php
class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function(); # Выводит object(Test)#1 (0) {}

```

При этом запрещено и вызывает ошибку использование в `use` суперглобальных переменных, `$this` и переменных с теми же именами, что и параметры функции:

```php
$f = function () use ($_SERVER) {};     //ошибка
$f = function () use ($this) {};        //ошибка
$f = function ($param) use ($param) {}; //ошибка
```

Анонимные функции могут быть объявлены статически. Это значит, что эти функции не привязаны к экземпляру класса и в них не доступна переменная `$this`. 

```php
class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);   # Ошибка
        };
        $func();
    }
};

```

Также статические функции нельзя привязать к объекту во время выполнения.

```php
$func = static function() {
    // тело функции
};
$func = $func->bindTo(new StdClass); # Error

```

### Arrow function

*Arrow function*'s (стрелочные функции), также называются *short closure*'s (короткие замыкания) – сокращенная запись для *anonymous function*'s с неявной привязкой *parent scope by value*.

Цель их введения: упростить синтаксис написания *anonymous function*'s, когда они выполняют простую операцию.

Синтаксис:

```php
fn(parameter_list) => expression;
```

*Arrow function* должна содержать только один *expression*, значение которого является возвращаемым значением *arrow function*, т.е. *expression* как бы вложено в оператор `return`.

*Arrow function* не поддерживают несколько *expression*'s, разделенных через символ `;`,

В `expression` можно использовать переменные из *parent scope*, переменные будут определены *by value*. Т.е. для переменной `$y`  неявно выполняется `use ($y)`. 

В примере ниже, функции `$fn1` и `$fn2` идентичны:

```php
$y = 1;
 
$fn1 = fn($x) => $x + $y;
 
$fn2 = function ($x) use ($y) {
    return $x + $y;
};
```

*Arrow function*'s позволяют использовать *typehinting*, аргументы и возврат значения *by reference*:

```php
fn(): int => $x;
fn(&$x) => $x;
fn&($x) => $x;
```

Как и для обычных *anonymous function*'s:

- *arrow function*'s, объявленные внутри класса будут автоматически связаны с этим классом и внутри функции будет доступна переменная `$this`. 
- *arrow function* может быть объявлена как `static` и тогда, эта функция не будет привязана к классу и в ней не будет доступна переменная `$this`. 

```php
class Test {
    public function method() {
        $fn = fn() => var_dump($this);
        $fn(); // object(Test)#1 { ... }
 
        $fn = static fn() => var_dump($this);
        $fn(); // Error: Using $this when not in object context
    }
}
```

*Arrow function* имеет самый низкий приоритет, так что выражение справа от `=>` всегда будет вычислено вначале.

*Arrow function*'s могут вкладываться друг в друга (право-ассоциативный оператор). Причем в каждый *child scope* пробрасываются переменные из всех *parent scope*'s.

```php
$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
```







### Класс `Closure`

Класс, используемый для создания анонимных функций.

Для привязки функции к объекту могут использоваться:

- динамический метод

  ```php
  public Сlosure::bindTo( object $newthis [, mixed $newscope = "static" ] ): Closure
  ```

  Создает и возвращает новую анонимную функцию с тем же телом функции и связанными переменными, но с другим связанным объектом  (т.е. который в функции будет доступен через `$this`) или новой областью видимости класса (класс, который определяет к каким `protected` (защищенным) и `private` (закрытым) элементам объекта будет иметь доступ анонимная функция). Для статических фунций первый параметр NULL.

  ```php
  $func = function($param) {var_dump($this);}; # функция не член класса
  class Obj {} # класс
  $obj = new Obj;
  $func_bind = $func->bindTo($obj, $obj); # привязка к классу и его области видимости
  $func_bind(1); # object(Obj)#2 (0) { }
  ```

- статический метод

  ```php
  public static bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] ) : Closure
  ```

  ```php
  $func_bind = Closure::bind($func, $obj, $obj);
  ```

Другие функции:

- Привязать функцию к объекту и вызвать, как в *javascript*. Не создавая новый `Closure` через `bindTo`

- ```php
  public Closure::call ( object $newthis [, mixed $arg1, ... ] ) : mixed
  ```

  - `$newthis` – объект для связи с замыканием на время его запуска.

  - `$arg1, ...` – параметры, которые передаются замыканию.

- ```php
  $func->call($obj, 2);
  ```

  При этом запрещено привязывать методы одного объекта к другому объекту, но можно привязать функции за пределами объекта, статические и анонимные функции (лямбда).


- Преобразовать  [`callable`](#callable) (в виде `string`, `array`, ...) → `Closure`:

- ```php
  public static Closure::fromCallable ( callable $callable ) : Closure
  ```
  
  ```php
  $closure = Closure::fromCallable ( [$object, 'method'] );
  ```
  
  

# Классы и объекты

Объекты можно объявлять без скобок:

```php
$a = new A;
```

Объекты допускают объявление динамических свойств, т.е. которых не существует в классе:

```php
$a->b = 5; 
```

## Property

Свойства класса представляются в `zend_object` структурой `HashTable`. Ключи могут иметь только тип `string`.

Свойства при объявлении могут инициализироваться, но они должны быть вычислены во время компиляции

- Корректные определения свойств:

- ```php
  class SimpleClass
  {
      public $var1 = 'hello ' . 'world';
      public $var2 = <<<EOD
  hello world
  EOD;
      public $var3 = 1 + 2;
      public $var6 = myConstant;
  }
  ```

- Некорректное определение *property*'s:

- ```php
  class SimpleClass
  {
      public $var4 = self::myStaticMethod();
      public $var5 = $myVar;
  }
  ```

Доступ к *property* по имени возможен:

- обычным способом:

  ```php
  $object->property
  ```

- с указанием `string` в фигурных скобках `{'...'}`:

  ```php
  $object->{'property'}
  ```

  Если имя *property* содержит недопустимые символы (`-`) или является числом (`0`), то доступ к нему можно получить только через фигурные скобки:

  ```php
  $obj = new stdClass;
  $obj->0 = 1;       # Error
  $obj->{'0'} = 1;   # OK
  $obj->{'a-b'} = 1; # OK
  ```

В PHP 7.4 были введены *typed property*'s (типизированные свойства) – определение *property* может включать *typehint*, кроме типов `void` и `callable`:

```php
class Bar
{
    public string $name;
    public ?int $amount;
    public Foo $foo;
}
```

## Преобразование других типов в `object` 

### Преобразование `array` в `object`

При преобразовании `array` в `object` будет  создан объект:

- названия *property* – ключи массива. Названия *property* (ключи в `HashTable properties`) могут иметь только тип `string`. Ключи с типом `int` преобразуются в `string`.
- значения *property* – значения массива. 

### Преобразование скалярных типов в `object`

Если значение скалярного типа преобразуется в `object`, создается новый экземпляр встроенного класса `stdClass`. Значение переменной будет помещено в поле с именем `scalar`.

```php
$a = 1;
var_dump((object)$a); # object(stdClass)#1 (1) {
                      #   ["scalar"] => int(1)
                      # }
```

`stdClass` это пустой класс, который используется при преобразовании других типов в объект. Он полезен для анонимных объектов, динамических свойств и т. д.

## Вызов метода родительского класса

Для вызова метода родительского класса может использоваться оператор конструкция  `<ParentClass>::<method>()`. Хотя используется оператор `::` для статического вызова, на самом деле вызов выполняется в контексте дочернего класса и переменная `$this`  определена.

```php
class A
{
    function foo()
    {
        var_dump($this);
    }
}

class B extends A
{
    function bar()
    {
        A::foo();
    }
}

$b = new B();
var_dump($b->bar());    # object(B)#1 (0) { }
```

Вызов *non-*`static` метода не родительского класса через оператор `::`  приводит к ошибке и переменная `$this` неопределена.

```php
class A
{
    function foo()
    {
        var_dump($this);
    }
}

class B  # не имеет родительского класса
{
    function bar()
    {
        A::foo();
    }
}

A::foo();    # Notice
$b = new B();
$b->bar();   # Notice

```

## Создание объекта

Существуют следующие способы создания объекта:

- со статическим указанием имени класса 

  ```php
  $object = new ClassName();
  ```

- с динамическим указанием имени класса в виде строки:

  ```php
  $className = 'ClassName';
  $object = new $className(); 
  ```

- в контексте класса, используя ключевые слова `new` и `parent`.

  ```php
  class B extends A
  {
      public function method()
      {
          $object1 = new self;
          $object2 = new parent;
      }
  }
  
  ```

## Наследование

К переопределенным методам или статическим свойствам можно обращаться через `parent::`

## Константы `const`

К константе можно обратить через `self`, имя класса, переменную с именем класса и объект класса:

```php
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        # Обращение через self
        echo self::CONSTANT;
    }
}

# Обращение по имени класса
echo MyClass::CONSTANT;

# Обращение через переменную с именем класса
$classname = "MyClass";
echo $classname::CONSTANT;

# Обращение через объект
$class = new MyClass();
echo $class::CONSTANT;

```

Значение константы должно быть неизменяемым выражением, а не (к примеру) переменной, свойством или вызовом функции:

```php
class foo {
    const TWO = ONE * 2;
    const THREE = ONE + self::TWO;
    const SENTENCE = 'The value of THREE is '.self::THREE;
}
```

Для констант класса можно использовать модификаторы видимости:

```php
class Foo {
    public const BAR = 'bar';
    private const BAZ = 'baz';
}
```

Доступна специальная константа `class`, которой на этапе компиляции присваивается полное имя класса. Полезна при использовании с классами, использующие пространства имен. Так как константа `class` определяется на этапе компиляции, она недоступна на объектах.

```php
namespace foo {
    class Bar {}
    $bar = new Bar;

    var_dump(Bar::class); # string(7) "foo\bar"
    var_dump($bar::class); # Fatal error
}
```

Константы можно переопределять в дочерних классах:

```php
class A
{
    const c = '1';
}
class B extends A
{
    const c = '2';
}
```

## Конструкторы и деструкторы

Конструкторы старого типа, задаваемые функцией с именем класса, объявлены УСТАРЕВШИМИ в PHP 7.0 и будут удалены в будущих версиях.

```php
class Bar {
    public function Bar() {}
}
```

Как правило, конструкторы и деструкторы объявляются с модификатором `public`. Если конструктор объявлен как `protected` или `private`, создание экземпляра класса извне класса запрещено. Это имеет смысл, если необходимо запретить создание объектов через  `new` и объявить статическую функцию – фабрику объектов этого класса (как в [ServiceLocator](#ServiceLocatorКласс с набором конкретных методов))

## Область видимости

К приватному свойству родительского класса в дочернем обращаться нельзя, но после переопределения в дочернем – можно:

```php
class Class1
{
    private $private1 = 'Private1';
    private $private2 = 'Private2';
}

class Class2 extends Class1
{
    // Мы можем переопределить общедоступные и защищенные свойства, но не закрытые
    private $private1 = 'Private3';

    function func()
    {
        var_dump($this->private1);  # string(8) "Private3"
        var_dump($this->private2);  # PHP Notice:  Undefined property: Class2::$private2
    }
}

$obj2 = new Class2();
$obj2->func();
```

Переопределение приватных функций допускается, при этом они не являются полиморфными:

```php
class Bar
{
    public function test() {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic() {   }

    private function testPrivate() {  }
}

class Foo extends Bar
{
    public function testPublic() { }

    private function testPrivate() {  }
}

$myFoo = new Foo();
$myFoo->test(); // Bar::testPrivate
                // Foo::testPublic
```

Объекты, которые имеют общий тип (наследуются от одного класса), имеют доступ к элементам с модификаторами `private` и `protected` друг друга, даже если не являются одним и тем же экземпляром. 

```php
class Test
{
    private $foo;

    private function bar() {}
    public function baz(Test $other)
    {
        // Мы можем изменить закрытое свойство:
        $other->foo = 'hello';
        // Мы также можем вызвать закрытый метод:
        $other->bar();
    }
}
```

## LSP в PHP

Пусть объявлен `class A` (или `interface A`)  с функцией `func()`:

```php
class A
{
    public function func(int $x) {}
}
```

### Ковариантность и контравариантность

<u>Вариантность (*variance*) или совместимость присваивания (*assignment compatibility*) типов</u> – это существующие ограничения и разрешения на возможность подставлять  значение одного типа вместо другого типа, причем эти типы являются *variant* друг другу. 

В PHP *variant* типами являются:

- `ParentClass` → `ChildClass`
- `iterable` → (`array`, `Traversable`, ...  ([1](#iterable))
- `object` → любой `class` 

<u>Инвариантность (*invariance*) типа</u> – это ограничение на подстановку как надклассов, так и подклассов. То есть метод может принимать или возвращать только указанный тип и никакой больше. 

До версии 7.4 PHP поддерживал только *invariant* типы параметров и *invariant* типы возвращаемого значения для методов дочернего класса. Т.е. если метод родительского класса принимает параметр или возвращается значение типа `T`, то этот параметр или возвращаемое значение у дочернего класса также должно быть `T`.

![invariance](https://parshikovpavel.github.io/img/php/invariance.png)

<u>Ковариантность (*covariance*) типа</u> – это  запрет на подстановку надклассов (*overtype*) и возможность на подстановку подклассов. 

В PHP существует ковариантность типа возвращаемого значения (*covariant return type*) в методах дочернего класса (дочерний класс сужает область возвращаемых значений, постусловия могут быть усилены в подклассах):

- метод дочернего класса `B` указывает тип возвращаемого значения, тогда как в классе  `A` тип возвращаемого значения не указан:

  ```php
  class B
  {
      public function func(int $x): int {}
  }
  ```

- методы дочернего класса могут в качестве возвращаемого значения использовать как исходный класс, так и любой его подкласс (*subtype, child type*), но не могут использовать надкласс (*overtype, parent type*).

- ```php
  class OverType {}
  class Type extends OverType {}
  class SubType extends Type {}
  
  class ParentClass {
      function a() : Type {}
      function b() : Type {}
  }
  
  class ChildClass extends ParentClass {
      function a() : SubType {}  # OK
      function b() : OverType {} # PHP Fatal error:  Declaration must be compatible
  }
  ```

  ![covariance](https://parshikovpavel.github.io/img/php/covariance.png)

<u>Контравариантность (*contravariance*) типа</u> – это запрет на подстановку подклассов и возможность на подстановку надклассов. 

В PHP существует контравариантность типа параметра (*contravariant parameter type*) в методах дочернего класса (дочерний класс расширяет область принимаемых параметров, предусловия могут быть ослаблены в подклассах):

- метод дочернего класса `B` опускает (не указывает) тип параметра, тогда как в классе  `A` тип параметра указан :

  ```php
  class B
  {
  	public function func($x);
  }
  ```

- методы дочернего класса могут в качестве параметра использовать как исходный класс, так и любой его надкласс (*overtype, parent type*), но не могут использовать подкласс (*subtype, child type*).

  ```php
  class OverType {}
  class Type extends OverType {}
  class SubType extends Type {}
  
  class ParentClass {
      function a(Type $param) {}
      function b(Type $param) {}
  }
  
  class ChildClass extends ParentClass {
      function a(OverType $param) {}  # OK
      function b(SubType $param) {} # PHP Fatal error:  Declaration must be compatible
  }
  ```

  



![contravariance](https://parshikovpavel.github.io/img/php/contravariance.png)

### Совместимости сигнатур

Сигнатура – это описание функции (метода), включающее в себя:

- модификатор доступа


- имя функции (метода)


- cписок аргументов, где для каждого аргумента указаны:
  - тип
  - имя
  - значение по умолчанию
  - оператор «три точки» (`...$args`)
- тип возвращаемого значения

Сигнатура функции `func()` в `class`'е-наследнике (или `interface`-наследнике) `B` считается <u>совместимой</u> с функцией в `A` (порядок важен, отношение несимметрично!), если:

1. Они полностью совпадают

2. Имеются следующие отличия в аргументах, допустимые согласно *LSP*:

   - `B` добавляет к `A` аргументы, со значениями по умолчанию (предусловия могут быть ослаблены в подклассах). Примеры:

     ```php
     public function func(int $x, $y = null);
     ```

     ```php
     public function foo(int $x, ...$args);
     ```

   - `B` изменяет название аргументов из `A`:

     ```php
     public function func(int $another_name);
     ```

   - `B`  имеет параметры, контравариантного типа (как [выше написано](#ковариантность-и-контравариантность))

   - конструктор `B::__construct()` может быть переопределен с любыми параметрами (получается что LSP нарушается).
   
3. Имеются отличия в возвращаемом значении:

   - `B` имеет ковариантный тип возвращаемого значения (как [выше написано](#ковариантность-и-контравариантность))

4. Имеются отличия в модификаторе видимости: 

   - модификатор видимости  методов должен совпадать или быть менее строгим:

      ```php
      class Bar
      {
          protected function a() {}
      }
      class Baz extends Bar
      {
          public function a() {}
      }
      ```

      

5. Возможна комбинация из нескольких отличий:

  ```php
  function foo(int $x, ...$args): int;
  ```

Перечисленные правила учитываются при `extends` и `implements`

- классов `class`
- интерфейсов `interface`
- `abstract` классов и `abstract` методов

## Статические свойства и методы

К статическому свойству и методу можно обращаться:

- через класс `Foo::`
- через переменную с именем класса `$classname::`
- через объект:
  - при доступе к свойству нужно использовать только оператор `::` (а не`->`).
  - при доступе к методу можно использовать или `::` или `->`

```php
class Foo
{
    public static $property = 'foo';
    static public function method() {}
}

$classname = 'Foo';
$classname::$property; # OK
$foo = new Foo();
$foo::$property;       # ОК

$foo->property;        # Notice, не определено свойство property

$foo->method();  # OK
$foo::method();  # OK
```

При наследовании статическое *property* – это одна и та же переменная для родительского и дочернего класса, если статическое *property* явно не переопределено в дочернем классе

```php
class A {
    static $a;
}
class B extends A {}
A::$a = 10;
var_dump(B::$a); # int(10)
```

## Абстрактные классы

В абстрактном классе можно не объявлять явно абстрактными методы интерфейса. 

```php
interface InterfaceA
{
    # Этот метод будет объявлен абстрактным
    public function methodA();

    # Этот метод в абстрактном классе не объявлен
    public function methodB();
}

abstract class ClassA implements InterfaceA
{
    abstract public function methodA();
}
```

## Интерфейс

Интерфейс может содержать:

- `public` константы. Константы невозможно переопределить в интерфейсе-наследнике или в классе, реализующем данный интерфейс. 

  ```php
  interface SomeInterface
  {
      public const STATUSES = 1;
  }
  ```

- `public` методы без тела, с `;` на конце: 

  ```php
  interface SomeInterface
   {
       public function foo();
       public static function bar(Baz $baz);
   }
  ```

Нельзя включать в интерфейс: 

-  любые свойства


- не `public` методы


- не `public` константы


Интерфейс может наследоваться от множества других интерфейсов (в отличии от классов, которые наследуются от одного интерфейса). Для этого используется ключевое слово `extends`.

```php
interface First
{
    public function foo(int $x);
}

interface Second
{
    public function bar(string $s);
}

interface Third extends First, Second
{
    public function baz(array $a);
}
```

При множественном наследовании интерфейсов воможны конфликты. Для их разрешения:

- сигнатуры нескольких интерфейсов должны совпадать


- сигнатура метода интерфейса, упомянутого в списке первым, должна быть совместима с сигнатурой из последующего интерфейса


В интерфейсе есть предопределенная константа `ThisInterface::class`

Никаких ограничений на использование `static` методов в интерфейсе нет.

```php
interface I
{
    static function f();
}
```

Если класс и наследует `extends` и реализует интерфейс `implements`, то ключевые слова указываются в порядке `extends` – `implements`:

```php
class A extends B implements C {}
```

## Трейт

Трейт позволяет реализовать множественным наследование и смешивание (*mixin*). Невозможно создать самостоятельный экземпляр трейта. В трейте можно обращаться к родительскому классу через `parent`.

Порядок приоритета по убыванию:

- члены из текущего класса 


- методы в трейте


- унаследованные методы.

```php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
```

Если два трейта вставляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешен. Необходимо использовать оператор `insteadof` для того, чтобы точно выбрать один из конфликтных методов. Оператор `as` может быть использован для включения одного из конфликтующих методов под другим именем.

При возникновении конфликтов имён методов недостаточно только назначить псевдонимы используя ключевое слово `as`. Сначала обязательно нужно заместить метод используя слово `insteadof`, только потом использовать `as`, так как эта конструкция назначает псевдоним только для замещённых методов.

```php
trait A {
    public function smallTalk() {}
    public function bigTalk() {}
}

trait B {
    public function smallTalk() {}
    public function bigTalk() {}
}



class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A; # метод B::smallTalk вместо A::smallTalk
        A::bigTalk insteadof B;   # метод A::bigTalk вместо B::bigTalk
        B::bigTalk as talk;       # метод B::bigTalk включить под псевдонимом talk
    }
}
```

Используя синтаксис оператора `as` можно также настроить видимость метода в использующем трейт классе.

```php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

// Изменение видимости класса sayHello
class MyClass1 {
    use HelloWorld { sayHello as protected; }
}

// Создание псевдонима метода с измененной видимостью
class MyClass2 {
    use HelloWorld { sayHello as private myPrivateHello; }
}
```

Аналогично тому, как классы могут использовать трейты, также могут и трейты использовать другие трейты.

```php
trait HelloWorld {
    use Hello, World;
}
```

Трейты поддерживают использование абстрактных методов:

```php
trait Hello
{
    abstract public function getWorld();
}
```

Внутри методов трейта можно определять статические переменные, причем у каждого класса будет свой экземпляр этой переменной.

```php
trait Counter {
    public function inc() {
        static $c = 0;
        print ++$c;
    }
}

class C1 {
    use Counter;
}

class C2 {
    use Counter;
}

$o = new C1(); $o->inc(); // echo 1
$p = new C2(); $p->inc(); // echo 1
```

В трейте можно объявить статическое свойство, при этом в каждом классе, его реализующем, будет свое значение этой переменной:

```php
trait A {
    static $a;
}
A::$a = 10;
```

Если трейт определяет свойство, то класс не может определить свойство с таким же именем, кроме случаев полного совпадения (те же начальное значение и модификатор видимости), иначе будет сгенерирована фатальная ошибка.

```php
trait PropertiesTrait {
    public $same = true;
    public $different = false;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true;       // OK
    public $different = true;  // Error
}
```

### Примеры

Трейт для добавления функциональности синглтона.

```php
trait Singleton 
{
   static public $instance;
   
   static public function getInstance()
   {
      if(static::$instance === null) {
         static::$instance = new static();
      }
      
      return static::$instance;
   }
   
   
}

class Application 
{
   use Singleton;
}

$app = Application::getInstance();
```

## Анонимные классы

Анонимные классы используют тогда, когда нужен одноразовый класс и создавать полноценный класс, а потом его объект не имеет смысла.

Используется в форме `new class`, чтобы сразу создать экземпляр анонимного класса.

Способы применения:

- присвоить экземпляр переменной:

  ```php
  $class = new class {function echo() {}};
  $class->echo();
  ```

- передать экземпляр в качестве параметра:

  ```php
  $app->setLogger(new class implements Logger {
      public function log(string $msg) {
          echo $msg;
      }
  });
  ```

Анонимные классы обладают всеми возможностями обычных классов:

- передавать аргументы в конструкторы
- наследовать другие классы
- реализовывать интерфейсы
- использовать трейты

```php
class SomeClass {}
interface SomeInterface {}
trait SomeTrait {}

$object = new class(10) extends SomeClass implements SomeInterface {
    use SomeTrait;
    public function __construct($num) {}
};
```

Все объекты, созданные одной и той же декларацией анонимного класса, являются объектами одного класса. Анонимным классам присваиваются имена движком PHP .

```php
function f()
{
    return new class {};
}

$a = f();
$b = f();

assert($a == $b);
```

## Перегрузка и магические методы

Перегрузка в PHP – возможность динамически «создавать» свойства и методы через магические функции. Все методы перегрузки должны быть объявлены как `public`. Аргументы в магические методы не могут  передаваться *by reference*. 

### `__construct()` и `__destruct()`

### `__call()` и `__callStatic()`

```php
public __call ( string $name , array $arguments ) : mixed
```

Запускается при вызове недоступных методов в контексте объекта.

```php
public static __callStatic ( string $name , array $arguments ) : mixed
```

Запускается при вызове недоступных методов в статическом контексте.

### `__get()` и `__set()`

 ```php
public __set ( string $name , mixed $value ) : void
 ```

Вызывается при записи данных в недоступные свойства.

```php
public __get ( string $name ) : mixed
```

Вызывается при чтении данных из недоступных свойств

Можно использовать в нескольких присвоениях подряд. При этом игнорируется возвращаемое `__set` значение и не вызывается `__get`:

```php
$a = $obj->b = 8;
```

При обращении к приватным свойствам, происходит вызов `__get` и `__set`:

```php
class A
{
    private $pr = 1;

    public function __get($name) {}
    public function __set($name, $value) {}
}
$a = new A;
$a->pr = 2; //вызывается __set
```

### `__isset()` и `__unset()`

```php
public __isset ( string $name ) : bool
```

Вызывается при использовании `isset()` на недоступных свойствах.

```php
public void __unset ( string $name )
```

Выполняется при вызове `unset()` на недоступном свойстве.

### Сериализация

Есть три взаимоисключающих способа управления сериализацией:

- `__sleep()` и `__wakeup()`
- `__serialize()` и `__unserialize()`
- [Интерфейс `Serializable`](#Serializable)

#### `__sleep()` и `__wakeup()`

```php
public __sleep ( void ) : array
```

Выполняется перед `serialize()`. Метод должен подготовить объект к выгрузке (завершить работу с данными, записать нужные значения в *property*'s) и возвращает массив с именами всех *property*'s объекта, которые должны быть сериализованы. 

```php
public __wakeup ( void ) : void
```

Вызывается после `unserialize()` . Может использоваться для восстановления соединений с базой данных.

```php
class Connection
{
    private $link, $dsn, $username, $password;

    public function __sleep()
    {
        return ['dsn', 'username', 'password'];
    }

    public function __wakeup()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
}

```

#### `__serialize()` и `__unserialize()`

```php
public __serialize ( void ) : array
```

Вызывается перед `serialize()`. Метод должен вернуть `array` с данными для сериализации.

```php
public __unserialize ( array $data ) : void
```

Вызывается после `unserialize()`. Методу будет передан восстановленный массив, который был возвращен из `__serialize()`. Затем он может вручную восстановить свойства объекта из этого массива.

```php
class Connection
{
    protected $link;
    private $dsn, $username, $password;

    public function __serialize(): array
    {
        return [
          'dsn' => $this->dsn,
          'user' => $this->username,
          'pass' => $this->password,
        ];
    }

    public function __unserialize(array $data): void
    {
        $this->dsn = $data['dsn'];
        $this->username = $data['user'];
        $this->password = $data['pass'];

        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
}
```

### `__toString()`

```php
public __toString ( void ) : string
```

Позволяет классу решать, как он должен реагировать при преобразовании в строку. 

### `__invoke()`

```php
__invoke ([ $... ] ) : mixed
```

Вызывается, когда скрипт пытается выполнить объект как функцию.

```php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);                       # int(5)
var_dump(is_callable($obj));   # bool(true)

```

### `__set_state()`

```php
static __set_state ( array $properties ) : object
```

Статический метод, который вызывается для тех классов, которые экспортируются функцией `var_export()`.

Функция `var_export()` выводит или возвращает интерпретируемое строковое представление переменной:

```php
/**
 * @param mixed $expression Переменная, которую необходимо экспортировать.
 * @param bool $return Если TRUE var_export() вернет представление переменной вместо его вывода
 * @return mixed Если return=TRUE => представление переменной, иначе NULL.
 */
mixed var_export ( mixed $expression [, bool $return = FALSE ] )
```

 Функция аналогична `var_dump()` за одним исключением: возвращаемое представление является полноценным PHP-кодом.  При применении этой функции к объекту PHP-код будет содержать вызов метода `__set_state()`.

```php
/* Пример экспорта и импорта объекта */
class A
{
    public $var;

    public static function __set_state($an_array)
    {
        $obj = new A;
        $obj->var = $an_array['var'];
        return $obj;
    }
}

$a = new A;
$a->var = 5;

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var' => 5,
                                            // ));
var_dump($b);   # object(A)#2 (1) {
                #    ["var"]=>
                #      int(5)
                # }
```

### `__clone()`

```php
__clone ( void ) : void
```

Вызывается для вновь склонированного объекта, для его дополнительной настройки

### `__debugInfo()` 

```php
__debugInfo ( void ) : array
```

`_debugInfo()` вызывается функцией `var_dump()` и должен вернуть для вывода массив свойств объекта и их значений. Если этот метод не определен, тогда будут выведены все `public`, `protected` и `private` свойства объекта.

```php
class C {
    private $prop;

    public function __construct($val) {
        $this->prop = $val;
    }

    /* Вместо свойства prop будет выведено propSquared */
    public function __debugInfo() {
        return [
            'propSquared' => $this->prop ** 2,
        ];
    }
}

var_dump(new C(42)); # object(C)#1 (1) {
                          #    ["propSquared"]=>
                          #     int(1764)
                          # }
```

