# Общая характеристика языка

- *stateless* по умолчанию. Это очень удобно, когда растущий проект перестает помещаться на один сервер. В этом случае [в]() PHP мы гарантировано не завязаны на взаимодействие потоков на одном сервер, на хранение данных в локальной памяти.

- низкий порог вхождения.  Удобен для набора команд, которые зачастую состоят из *junior* и *middle*.

## PECL

*PECL* (транск. 'pickle', PEAR Extension Code Library) это:

-  репозиторий компилируемых расширений самого интерпретатора PHP. 
- консольная утилита `pecl`, которая поставляется в одной папке с PHP

*PECL*  создан, чтобы упростить установку расширений, которые вынесены из стандартной поставки PHP. Расширения представлены в форме модулей *С* , которые подключаются к машине PHP. Поскольку расширение представляют собой программы на языке *С* , то как правило выполняются быстрее и более эффективно по сравнению с расширениями на *PHP*.

Установка расширения:

```bash
pecl install <extension_name>
```

Узнать каталог где PECL хранит *extension*'ы, чтобы прописать  `extension_dir` в `php.ini`

```bash
pecl config-get ext_dir
```

Какие-то ошибки исправляет:

```bash
mkdir -p /tmp/pear/cache
```

## PEAR

*PEAR* - это предшественник *Composer* для добавления библиотек PHP.

Устарел, вместо него используются *Composer* и *packagist*.

## Xdebug

### Установка

- `pecl install xdebug`

  Автоматически в `php.ini` добавляются строки:

  ```
  zend_extension="xdebug.so"
  extension_dir = "/usr/local/lib/php/pecl/20190902"
  ```

  Путь к расширению `/usr/local/Cellar/php/7.4.2/pecl/20190902/xdebug.so'`

- 

## PHP.ini

### Местоположение

В *Ubuntu* используется несколько конфигурационных файлов `php.ini`:

- `/etc/php7/cli/php.ini` — конфигурационный файл консольной утилиты `php`;

- ` /etc/php7/apache2/php.ini` — конфигурационный файл для модуля РНР встроенного в Apache;

- `/etc/php7/fpm/php.ini` — конфигурационный файл для PHP-FPM , используемый *nginx*.

Расположение для *Mac*:

- `/usr/local/etc/php/<version>/php.ini`

Узнать местоположение используемого файла можно в отчете с настройками. Отчет можно получить через:

- в коде `phpinfo()`


- в консоли:

  ```bash
  php -i
  ```

### `memory_limit` 

максимальное количество оперативной памяти, которое может быть выделено скрипту. ВАЖНО!!! Это не лимит оперативной памяти выделяемой для всего PHP.

### `max_execution_time`

Максимальное время в секундах, в течение которого скрипт должен полностью загрузиться. Если этого не происходит, парсер завершает работу скрипта с `Fatal Error`. По умолчанию на загрузку дается 30 секунд. Если PHP запущен из командной строки, это значение по умолчанию равно `0`.

# Ключи в режиме командной строки

- Все параметры PHP

  ```bash
  php -h
  ```

- Запуск встроенного в php веб-сервера

  ```bash
  php -S localhost:8000
  ```

  Если в конце указать PHP-файл, то он рассматривается как скрипт "маршрутизации". Скрипт выполняется в самом начале после каждого HTTP-запроса. Если этот скрипт возвращает `FALSE`, то запрашиваемый ресурс возвращается как есть. В противном случае браузеру будет возвращен вывод этого скрипта.

  Для запуска на 80 порту нужен `sudo`. По умолчанию текущая папка является корневой для сервера.

- Версия PHP

- ```bash
  php -v
  ```

- Вызвать `phpinfo()` и вывести его результат.

- ```bash
  php -i
  ```

- Вывод подключенных модулей

- ```bash
  php -m
  ```

- Вывод всех загруженных конфигурационных файлов

- ```bash
  $ php --ini
  Configuration File (php.ini) Path: /usr/local/etc/php/7.4
  Loaded Configuration File:         /usr/local/etc/php/7.4/php.ini
  Scan for additional .ini files in: /usr/local/etc/php/7.4/conf.d
  Additional .ini files parsed:      /usr/local/etc/php/7.4/conf.d/ext-opcache.ini
  ```

- Запустить консольную версию в виде интерактивной консоли, в которую вводишь команды и сразу возвращается результат исполнения:

  ```bash
  php -a
  ```

  

## Синтаксис

При выводе больших блоков текста выход из режима синтаксического разбора PHP обычно более эффективен, чем отправка текста с помощью функций `echo` или `print`. Для обрамления кода допускаются только теги `<?php ?>` и `<?= ?>`.

Закрывающий тег блока PHP-кода автоматически применяет точку с запятой; т.е. нет необходимости ставить точку с запятой в конце последней строки блока с PHP-кодом. 

```php
<?php echo 'Это тест' ?>
```

PHP поддерживает комментарии в стиле 'C', 'C++' и оболочки *Unix* (стиль *Perl*). 

```php
echo "Последний тест"; # Это комментарий в стиле оболочки Unix
```

## Ключевые слова

### `static`

Используется в следующих конструкциях:

- [`static` переменные](#static-переменные)
- [`static`  свойства и методы классов](#static-свойства-и-методы)
- [позднее статическое связывание](#позднее-статическое-связывание)

## Типы

### Список типов

PHP поддерживает десять простых типов.

**Четыре скалярных типа:**

- `boolean`

- `integer`

- `float` (иногда называется `double`)

- `string`

**Четыре смешанных типа:**

- `array`

- `object`

- `callable`

- `iterable`

**Два специальных типа**:

- `resource`

- `null`

### Определение типа переменной

Тип переменной определяется динамически во время выполнения программы в зависимости от контекста использования. Проверка типа возможна следующими способами:

- `var_dump()`

- `gettype()`

```php
$a_bool = TRUE;   // логический
$a_str  = "foo";  // строковый

echo gettype($a_bool); // выводит: boolean
echo gettype($a_str);  // выводит: string
```

- группа функций, вроде `is_int()`, `is_string()`, `is_bool()`


### Перечень типов

#### `bool`

Для определения переменной типа `boolean` необходимо использовать константы `true` или `false`. Обе они регистронезависимы, т.е. можно и так:

```php
$foo = True; 
```

При преобразовании в `bool`, следующие значения рассматриваются как `false`:

- само значение `bool(false)`

- `int(0)`
- `float(0.0)`
- `string("")` и `string("0")`
- `array([])`
- `null`
- объекты `SimpleXML`, созданные из пустых тегов


Все остальные значения рассматриваются как `true` (включая любой `resource` и `nan`).

```php
var_dump((bool)"false");   // bool(true)
```

#### `int`

Для записи в восьмеричной системе счисления, необходимо поставить перед числом `0`. 

```php
$a = 0123;
```

Для записи в шестнадцатеричной системе счисления, необходимо поставить перед числом `0x`. 

```php
$a = 0x1A;
```

Для записи в двоичной системе счисления, необходимо поставить перед числом `0b` 

```php
$a = 0b11111111;
```

Целые числа в PHP всегда со знаком, PHP не поддерживает беззнаковые целые. Размер `int` зависит от платформы: 

- для 32-битной платформы максимальное значение 2<sup>31</sup>-1
- для 64-битной платформы 2<sup>63</sup>-1

Константы:

- `PHP_INT_SIZE` – размер `int` в байтах (как правило 8)
- `PHP_INT_MAX` – максимальное значение `int`
- `PHP_INT_MIN` – минимальное значение.

Если PHP обнаружил, что число превышает размер типа `int` или что в результате операции получается такое число, он будет интерпретировать его в качестве `float`:

```php
$large_number = 9223372036854775808;
var_dump($large_number);                     // float(9.2233720368548E+18)

$million = 1000000;
$large_number =  50000000000000 * $million;
var_dump($large_number);                     // float(5.0E+19)
```

##### Деление

Алгоритм оператора `/`:

- если деление выполняется нацело, то результат `int`
- если нет – `float`. 

```php
var_dump(25/5); # int(5)
var_dump(25/7); # float(3.5714285714286)
```

##### Приведение к `int`

Если привести значение к `int`, оно будет округлено вниз, то есть будет отброшена дробная часть числа. Если оператор или функция требуют `int`, то значение будет автоматически преобразовано в `int`.

```php
var_dump((int)false); // int(0)
var_dump((int)true);  // int(1)
var_dump((int)25.3);  // int(25), округление в меньшую сторону
var_dump((int)fopen('index.php','r')); // int(3), где 3 - это resource_id
```

Можно использовать функции `floor` (в меньшую сторону) и `ceil` ( в большую).

оператор целочисленного деления `intdiv(10,3)=3`



#### `float`

Числа с плавающей точкой могут быть определены следующими синтаксисами:

```php
$a = 1.234; 
$b = 1.2e3; 
$c = 7E-10;
```

В PHP обычно используется формат двойной точности. Рациональные числа, например, `0.1` или `0.7`, не имеют точного внутреннего представления в качестве чисел с плавающей точкой с основанием `2`, вне зависимости от размера мантиссы.  Поэтому они и не могут быть преобразованы в их внутреннюю двоичную форму без небольшой потери точности. Это может привести к неожиданным результатам: например, `floor((0.1+0.7)*10)` скорее всего вернет `7` вместо ожидаемого `8`, так как результат внутреннего представления будет чем-то вроде `7.9999999999999991118....`

##### Разделитель числовых литералов

В числовых литералах (*numeric literal*) – числа с типом `int` и `float` , может использоваться символ подчеркивания `_` для визуального разделения групп цифр. Символ `_` может использоваться в любых формах записи *numeric literal*'ов.

Единственное требование – символ `_` может стоять только между двумя цифрами.

Это верные записи *numeric literal*'ов:

```php
1_000_000_000;  
107_925_284.88; 
135_00;
6.674_083e-11;
0xCAFE_F00D;
```

Это ошибочные записи:

```php
100_;
1_.0;
```



#### `NAN`

Некоторые числовые операции могут возвращать значение, представляемое константой `NAN` (*Not A Number*, не-число). Например, `sqrt(-1)`, `asin(2)` и `acosh(0)`.

Данный результат означает неопределенное или непредставимое значение в операциях с плавающей точкой. 

<u>Сравнение</u>

Так как `NAN` представляет собой неограниченное количество различных значений, то `NAN` не следует сравнивать с другими значениями, включая ее саму. Вместо этого, для определения ее наличия необходимо использовать функцию `is_nan()`.

Особенности сравнения:

- `NAN == true` и `NAN === true`
- во всех остальных случаях `false`, включая `NAN != NAN` и `NAN !== NAN`

```php
$nan = acos(8);

var_dump($nan);         # float(NAN)
var_dump($nan==TRUE);   # bool(true)
var_dump($nan==NAN);    # bool(false)
var_dump(is_nan($nan)); # bool(true)
```

#### `string`

В PHP строки, по умолчанию, рассматриваются как набор символов, каждый из которых – 1 байт. Т.е. PHP стандартно поддерживает 256 символов, и не поддерживает *Unicode*.

##### Способы записи

###### Deprecated

До PHP 7.1 можно было (но не рекомендовалось) записывать строки вообще без кавычек и каких-либо символов:

```php
$str = foo;

var_dump($str);  # string(3) "foo"

                 # C PHP 7.1:
                 # PHP Notice:  Use of undefined constant
```

Строка интерпретируется как константа, и, т.к. она не определена, по умолчанию возвращается ее имя в качестве значения. 

Начиная с PHP 7.1 генерируется предупреждение.

###### Одинарные кавычки

Специальные символы:

- `\'` – одинарная кавычка

- `\\` – обратный слеш

Во всех остальных случаях, обратный слеш `\` – обычный символ, например, `\r` и `\n` выводятся как есть.

Особенности:

- переменные не разворачиваются


- допускается запись в несколько строк

  ```php
  echo 'Вы можете вставлять в строки
  символ новой строки вот так,
  это нормально';
  
  // Выводит: Переменные $expand также $either не разворачиваются
  echo 'Переменные $expand также $either не разворачиваются';
  ```

###### Двойные кавычки

В двойных кавычках PHP распознает следующие специальные символы:

Поправить

| **Последовательность**                      | **Значение**                                                 |
| ------------------------------------------- | ------------------------------------------------------------ |
| `\n`                                        | новая строка                                                 |
| `\r`                                        | возврат   каретки                                            |
| `\t`                                        | горизонтальная   табуляция (HT или 0x09 (9) в ASCII)         |
| `\v`                                        | вертикальная   табуляция (VT или 0x0B (11) в ASCII) (с PHP 5.2.5) |
| `\e`                                        | escape-знак   (ESC или 0x1B (27) в ASCII) (с PHP 5.4.4)      |
| `\f`                                        | подача   страницы (FF или 0x0C (12) в ASCII) (с PHP 5.2.5)   |
| `\\`                                        | обратная   косая черта                                       |
| `\$`                                        | знак доллара                                                 |
| `\"`                                        | двойная   кавычка                                            |
| `\[0-7]{1,3}`                               | последовательность   символов, соответствующая регулярному выражению символа в восьмеричной   системе счисления, который молча переполняется, чтобы поместиться в байт   (т.е. "\400" === "\000") |
| `\x[0-9A-Fa-f]{1,2}`                        | последовательность   символов, соответствующая регулярному выражению символа в шестнадцатеричной   системе счисления |
| `\u{[0-9A-Fa-f]+}`   Например,   `\u{00BC}` | Символ Unicode, задаваемый своим кодом                       |

###### Heredoc

Структура:

- `<<<` + некоторый *identifier* + перевод строки 
- Сам текст
- На отдельной строке тот же самый *identifier* + `;`. Строка *должна* начинаться с закрывающего *identifier*'а, т.е. он должен стоять в первом столбце строки. Cтрока с закрывающим *identifier*'ом' не должна содержать других символов, за исключением точки с запятой `;`. Это означает, что *identifier* не должен вводиться с отступом и что не может быть никаких пробелов или знаков табуляции до или после точки с запятой. Первым символом перед закрывающим *identifier*'ом должен быть символ новой строки. Если это правило нарушено и закрывающий *identifier* не является "чистым", считается, что закрывающий *identifier* отсутствует и PHP продолжит его поиск дальше.

*Identifier* должен соответствовать тем же правилам именования, что и все остальные метки в PHP: 

- содержать только буквенно-цифровые символы и знак подчеркивания
- не должен начинаться с цифры (знак подчеркивания разрешается). 

```php
$bar = <<<EOT
bar
EOT;
```

С PHP7.3 ослаблены требования к структуре закрывающего *identifier*'а, прежде всего чтобы добавить отступы для улучшения читабельности кода. Особенности:

- закрывающий *identifier* может иметь отступ, и в этом случае:
  - отступ может быть сделан или пробелами или табами. Но не одновременно тем и другим.
  - точное количество пробелов/табов, используемых перед закрывающим  *identifier*'ом будет удалено из каждой строки
  - после закрывающего *identifier*'а может стоять `,` и продолжаться выражение.

```php
$foo = ['foo', 'bar', <<<EOT  
  baz  
   -  hello world! --  
  ahoy  
  EOT, 'qux', 'quux'  
];
```



*Heredoc-текст* ведет себя так же, как и строка в двойных кавычках, при этом их не имея.

Возможно использовать heredoc-синтаксис для передачи данных через аргументы функции.

```php
var_dump(array(<<<EOD
foobar!
EOD
));
```

Возможна инициализация статических переменных и свойств/констант класса с помощью синтаксиса *Heredoc*. 

```php
class ClassName
{
    const NAME = <<<STR
...
STR;

    public $property = <<<STR
...
STR;
}
```

Можно также окружать идентификатор *Heredoc* двойными кавычками.

###### Nowdoc

*Nowdoc* для строк в одинарных кавычках то же, что и *Heredoc* для строк в двойных кавычках. *Nowdoc* похож на *Heredoc*, но внутри него не осуществляется никаких подстановок. *Nowdoc* указывается той же последовательностью `<<<`, что используется в *Heredoc*, но последующий за ней идентификатор заключается в одинарные кавычки, например, `<<<'EOT'`. 

```php
$str = <<<'EOD'
EOD;
```

##### Обработка переменных

Если строка указывается в двойных кавычках, либо при помощи *Heredoc*, переменные внутри нее обрабатываются. Если интерпретатор встречает знак доллара `$`, он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. 

```php
$string = 'string';
echo "Символ с индексом -2 равен $string[-2].", PHP_EOL;

// Работает, ключи, заключенные в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределенная константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает
echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает $object->getName(): {${$object->getName()}}";
echo "{$foo->bar}\n";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";

```

С помощью этого синтаксиса также возможен доступ к свойствам объекта внутри строк.

```php
<?php
class foo {
  var $bar = 'I am bar.';
}

$foo = new foo();
$bar = 'bar';
$baz = array('foo', 'bar', 'baz', 'quux');
echo "{$foo->$bar}\n";  		# I am bar.
echo "{$foo->{$baz[1]}}\n";		# I am bar.
?>
```

##### Доступ к символу

К символу в строке следует обращаться с использование квадратных скобок `$str[42]`. Начиная с PHP7.4, доступ к символу через фигурные скобки `$str{42}` – *deprecated*. 

Поддерживаются отрицательные значения смещения – они задают смещение с конца строки. 

```php
"abcdef"[-2]
$string[-1]
```

Доступ к символу через `[]` – означает доступ к соответствующему байту строки. Поэтому:

- его корректно выполнять только для однобайтовых кодировок. 
- для многобайтовых кодировок (*UTF8*) он работает некорректно. 

Попытка записи в смещение за границами строки дополнит строку пробелами до этого смещения. При использовании в качестве смещения `float`, оно будет преобразовано в `int`. Смещение в строке должно задаваться либо `int`, либо `string`, содержащей цифры, иначе будет выдаваться предупреждение. 

При присвоении символу строки, используется только первый символ присваиваемой строки. 

##### Преобразование в строку

- `bool` – значение `true` преобразуется в строку `"1"`, а значение `false` преобразуется в `""` (пустую строку). Это позволяет преобразовывать значения в обе стороны - из булева типа в строковый и наоборот.

- `null` – преобразуется в `""` (пустую строку).

##### Преобразования строк в числа

Если строка не содержит какой-либо из символов `'.'`, `'e'` или `'E'`, и значение числа помещается в пределы целых чисел (определенных `PHP_INT_MAX`), строка будет распознана как целое число `int`. Во всех остальных случаях она считается числом с плавающей точкой `float`.

Значение определяется по начальной части строки. Если строка начинается с верного числового значения, будет использовано это значение. Иначе значением будет `0 `. Верное числовое значение – это одна или более цифр (могущих содержать десятичную точку), по желанию предваренных знаком, с последующим необязательным показателем степени. Показатель степени - это `'e'` или `'E'` с последующими одной или более цифрами.

```php
$foo = 1 + "10.5";                // $foo это float (11.5)
$foo = 1 + "-1.3e3";              // $foo это float (-1299)
$foo = 1 + "bob-1.3e3";           // $foo это integer (1)
```

Начиная с PHP 7.1, выдается предупреждение, если строка не содержит полностью корректное число.

##### Преобразования символа в число

Над символами нельзя выполнять арифметические операции, как в C. 

```php
var_dump('b' - 'a'); # int(0) + Warning: A non-numeric value encountered 
```

Получить код ASCII символа:

```php
ord ( string $string ) : int
```

Получить ASCII символ по коду:

```php
chr ( int $bytevalue ) : string
```





##### Реализация

Строковый тип `string` в PHP реализован в виде массива байт и целого числа, содержащего длину буфера. Поэтому функция `strlen()` имеет временную сложность `O(1)`. Найти длину конкатенированной строки быстрее, сложив длины отдельных строк и не получая саму конкатенированную строку:

```php
# Вместо
$len = strlen($a.$b);
# гораздо быстрее
$len = strlen($a)+strlen($b);
```

Данная природа строкового типа объясняет почему в PHP нет отдельного типа `byte` – строки играют эту роль. Функции, возвращающие нетекстовые данные – например, произвольный поток данных, считываемый из сетевого сокета, – на самом деле возвращают строки. 

Способ кодирования строки определяется тем, как она записана в файле скрипта. Например, строка `"á"` эквивалентна `"\xE1"` (ISO-8859-1), `"\xC3\xA1"` (UTF-8, форма нормализации C), "\x61\xCC\x81" (UTF-8, форма нормализации D). Написание корректных программ, работающих с *Unicode*, означает осторожное избегание функций, которые не работают с *Unicode* и, скорее всего, испортят данные, и использование вместо них корректных функций, обычно из расширений `intl` и `mbstring`.

#### `array`

Ключи массива могут иметь тип `array` или `string`.

При удалении элемента из середины массива ключи не пересчитываются.

При использовании в качестве ключей следующих типов выполняется преобразование:

- `string`, содержащее целое число (исключая случаи, когда число предваряется знаком `+`) будут преобразованы к типу `int`


- `float` будет преобразован к типу `int`, т.е. дробная часть будет отброшена. 
- `bool` будет преобразован к `int` (`0`  или `1`)
- `null` будет преобразован к пустой строке `""`. 
- `array` и `object` не могут использоваться в качестве ключей. 

```php
$array = array(
    1    => "a",
    "1"  => "b",
    1.5  => "c",
    true => "d", # В `$array` попадет только этот ключ
); 

```

Если при объявлении массива повторяется индекс, то более позднее значение переписывает более раннее.

Ключ для элемента массива не является необязательным. Если он не указан, PHP будет использовать предыдущее наибольшее значение ключа типа `int`, увеличенное на 1.

```php
$array = array(
    "a",
    "b",
    6 => "c",
    "d",      # Ключ – 7
); 

```

Вместо квадратных скобок можно использовать фигурные: (т.е. и `$array[42]` и `$array{42}` равнозначны).

Если к переменной, тип которой не `string` или `array`, обратиться как к массиву с помощью `[]`, то будет возвращен `null` без какого либо оповещения об ошибке:

```php
$a = 123;
var_dump($a[1]); # null
```

Можно объявить массив прямо так:

```php
$arr[] = value;
```

Если элементы удаляются из массива, то максимальный номер ключа – тот который существовал когда-то. Например:

```php
$a[5] = 1;
unset($a[5]);
$a[] = 1;
var_dump($a); # array( [6] => 1 )
```

Внутри строки в двойных кавычках `"..."` можно не заключать индекс массива в одинарные кавычки

```php
"Fruit: {$a['fruit']}";  # OK
"Fruit: $a['fruit']":    # Error
"Fruit: $a[fruit]";      # OK
```



##### Преобразование `object` к `array`

При преобразовании `object` к `array`:

- ключами становятся свойства объекта
- к `private` свойствам спереди будет дописано имя класса, к `protected` свойствам спереди будет добавлен символ `*`. Эти добавленные значения с обоих сторон заключаются в нулевые байты.
- значения массива – значения свойств объекта

```php
class A {
    private $A; // Ключ - '\0A\0A'
}

class B extends A {
    private $A; // Ключ - '\0B\0A'
    public $AA; // Ключ - 'AA'
}
```

##### Присваивание по ссылке

При присваивании массива всегда происходит копирование значения. Чтобы скопировать массив по ссылке, нужно использовать оператор ссылки `&`.

##### Сложение массивов

###### Оператор `+`

Оператор `+` возвращает левый массив, к которому был присоединен правый массив. Для ключей, которые существуют в обоих массивах, будут использованы значения из левого массива, а соответствующие им элементы из правого массива будут проигнорированы. Обработка одинаковая и для числовых и для строковых ключей, никакие ключи не перенумеровываются.

```php
$a = ["a" => "apple", "b" => "banana"];
$b = ["a" => "pear", "b" => "strawberry", "c" => "cherry"];

var_dump($a + $b); # array(3) {
                   #.          ["a"] => string(5) "apple"
                   #           ["b"] => string(6) "banana"
                   #           ["c"] => string(6) "cherry"
                   # }
```

###### Функция `array_merge`

```php
array array_merge ( array $array1 [, array $... ] ))
```

Поведение:

-  `string` ключ – ключ и значение переносятся в результат. Если ключи совпадают в нескольких массивах, то каждое последующее значение заменяет предыдущее. 
- `int`  ключ – только значение переносится в результат. В качестве ключей для этих значений будут использованы числа, начиная с нуля. Т.е. `int` ключи не сохраняются вообще.

```php
$a = [5 => 'a'];
$b = [6 => 'c'];

var_dump(array_merge($a, $b)); # array(2) {
                               #    [0] => string(1) "a"
                               #    [1] => string(1) "c"
                               # }

```

###### Unpacking `iterable` внутри `array`

С PHP7.4 сложение `array` и `iterable` (в том числе `array`)  можно реализовать через *unpacking* `iterable` внутри  `array` с использованием многоточия `...` (*spread operator*) (также используется в [1](список-аргументов-переменной-длины))

```php
$array = ['b', 'c'];

var_dump(['a', ...$array, 'd']); # array(4) {
                                 #   [0] => string(1) "a"
                                 #   [1] => string(1) "b"
                                 #   [2] => string(1) "c"
                                 #   [3] => string(1) "d"
                                 # }
```

Можно делать *unpacking* несколько раз:

```php
$arr = [1, 2];
$array = [1, 2];

var_dump([...$array, ...$array]); # array(4) {
                                 #   [0] => int(1)
                                 #   [1] => int(2)
                                 #   [2] => int(1)
                                 #   [3] => int(2)
                                 # }
```

Обработка ключей из `iterable`, для которого выполняет *unpacking*:

- `string` ключи не поддерживаются. Если встречается `string` ключ, выбрасывается `Fatal error`.

  ```php
  $array = ['str' => 'c'];
  [1 => 'a', 'key' => 'b', ...$array]; # Error!
  ```

- `int` ключи игнорируются, переносится только значение. Ключ как будто не указан, поэтому будет взято предыдущее наибольшее значение ключа типа `int`, увеличенное на `1`, `2`,...

  ```php
  $array = [100 => 'c'];
  var_dump([1 => 'a', 'key' => 'b', ...$array]); # array(3) {
                                                 #  [1]   => string(1) "a"
                                                 #  'key' => string(1) "b"
                                                 #  [2]   => string(1) "c"
                                                 # }
  ```

  

Можно делать *unpacking* `iterable` значения, возвращаемого функцией:

```php
function generator() {
	for($i = 0; $i < 2; $i++) {
        yield $i;
    }
}
var_dump([...generator()]); # array(2) {
                            #   [0] => int(0)
                            #   [1] => int(1)
                            # }
```

*Unpacking* `iterable` *by reference* не работает.

```php
[...&$array];  # Error!
```

Преимущества сложения массивов через *spread operator* `...`  над сложением через `array_merge()`:

- сложение через *spread operator* `...`  работает быстрее, чем `array_merge()`, т.к. *spread operator* `...` – языковая конструкция, а `array_merge()` – функция.

- *spread operator* поддерживает любой `iterable`, а *array_merge()* только `array`. В `array_merge()` нужно при необходимости вначале привести `iterable` к `array`:

  ```php
  [ ...$iter1, ...$iter2 ]
  
  # аналогично
  array_merge(iterator_to_array($iter1), iterator_to_array($iter2))
  ```

  

##### Конструкции `list` и `[]`

Конструкции аналогичны, используются для того, чтобы присвоить списку переменных значения за одну операцию. Выполняют т.н. симметричную деструктуризацию массива.

```php
# Получение всех (или несколько первых) элементов массива
list($a, $b, $c) = $array;
[$a, $b, $c] = $array;

# Получение некоторых первых элементов массива
list($a, , $c) = $array;
[$a, , $c] = $array;

list(, , $c) = $array;
[, , $c] = $array;
```

Может использоваться с `foreach`:

```php
foreach ($array as list($a, $b)) 
    /* ... */
}

foreach ($array as [$a, $b]) 
    /* ... */
}
```

Поддерживаются ключи в операторе `list()` и в коротком синтаксисе `[]`. Это позволяет деструктурировать массивы со строковыми и непоследовательными числовыми ключами.

```php
list('a' => $a, 'b' => $b) = $array;
['a' => $a, 'b' => $b] = $array;

# с foreach
foreach ($array as list('a' => $a, 'b' => $b)) 
    /* ... */
}

foreach ($array as ['a' => $a, 'b' => $b]) 
    /* ... */
}
```

C PHP7.3 поддерживается присвоение по ссылке:

```php
list($a, &$b) = $array;
[$a, &$b] = $array;
```



#### `iterable`

К этому смешанному типу относятся:

```
iterable ---> array
          --> Traversable ---> Iterator
                           --> IteratorAggregate
                           --> Generator
```

Хотя `object` допускает `foreach` по `public`  свойствам, он не входит в `iterable`. 

`iterable` итерируется с помощью `foreach` и может быть использован с `yield from` в генераторах.

При использовании в параметрах функции значение по умолчанию может быть `array` типа или `null`:

```php
function foo(iterable $iterable = []) {}
function foo(iterable $iterable = null) {}
```

Использование в качестве типа возвращаемого значения:

```php
function bar(): iterable {
    return [1, 2, 3];
}
function gen(): iterable {
    yield 1;
    yield 2;
    yield 3;
}
```

Для `iterable` реализован [LSP](), т.е. дочерние классы:

- могут «расширять» тип параметра метода с `array` или `Traversable` до `iterable`
- могут «сужать» тип возвращаемого значения с `iterable` до `array` или `Traversable`.

#### `object`



#### `callable`

##### Способы создания callable

1. Анонимная функция ([подробнее](#анонимные-функции)). PHP автоматически преобразует анонимные функции в экземпляры внутреннего класса `Closure`. 

   ```php
   $closure = function() {};
   
   var_dump(is_object($closure));  # true
   var_dump($closure);             # object(Closure)#1 (0) {}
   ```

2. `string`. 

   1. `'functionName'`. 

      В этом случае интерпретатор будет искать обычную, неанонимную функцию с именем, совпадающим с данной строкой и, в случае успеха, вызовет такую функцию. Есть ряд ограничений — нельзя вызвать `isset()`, `empty()` и другие функции, которые фактически являются конструкциями языка. Важная особенность — скобки списка аргументов в таком случае не пишутся!

      Интересно, что функция `create_function()` создает именованную функцию с именем вроде `lambda_1` и возвращает ее имя. И вызов такой функции выполняет аналогично через `string`.

      ```php
      function func() {}
      
      $str = 'func';
      
      $str();
      ```

   2. `'ClassName::method'`

      Используется для вызова статических методов. 

      ```php
      class A {
          static function b() {}
      }
      
      $str = 'A::b';
      
      $str();
      ```

   3. Строки вида:

      - `'parent::method'`–  вызов метода в родительском классе
      - ` ‘self::method'` – вызов метода в том же классе
      -  `'static::method'` – вызов метода через позднее статическое связывание.

      Вызовы этих `callable` не работают через простой синтаксис `$str()`, а работают только через специальную функцию `call_user_func()`. Эта функция позволяет делать вызовы как в статическом контексте (через класс), так и в динамическом (через объект):

      ```php
      class A {
          static function name() {
              return 'A';
          }
      
          static function fSelf() {
              return call_user_func('self::name');
          }
      
          static function fStatic() {
              return call_user_func('static::name');
          }
      
      }
      
      class B extends A {
          static function name() {
              return 'B';
          }
      }
      
      $b = new B;
      
      # 1. parent::name
      #    1.1. Статический вызов
      var_dump(call_user_func(['B', 'parent::name'])); # string(1) "A"
      
      #    1.2. Динамический вызов
      var_dump(call_user_func([$b, 'parent::name'])); # string(1) "A"
      
      # 2. self::name
      var_dump(call_user_func(['B', 'fSelf'])); # string(1) "A"
      
      # 3. static::name
      var_dump(call_user_func(['B', 'fStatic'])); # string(1) "B"
      
      # Вызов через простой синтаксис
      $str = ['B', 'parent::name'];
      var_dump($str()); # PHP Fatal error:  Uncaught Error: Call to undefined method B::parent::f()
      ```

3. `array`. 

   Структура массива:

   ```
   [
   	0 => имя класса,
   	1 => имя статического метода
   ]
   ```

   или

   ```
   [
   	0 => объект,
   	1 => имя статического / динамического метода
   ]
   ```

   Доступ к `protected` и `private` методам разрешен изнутри класса.

   ```php
   class A {
       static function b() {}
   }
   
   $a = new A;
   
   $arr1 = ['A', 'b'];
   $arr2 = [$a, 'b'];
   
   $arr1();
   $arr2();
   ```

4. `object`. 

   Чтобы `object` был `callable` необходимо определить в классе магический метод `__invoke()`:

   ```php
   class A {
       public function __invoke($val) {
           return $val*2;
       }
   }
   
   var_dump((new A)(2)); # int(4)
   ```

##### Способы обращения к функции через `callable`

Подробнее и примеры в [Порядок обработки непрямого доступа](#порядок-обработки-непрямого-доступа)

Возможны два способа обращения к функции через `callable`:

1. Сохранить `callable` в переменную.

2. Не сохранять `callable` в переменную, а вызвать его напрямую 


https://stackoverflow.com/questions/7067536/how-to-call-a-closure-that-is-a-class-variable

https://wiki.php.net/rfc/uniform_variable_syntax

##### Функция `is_callable()`

Функция `is_callable()` проверяет — принадлежит ли переданное ей значение `callable` типу.

Если в классе `Foo` определен метод `__call()` или `__callStatic()`, то `is_callable($foo, 'bar')` или `is_callable(‘Foo’, 'bar')` всегда будет `true`. 

## Манипуляции с типами

Допускаются следующие приведения типов:

- `(int)`, `(integer)`, аналог – функция `intval()`

- `(bool)`, `(boolean)` – приведение к `bool`

- `(float)`, `(double)`, `(real)` – приведение к `float`

- `(string)`

- `(array)`

- `(object)`

## Переменные

Имя переменной чувствительно к регистру. 

По ссылке могут быть присвоены только именованные переменные. 

```php
$bar = &(24 * 7);  # Неверно; 
$bar = &test();    # Неверно.
```

Хорошей практикой считается инициализировать переменные, хотя в PHP это и не является обязательным требованием. Неинициализированные переменные принимают значение в соответствии с контекстом их первого использования: 

- `bool` – значение `false`
- `int` и `float` – `0`
- `string`  (например, при использовании в echo) – `""`
- `array` – `[]`

```php
var_dump($unset_var);                       # NULL
echo($unset_bool ? "true\n" : "false\n");   # false
$unset_int += 25;                           # 0 + 25 => 25
$unset_str .= 'abc';                        # ''.'abc' => 'abc'
$unset_arr[3] = "def";                      # [] + [3 => "def"] => [3 => "def"]
$unset_obj->foo = 'bar';            # object(stdClass)#1 (1) {  ["foo"]=>  string(3) "bar" }
```

Существует только 2 *scope*'s': *local* и *global*.

### Global scope

Глобальные переменные автоматически недоступны в локальной области видимости. Это отличается от языка C, где глобальные переменные автоматически доступны функциям, если только они не были перезаписаны локальным определением:

```php
a = 1; # глобальная область видимости

function test()
{
    echo $a; # выведет пустую строку, переменная неинициализирована
}

test();
```

Фактически, можно рассматривать глобальные переменные как элементы массива `$GLOBALS`. Т.е. `$GLOBALS['variable']` – это непосредственно сама глобальная переменная `$variable`, а не ссылка на нее.

Способы доступа к глобальным переменным:

- создать ссылку на глобальную переменную в локальной области видимости:

  ```php
  global $var;
  ```

  эта конструкция равнозначна:

  ```php
  $var = &$GLOBALS["var"];
  ```

- использовать массив `$GLOBALS`

  ```php
  $GLOBALS['var']
  ```

### Local scope

Только тело `function` формирует *local scope*. Видимость переменных, объявленных внутри `function`, ограничена телом этой `function`. 

Это отличается от *Java* и *C*. Т.к. переменные, объявленные внутри тела циклов (`for`, `while`...), и условных операторов `if` будут доступны за пределами этого блока: 

```php
function func() 
{
  for (...) {
    if(...) {
      $a = 4;  
    }
  }
    
  var_dump($a); # int(4)    
}
```

### `static` переменные

Статическая переменная существует только в локальной области видимости функции, но не теряет своего значения, когда выполнение программы выходит из этой области видимости.

Статические переменные вычисляются во время компиляции скрипта и должны содержать выражения, которые могут быть вычислены в этот момент. Поэтому статические переменные нельзя инициализировать значением функции:

```php
static $int = 0;          # OK
static $int = 1+2;        # OK
static $int = sqrt(121);  # Error  (поскольку это функция)
```

Non-`static` методы в PHP существуют в контексте классов, а не объектов. И только лишь в рантайме происходит подстановка `$this = текущий_объект`. Поэтому статическая локальная переменная существует в единственном экземпляре:

```php
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

$a1 = new A;
$a2 = new A;

$a1->foo(); // 1
$a2->foo(); // 2
$a1->foo(); // 3
$a2->foo(); // 4
```

Наследование класса (и метода) приводит к тому, что всё-таки создается новый метод:

```php
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}

class B extends A {
}

$a1 = new A;
$b1 = new B;

$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2

```

### Ссылки на `global` и `static` переменные

PHP использует определяет `static` и `global` переменные как ссылки. 

Ссылки на глобальные переменные, внедренные через `global`, и `static` переменные являются ссылками на исходные переменные и при присвоении им ссылок, они не изменяются. Они просто указывают на структуру zval и естественно при присвоении им другой ссылки, они начинают указывать на другую структуру ([подробнее](#присваивание-ссылке-ссылки)).

```php
function test_global_ref() {
    global $var;
    $local = 1;
    $var = &$local;
}

function test_global_noref() {
    global $var;
    $var = 1;
}

test_global_ref();
var_dump($var);         # NULL
test_global_noref();
var_dump($var);         # int(1)
```

Т.к. элементы массива `$GLOBALS` – это не ссылки, при присвоении им ссылок, глобальные переменные меняться будут:

```php
function test_global_ref() {
    global $var;
    $local = 1;
    $GLOBALS['var'] = &$local;
}

test_global_ref();

var_dump($var);         # int(1)
```

### Переменные переменных

Создание переменной `$a` и переменной переменной `$hello`:

```php
$a = 'hello';
$$a = 'world';
```

При обращении к переменной переменной в индексе массива необходимо разрешить неоднозначность:

```php
${$a[1]};
${$a}[1];
```

Возможно составление имени свойства через фигурные скобки:

```php
$start = 'b';
$end   = 'ar';
echo $foo->{$start . $end} . "\n";
```

### Переменные при POST запросе

Если в форме присутствуют поля, `name` которых содержит точки `.` или пробелы ` `:

```html
<input name="a.b" />
```

при получении POST запроса PHP преобразует их в знак подчеркивания `_`. 

Значение поля из примера будет доступно через `$_REQUEST['a_b']`.

## Константы

Принято писать имена констант в верхнем регистре `CONSTANT_NAME`

Константу можно определить:

- с помощью функции `define()`

  ```php
  define(string $name, mixed $value);
  define('CONSTANT_NAME', 1);    
  ```

  Такое объявление может находиться в любом месте скрипта.

- с помощью ключевого слова `const`

  ```php
  const CONSTANT_NAME = 1;
  ```

  Такое объявление должно быть размещено в самой верхней области видимости, потому что оно вычисляется при компилировании скрипта.

После того, как константа определена, ее значение не может быть изменено или аннулировано.

Как и суперглобальные массивы, константы доступны в любой области видимости. 

Функции для работы с константами:

- Определить значение константы по имени:

  ```php
  mixed constant(string $name) 
  ```

- Проверить, объявлена константа или нет:

  ```php
  defined(string $name): bool
  ```

В качестве значения константы можно задать:

- скалярное значение:

  ```php
  const CONSTANT = '123';
  ```

- `array`:

  ```php
  const CONSTANT = [1, 2];
  ```

- скалярные выражения:

  ```php
  const CONST_2 = CONST_1 . '123';
  ```

Константы регистрозависимы.

### Магические константы

Есть 9 магических констант, значение которых зависит от места, где они размещены.

| Имя                  | Описание                                                  |
| -------------------- | --------------------------------------------------------- |
| `__LINE__`           | Номер строки в файле                                      |
| `__FILE__`           | Полный путь к текущему файлу                              |
| `__DIR__`            | Директория текущего файла                                 |
| `__FUNCTION__`       | Имя функции                                               |
| `__CLASS__`          | Имя класса, включая пространство имен `ppFinal/ClassName` |
| `__TRAIT__`          | Имя треста, включая пространство имен                     |
| `__METHOD__`         | Имя метода класса                                         |
| `__NAMESPACE__`      | Текущее пространство имен                                 |
| `<ClassName>::class` | Имя класса, включая пространство имен                     |

Магические константы разрешаются во время компиляции.

## Операторы

### Приоритет и ассоциативность оператора

Ассоциативность оператора определяет порядок выполнения операторов с одинаковым приоритетом. Различают:

- лево-ассоциативные операторы – выполняются слева-направо. Например, оператор `-`, поэтому `1 - 2 - 3` сгруппируется как `(1 - 2) – 3`
- право-ассоциативные операторы – выполняются справа-налево. Например, оператор `=`, поэтому `$a = $b = $c` сгруппируется как `$a = ($b = $c)`.
- неассоциативный операторы – если в выражении несколько таких операторов имеют одинаковый приоритет, то выражение выдает ошибку. Например, `1 < 2 > 1` не будет работать, `(1 < 2) > 1` – будет. 

| Оператор       | Ассоциативность | Тип оператора                         |
| -------------- | --------------- | ------------------------------------- |
| `+` `-`  `.`   | левая           | арифметические, строковый             |
| `<<` `>>`      | левая           | побитовые                             |
| `.`            | левая           | строковые                             |
| `??`           | правая          | *null coalescing*                     |
| `?:`           | левая           | тернарный                             |
|                |                 |                                       |
|                |                 |                                       |
|                |                 |                                       |
| `fn () => ...` | правая          | arrow function ([1](#arrow-function)) |



С PHP7.4  оператор конкатенации `. ` имеет приоритет ниже, чем `+`, `-`, желательно использовать скобки для явного указания приоритета:

```php
var_dump( 'a' . 1 + 2 . 'b' ); # string(2) "a3b" 
var_dump( 'a' . (1 + 2) . 'b' ); # string(2) "a3b" 
```

### Порядок обработки непрямого доступа

Непрямой доступ – доступ через другое выражение.

Сложные выражения с непрямым доступом к переменным, свойствам и методам, начиная с PHP7, раскрываются строго слева-направо. Примеры в таблице ниже:

| Выражение             | Интерпретация   PHP 7   |
| --------------------- | ----------------------- |
| `$$foo['bar']['baz']` | `($$foo)['bar']['baz']` |
| `$foo->$bar['baz']`   | `($foo->$bar)['baz']`   |
| `$foo->$bar['baz']()` | `($foo->$bar)['baz']()` |
| `Foo::$bar['baz']()`  | `(Foo::$bar)['baz']()`  |

При этом, начиная с PHP7 допустимы следующие операции над любыми сложными выражениями:

```php
(...)['foo'] # Обращение к элементу массива
(...)->foo   # Доступ к свойству объекта 
(...)->foo() # Доступ к методу объекта
(...)::$foo  # Доступ к статическому свойству объекта
(...)::foo() # Доступ к статическому методу объекта
(...)()      # Вызов callable
(...){}      # Обращение к символу строки
```

Допустимы все приведенные ниже примеры. Они также раскрываются строго слева-направо:

```php
# Поддерживаются цепочки вызовов функций, обращений к элементам массивов,
# вызовов callable, обращений к символам строк и т.д.
$foo()['bar']()
[$obj1, $obj2][0]->prop
getStr(){0}

# поддерживаются цепочки из операторов ::
# для доступа к статическим членам класса
$foo['bar']::$baz
$foo::$bar::$baz
$foo->bar()::baz()

# поддерживаются цепочки вызовов функций ()
# каждая конструкция должна возвращаться callable
foo()()
$foo->bar()()
Foo::bar()()
$foo()()

# Вызов анонимной функции после ее определения
(function() { ... })()

# Вызов анонимной функции, сохраненной в свойстве объекта
($obj->closure)()

# вызов различных типов callable напрямую
[$obj, 'method']()
['Classname', 'method']()
$object->$methodName();    
    
# Обращение к статическим элементам класса    
'Foo'::$bar
```


### Арифметические операторы

- `+$a` (оператор индентичность) – конвертация `$a` в `int` или `float`, что более подходит:

  ```php
  $a = '123';
  var_dump(+$a); # int(123)
  ```

- `$a ** $b` – возведение `$a` в степень `$b`

- `$a / $b` (деление). Возвращает результат типа:

  - `int` – оба значения являются целыми числами (или строками, которые преобразуются в целые числа), которые делятся нацело
  - `float` – для всех остальных случаев

  Для гарантированного целочисленного деления необходимо использовать `intdiv()`.

- `$a % $b` (деление по модулю) – оба операнда преобразуются в целые числа путем удаления дробной части до начала операции. 

    ```php
    var_dump( 5.1 % 2.3 ); # int(1)
    ```

#### Побитовые операторы

- `$a & $b` – И

- `$a | $b` – ИЛИ

- `$a ^ $b` – Исключающее ИЛИ

  Особенности операторов  `&`, `|` и `^`:

  - если оба операнда `string`, то операция будет производиться с кодами ASCII всех символов строки и в результате вернет строку. 
  - во всех остальных случаях, оба операнда будут преобразованы к целому и результатом будет целое число.

  Пример:

  ```php
  echo 12 ^ 9;     // Выводит '5'
  
  echo "12" ^ "9"; // Выводит символ Backspace (ascii 8)
                   // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8
  
  echo "hallo" ^ "hello"; // Выводит ascii значения #0 #4 #0 #0 #0
                          // 'a' ^ 'e' = #4
  
  echo 2 ^ "3"; // Выводит 1
                // 2 ^ ((int)"3") == 1
  
  echo "2" ^ 3; // Выводит 1
                // ((int)"2") ^ 3 == 1
  ```

- `~$a` – отрицание.

  Особенности:

  - Если операнд `string`, то операция будет производиться с кодами ASCII всех символов строки и в результате вернет строку
  - в остальных случаях операнд будет считать целым,  и результат будут целыми.

- `$a << $b` – сдвиг влево.

  Сдвиг влево дополняет число нулями справа, сдвигая в то же время знаковый бит числа влево, что означает что знак операнда не сохраняется.

  ```
  Выражение: 4 << 29 = -2147483648
   Десятичный вид:
    val=4
    res=-2147483648
   Двоичный вид:
    val=00000000000000000000000000000100
    res=10000000000000000000000000000000
   ЗАМЕЧАНИЕ: знаковый бит не был сохранен
  ```

- `$a >> $b` – сдвиг вправо.

  Сдвиг вправо сохраняет копию сдвинутого знакового бита слева, что означает что знак операнда сохраняется.

  ```
  Выражение: -4 >> 1 = -2
   Десятичный вид:
    val=-4
    res=-2
   Двоичный вид:
    val=11111111111111111111111111111100
    res=11111111111111111111111111111110
   ЗАМЕЧАНИЕ: слева была вставлена копия знакового бита
  ```

  Оба операнда и результат выполнения `<<` и ` >>` всегда считаются за целое.

#### Операторы сравнения

| Пример                    | Название                         | Результат                                                    |
| ------------------------- | -------------------------------- | ------------------------------------------------------------ |
| `$a == $b`                | Равно                            | `true`, если `$a` равно `$b` после преобразования типов.     |
| `$a != $b` или `$a <> $b` | Не равно                         | `true`, если `$a` не равно `$b` после преобразования типов.  |
| `$a === $b`               | Тождественно   равно             | `true`, если `$a` равно `$b` и имеет тот же тип.             |
| `$a <=> $b`               | Спейсшип   (космический корабль) | Число типа `integer` меньше, больше или равное нулю, когда `$a` соответственно меньше, больше или равно `$b`. Доступно PHP 7. |

##### Операторы `==` и `===`

При проверке равенства двух переменных, для которых предполагается один и тот же тип и не требуется никаких преобразований, нужно использовать обязательно операторы `===` и `!==`. Операторы `===` и `!==` не выполняют никаких преобразований типов. Также операторы `===` и `!==` работают быстрее, чем `==` и `!=` и функции (вроде `strcmp()`).

При сравнении оператором `==` возможно преобразование одного (или обоих) операндов к другому типу. Сравнение происходит в соответствии со следующей таблицей (по порядку).

| Тип операнда 1                                         | Тип операнда 2                                         | Результат                                                    |
| ------------------------------------------------------ | ------------------------------------------------------ | ------------------------------------------------------------ |
| `null` или `string`                                    | `string`                                               | `null` преобразуется в `""`,   числовое или лексическое сравнение |
| `bool` или `null`                                      | что угодно                                             | Все операнды преобразуется в `bool`, `null` → `false`. При сравнении `false < true` |
| `object`                                               | `object`                                               | [Сравнение `object`](#сравнение-object)                      |
| `string` (содержащее число), `resource`   или `number` | `string` (содержащее число), `resource`   или `number` | Все переводится в `number` и выполняется численное сравнение. Подробнее ниже. |
| `array`                                                | `array`                                                | [Сравнение `array`](#сравнение-array)                        |
| `array`                                                | что угодно                                             | `array` всегда больше                                        |
| `object`                                               | что угодно                                             | `object` всегда больше                                       |

##### Сравнение `string`

При сравнении оператором `== `  операндов `number` с `string` (или два `string`), содержащие числа, каждая `string` будет преобразована в `number`, и сравниваться они будут как `number`. Эти правила также распространяются на оператор `switch`. 

```php
var_dump(0 == "a"); // 0 == 0 -> true
var_dump("1" == "01"); // 1 == 1 -> true
var_dump("10" == "1e1"); // 10 == 10 -> true
var_dump(100 == "1e2"); // 100 == 100 -> true
switch ("a") {
    case 0:
        echo "0";
        break;
    case "a": // Эта ветка никогда не будет достигнута, так как "a" уже сопоставленно с 0
        echo "a";
        break;
}

```

При использовании операторов `===` и `!==`  преобразование типов не происходит, а также проверяется соответствие типов.

При проверке равенства двух строк (если предполагается что они содержат только символы и не требуется преобразований) нужно использовать обязательно операторы `===` и `!==`. Также они работают быстрее, чем `==` и `!=` и функции (вроде `strcmp()`).

При сравнении `string` оператор `==` (если не было преобразования `string` в другой тип) и `===` делают побайтовое сравнение переменных. Поэтому операторы `==` и `===` выполняют *case sensitive* сравнение. 

##### Сравнение `bool` и `null`

Пример сравнения `bool` и `null` с другими типами:

```php
var_dump(1 == TRUE);  // TRUE - то же, что и (bool)1 == TRUE
var_dump(0 == FALSE); // TRUE - то же, что и (bool)0 == FALSE
var_dump(100 < TRUE); // FALSE - то же, что и (bool)100 < TRUE
var_dump(-10 < FALSE);// FALSE - то же, что и (bool)-10 < FALSE
var_dump(min(-100, -10, NULL, 10, 100)); // NULL - (bool)NULL < (bool)-100 это FALSE < TRUE
```

##### Сравнение `float`

Т.к. `float` – число с плавающей запятой, не нужно проверять на равенство два `float`-числа. Подробнее см. [float]().

##### Другие сравнения

Если происходит обращение к несуществующей переменной или несуществующему элементу массива, то вместо него подставляется `null` и выводится `Notice`:

```php
$a = [];
var_dump($a[1] != 2); # bool(true) + Notice
var_dump($a[1] == false); # bool(true) + Notice
```

[Сравнение `NAN`](#nan)

#### Тернарный оператор `?:`

<u>Полная форма</u>

```php
(expr1) ? (expr2) : (expr3) # если `expr1 == true`, то `expr2`, иначе `expr3`
```

В отличии от большинства языков программирования тернарный оператор в PHP является *left-associative*. Вложенная полная форма тернарного оператора может использоваться только с круглыми скобками `()`, явно указывающими приоритет:

```php
$a === $b ? 1 : ($a === $c ? 2 : 3) # OK
$a === $b ? 1 : ($a === $c ? 2 : 3) # Error
```

<u>Короткая форма</u>

```php
(expr1) ?: (expr3)          # если `expr1 == true`, то `expr1`, иначе `expr3`
```

Из короткой формы `?:` можно строить цепочки, возвращается первое значение, которое приводится к `true`:

```php
var_dump(0 ?: 0 ?: 2 ?: 3); # int(2) 
```


#### *Null coalescing operator* `??`

Оператор `??` (объединение с *null*, *null coalescing*) является синтаксическим сахаром:

```php
$a ?? $b;             # то же самое
isset($a) ? $a : $b;
```

Можно строить цепочки, возвращается первое значение, которое не `null`:

```php
var_dump(null ?? null ?? 1 ?? 2); # int(1) 
```

#### Null Coalescing Assignment Operator `??=`

Оператор `??=` (присваивающий оператор объединения с *null*) – синтаксический сахар:

```php
$a ??= $b;

# то же самое, что
# 1.
$a = $a ?? $b;

# или
# 2.
if (!isset($a)) {
    $a = $b;
}
# else - ничего не делается
```



#### Spaceship operator `<=>`

```php
$a <=> $b;
```

Алгоритм:

- если `$a > $b` – вернет `1`
- если `$a < $b` – вернет `-1`
- иначе, если `$a == $b` – вернет `0`

Сравнивать можно любые типы, например:

```php
# int
var_dump(1 <=> 2); # int(-1)

# float
var_dump(1.5 <=> 2.5); # int(-1)

# string
var_dump("a" <=> "b"); # int(-1)

# array
echo [] <=> [1,2,3]; # int(-1)

# object
var_dump((object) ["a" => 1] <=> (object) ["a" => 2]); # int(-1)
```

#### Сравнение `array`

<u>Операторы `==`, `<`, `>`</u>

`$a == $b` – `true`, если `$a` и `$b` содержат одни и те же пары ключ/значение.

Алгоритм:

- Если в первом `array` меньше элементов, возвращается `-1` (`$a < $b`), иначе `1` (`$a > $b`). 
- Если число элементов в `array`'s одинаковое, то сравниваются значения соответствующих ключей в порядке ключей первого `array`:
  - Если ключ из первого `array` не найден во втором – возвращается `null`
  - Если ключ в первом `array` меньше, возвращается `-1` (`$a < $b`), иначе `1` (`$a > $b`).

```php
if (count($op1) < count($op2)) {
    return -1; // $op1 < $op2
} elseif (count($op1) > count($op2)) {
    return 1; // $op1 > $op2
}
foreach ($op1 as $key => $val) {
    if (!array_key_exists($key, $op2)) {
        return null; // не могут быть сравнимы
    } elseif ($val < $op2[$key]) {
        return -1;
    } elseif ($val > $op2[$key]) {
        return 1;
    }
}
return 0; // $op1 == $op2
```

<u>Оператор `===`</u>

`$a === $b` – `true`, если `$a` и `$b` содержат одни и те же пары ключ/значение, в том же самом порядке и того же типа.

```php
$a = array("apple", "banana");
$b = array(1 => "banana", "0" => "apple");
var_dump($a == $b); // bool(true)
var_dump($a === $b); // bool(false)
```

#### Сравнение `object`

Встроенные классы (например, `TDateTime`?) могут определять свои собственные правила сравнения.

- `object1 == $object2`, если они являются экземплярами одного и того же класса, содержат одинаковые свойства с одинаковыми значениями (значения так же сравниваются через `==`)
- `object1 === object2`, если они ссылаются на один и тот же *instance* одного и того же класса.
- `object1 < object2` и `object1 > object2` – для объектов одного класса сравниваются значения соответствующих свойств. (остальные случаи?)

#### Функция `empty`

```php
bool empty ( mixed $var )
```

Возвращает `true`, если аргумент `$var` не существует или его значение равно `false`, т.е. точный эквивалент конструкции:

```php
!isset($var) || $var == false
```

В качестве аргумента `$var` может передаваться выражение, например:

```php
empty(trim($name));
```

[Значения, которые приводятся к `false`](#bool)

#### Конструкция `isset`

```php
bool isset ( mixed $var [, mixed $... ] )
```

Это языковая конструкция, а не функция. Определяет, была ли установлена переменная значением отличным от `null`. Если были переданы несколько параметров, то `isset()` вернет `true` только в том случае, если все параметры определены. Проверка происходит слева направо и заканчивается, как только будет встречена неопределенная переменная.

При использовании `isset()` на недоступных свойствах объекта, будет вызываться перегруженный метод `__isset()`, если он существует.

#### `isset`, `empty` и неопределенные переменные

Если внутри проверяемой переменной используется другая неопределенная переменная, то будет выведена ошибка для всех конструкций: `??`, `empty`, `isset`:

```php
$a = [];
$a[$no] ?? 0;   # Notice!!!
isset($a[$no]); # Notice!!!
empty($a[$no]); # Notice!!!

isset($no, $a[$no]); # OK
```

Но если происходит обращение к несуществующей переменной, или к несуществующему индексу несуществующей переменной, то ошибок нет:

```php
# $a undefined
isset($a['a']);     # OK
empty($a['a'][1]);  # OK
$a['a'][1][2] ?? 0; # OK
```

### Управление ошибками

Может быть выполнено через знак `@` или `set_error_handler()`

### Операторы исполнения

PHP поддерживает один оператор исполнения: обратные кавычки ` `` `.   аналогично использованию функции `shell_exec()`.

### Инкремент `++`, декремент `--`

<u>Инкремент символьных переменных</u>

К символьным переменным можно применять операцию `++`, в то время как операцию `--`применять нельзя.  

Инкрементируются только *ASCII* символы (`a-z` и `A-Z`). Попытка инкремента/декремента других символьных переменных не будет иметь никакого эффекта.

В *C/C++* инкрементирование символа инкрементирует код символа. В PHP инкрементирование строки приводит к получение следующей по смыслу строки (например, для получения следующего символьного идентификатора)

- строка из символов (алгоритм, как в Excel):

  ```
  Y
  Z
  AA
  AB
  ```
  
- строка с цифрами на конце:

  ```
  A8
  A9
  B0
  B1
  ```

  ```
  A09
  A10
  A11
  A12
  ```

### Логические операторы

Перечень в порядке приоритета:

| Оператор    | Значение        |
| ----------- | --------------- |
| `!$a`       | Отрицание       |
| `$a && $b`  | И               |
| `$a || $b`  | ИЛИ             |
| `$a and $b` | И               |
| `$a xor $b` | Исключающее или |
| `$a or $b`  | ИЛИ             |

Смысл двух разных вариантов для операторов `and` и `or` в том, что они работают с различными приоритетами. У `and`, `xor` и `or` приоритет ниже, чем у всех операторов, даже ниже чем у присваивания):

```php
$a = true and false; # Действует как: (($a = true) and false)
var_dump($a);        # bool(true), хотя на первый взгляд должно быть false
```

### `instanceof`

Оператор `instanceof` используется для определения того, является ли текущий объект экземпляром или наследником указанного *class*'а или *interfac*'а.

Может проверяться по:

- название класса или интерфейса:

  ```php
  $a instanceof ClassName
  ```

- строка с названием класса или интерфейса: 

  ```php
  $a instanceof "ClassName"
  ```

- объект некоторого класса:

  ```php
  $a = new MyClass;
  $b = new MyClass;
  
  var_dump($a instanceof $b); // true, $b это объект класса MyClass
  ```

## Управляющие конструкции

### Основной и альтернативный синтаксис

Для операторов `if`, `while`, `for`, `foreach` и `switch` поддерживаются:

- основной синтаксис – с фигурными скобками `{` и `}`:

  ```php
  if (...) {
      ...
  }
  ```

- альтернативный синтаксис – с двоеточием `:` и закрывающим ключевым словом `endif`, `endwhile`, ...

  ```php
  if (...):
      ...
  endif;        
  ```

### `if`,`elseif`, `else`  

`elseif` желательно (по PSR) писать слитно. Тем более, что в альтернативном синтаксисе допустим только `elseif` без пробела.  

### `for`

Синтаксис:

```php
for (expr1; expr2; expr3) {
    ...
}
```

Любое из выражений `exprN` может не указываться, а также состоять из нескольких выражений, разделенных запятой `,`. 

В `expr2` все выражения, разделенные запятыми, вычисляются, но результат берется из последнего. 

Если выражение `expr2` отсутствует, это означает, что цикл будет выполняться бесконечно.

Если `expr2` не будет изменяться во время выполнения цикла, лучше его однократно вычислить до выполнения цикла и не считать на каждой итерации:

```php
$size = count($people);
for($i = 0; $i < $size; $i++) {
    ...
}
```

### `foreach`

Существует 2 синтаксиса:

```php
foreach (array_expression as $value) {
    // ...
}
```

```php
foreach (array_expression as $key => $value) {
	// ...    
}
```

В PHP5 `foreach` двигает внутренний указатель массива, в PHP7 в `foreach` не использует внутренний указатель.

```php
$array = [0, 1, 2];
foreach ($array as &$val) {
    var_dump(current($array)); # все время выводит 0
}
```

При доступе к элементу по ссылке нужно делать так:

```php
foreach ($arr as &$value) {
    ...
}
unset($value);
```

Иначе ссылка `$value` на последний элемент массива останется после окончания цикла `foreach` и возможны ошибки:

```php
foreach ($arr as &$value) {
    ...
}
foreach ($arr as $key => $value) {
    ...
}
// последний элемент $arr[] будет перезаписываться значениями $arr при каждой итерации цикла
```

`foreach` функционально идентично следующей конструкции `while`

```php
foreach ($arr as $key => $value) {
    ...
}
while ([$key, $value] = each($arr)) {
    ...
}
```

Есть возможность обхода массива массивов с распаковкой вложенного массива в переменные цикла:

```php
$a = [
    [12,12,34],
    [543,453,313],
];
foreach($a as [$post_id, $comment_id, $count]) {
    ...    
}
```

`foreach`  *by value*. Изменения, внесенные в массив внутри тела цикла, происходят не в исходном массиве, а в копии массива, т.е. не затронут перебираемые значения.. [Подробнее](#array-zval)

```php
foreach ($array as $val) {
    unset($array); # удаление массива внутри цикла не повлияет на перебор
}
```

`foreach`  *by reference*. Изменения, внесенные в массив внутри тела цикла, происходят в исходном массиве, т.е. затронут перебираемые значения. Причем изменения отслеживаются в процессе итераций.

```php
$array = [0];
foreach ($array as &$val) {
    $array[1] = 1; # добавляет итерацию на еще один элемент
}
```



### `break`

`break` прерывает выполнение конструкций `for`, `foreach`, `while`, `do-while` и `switch`. 

По умолчанию, прерывается ближайшая конструкция:

```php
break;
```

Можно прервать сразу несколько вложенных конструкций, указав числовой аргумент (по умолчанию, `1`):

```php
break 2;
```

### `switch`

В PHP конструкция `switch` считается циклической и внутри нее может использоваться `continue`. Если `continue` не передано аргументов, то он ведет себя аналогично `break`. Если `switch` расположен внутри цикла, `continue 2` продолжит выполнение внешнего цикла со следующей итерации.

Конструкция `switch` использует неточное сравнение (==).

Если не написать `break` в конце секции `case`, PHP будет продолжать исполнять команды следующей секции `case`. В примере будут исполнены все `case` секции:

```php
switch (0) {
    case 0:
        echo "1";
    case 1:
        echo "2";
}
```

Можно указать секцию по умолчанию, которая исполняется, если не сработал ни один `case`:

```php
switch (...) {
    ...
    default:
        ...
}
```

Возможно использование точки с запятой `:` вместо двоеточия `:` после оператора `case`:

```php
switch (...) {
    case 0;
    case 1;
        ...    
}

```

В альтернативном синтаксисе запрещаются любые символы (включая пробел) между `switch` и первым `case`:

```php
<?php switch ($foo): ?> # Error!!!
    <?php case 1: ?>
        ...
<?php endswitch ?>
```

Допускается только перевод строки после `switch`:

```php
<?php switch ($foo): ?>
<?php case 1: ?>
        ...
<?php endswitch ?>
```

### `return`

При вызове `return` без параметров из функции возвращается `null`.

```php
function func() {}

var_dump(func()); # null
```

`return` является специальной конструкцией, а не функцией. Выражение после `return` не надо заключать в скобки. 

### `goto`

```php
goto a;
...

a:
...
```

Требования:

- Целевая метка должна находиться в том же файле.  
- Нельзя выйти за границы функции или метода
- Нельзя перейти внутрь функции или метода
- Нельзя перейти внутрь любой циклической структуры или оператора `switch`, но можно выйти из них.

### `require`, `include`

Единственное отличие `require` и `include`:

- `include`, когда не может найти файл, выдает предупреждение `E_WARNING`
- `require`, когда не может найти файл, выдает фатальную ошибку `E_COMPILE_ERROR`

Может указываться путь:

- абсолютный
- относительный. В этом случае поиск производится в следующем порядке:
  - в папках из директивы `include_path` в `php.ini`
  - в папке с текущим включающим скриптом
  - текущей рабочей директории

Когда файл включается, его код наследует ту же область видимости переменых, что и строка, на которой произошло включение:

- Все переменные, доступные на этой строке во включающем файле будут также доступны во включаемом файле. 
- Все переменные, объявленные во включаемом файле будут доступны во включающем файле.

```php
# 1.php
$var1 = 1;
include "2.php";
var_dump($var2); # int(2)
```

```php
# 2.php
var_dump($var1); # int(1)
$var2 = 2;
```

Так как `include` и `require` – конструкции языка и круглые скобки не обязательны для заключения аргумента.

Если `return` вызывается из глобальной области видимости, выполнение текущего файла скрипта прекращается.  Если текущий файл скрипта был подключен с помощью `include` (`require`), тогда значение переданное `return` будет возвращено в качестве значения вызова `include` (`require`).

```php
# 1.php
return 5;
```

```php
# 2.php
var_dump(include "1.php"); # int(5)
```

Если включаемый файл не содержит `return`, то `include` (`require`) возвращает `1`:

```php
# включение пустого файла
var_dump(include "empty.php"); # int(1)
```

Функции (и классы)? из включаемого файла могут быть использованы во включающем файле, даже если они объявлены после `return`.  

Повторное подключение одного и того же файла с помощью `include` (`require`) выбрасывает ошибку. Необходимо использовать `include_once` (`require_once`).

`include_once` при повторном включении того же файла, ничего не делает и возвращает `true`.

Простейший шаблонизатор на базе `include`:

```php
public function render($view, $params = [])
{
    extract($params);
    ob_start();
    include __DIR__.'/'.$view;
    return ob_get_clean();
}
```

## Функции / методы

Внутри функции может использоваться любой PHP-код, в том числе:

- определение функций
- определение классов (например, *Composer* делает `include` файла внутри функции)

Функции могут вызываться до того, как они были определены в файле. За исключением случая, когда они определены внутри внутри блока, который выполняется в зависимости от условия.  В этом случае такое условие должно сработать раньше вызова функции.

```php
foo();  # Ошибка

if (true) {
    function foo() {}
}

foo();  # OK
```

Все функции и классы PHP имеют глобальную область видимости – они могут быть вызваны вне функции, даже если были определены внутри и наоборот.

```php
function foo()
{
    function bar()
    {
        echo "Я не существую пока не будет вызвана foo().\n";
    }
}

/* Мы пока не можем обратиться к bar(),
поскольку она еще не определена. */
foo();

/* Теперь мы можем вызвать функцию bar(),
обработка foo() сделала ее доступной. */
bar();

```

Отсутствует возможность переопределить или удалить объявленную ранее функцию.

Имена функций регистронезависимы (в отличии от переменных). Тем не менее, более предпочтительно вызывать функции так, как они были объявлены.

### Аргументы функции

Функция принимает список аргументов, разделенных запятой `,`. 

С PHP7.3 можно ставить запятую `,` после последнего аргумента. Это делает вызов функции похожим на синтаксис объявления `array`.

```php
func(
    $arg1, 
    $arg2,
);
```

<u>Нельзя:</u>

- использовать эту возможность в объявлениях функций:

  ```php
  function foo($arg1, $arg2, ) {} # Error!
  ```

- использовать более одной запятой в конце:

  ```php
  func($arg1, $arg2,,); # Error!
  ```

- использовать запятые для пропуска аргументов:

  ```php
  func($arg1, , $arg3); # Error!
  ```

  

Функция, принимающая значение по ссылке:

```php
function func(&$arg) {}
```

Значение по умолчанию функции должно быть константным выражением, а не (к примеру) переменной или вызовом функции/метода класса. Значения по умолчанию могут быть переданы по ссылке

```php
function func(&$arg = 1) {}
```

#### Список аргументов переменной длины

Функция может быть определена с переменным числом аргументов  `...`. Аргументы собираются в `array`:

```php
function func(...$args) {
    var_dump($args); # array(3) {
                     #      0 => 1,
                     #      1 => 2
                     # } 
}

func(1, 2);
```

Многоточие `...`  (*unpacking operator*, оператор распаковки, также *spread operator*, также используется в [1](#unpacking-внутри-array)) можно использовать при вызове функции, чтобы распаковать `iterable` в список аргументов: Можно использовать как замену `call_user_func_array()`:

```php
function add($a, $b) {}
add(...[1, 2]);
```

Можно указать несколько аргументов обычным образом, а в конце добавить `...`. В этом случае `...` поместит в массив только те аргументы, которые не нашли соответствия аргументам в объявлении функции.

Также можно добавить *TypeHinting* перед `...`. В этом случае PHP будет следить, чтобы все аргументы, обработанные многоточием `...`, были указанного типа:

```php
function func(string $a, int ...$b) {}
```

Каждый из списка аргументов может передаваться по ссылке. Для этого перед `...` нужно поставить амперсанд `&`.

```php
function func(int &...$b) {}
```

### Возврат значения

Если нужно вернуть несколько значений из функции, то следует использовать `array`:

```php
function func()
{
    return [0, 1];
}
[$zero, $one] = func();
```

Для того, чтобы функция возвращала результат по ссылке, необходимо:

- использовать оператор `&` при описании функции
- использовать оператор `&` при присвоении переменной возвращаемого значения:

```php
function &returns_reference() {}

$reference =& returns_reference();
```

### TypeHinting

Для аргументов функции и возвращаемого значения могут быть указан *TypeHinting*. 

Допустимые TypeHinting:

| **Тип**                               | **Минимальная версия PHP** |
| ------------------------------------- | -------------------------- |
| Имя класса/интерфейса                 | PHP 5.0                    |
| `self`                                | PHP 5.0                    |
| `array`                               | PHP 5.1                    |
| `callable`                            | PHP 5.4                    |
| `bool`                                | PHP 7.0                    |
| `float`                               | PHP 7.0                    |
| `int`                                 | PHP 7.0                    |
| `string`                              | PHP 7.0                    |
| `iterable`                            | PHP 7.1                    |
| `void` (только возвращаемое значение) | PHP 7.1                    |
| `object`                              | PHP 7.2                    |

#### `void`

Применяется только для возвращаемого значения. 

Функция не должна ничего возвращать:

- не содержать ни одного оператора `return`

- использовать `return` без параметра:

  ```php
  return;
  ```

  

#### Nullable type

Тип аргумента (возвращаемого значения) может быть указан, как обнуляемый (*nullable*) – этот аргумент (возвращаемое значение) могут быть указанного типа или `null`.

Способы указать аргумент, как обнуляемый:

- задать значение по умолчанию `null`:

  ```php
  function f(C $c = null) {}
  ```

- добавить перед типом знак вопроса `?`:

  ```php
  function testReturn(): ?string
  {
      return null;
  }
  
  function test(?string $name) {}
  
  ```

#### Режимы типизации

Возможны два режима типизации:

- слабая
- строгая (*strict*)

<u>Слабая типизация</u>

По умолчанию, используется слабая типизация – PHP будет пытаться привести значения несоответствующих типов к скалярному типу, если это возможно. Например:

- если в функцию передается `int`, а тип аргумента объявлен `string` – функция получит приведенное к `string` значение:

- значение `bool` может быть приведено к `int`:

  ```php
  function a(?int $b) {
      return $b;
  }
  
  var_dump(a(false)); // int(0)
  var_dump(a(true));  // int(1)
  ```

<u>Строгая типизация</u>

Может быть включен режим строгой типизации. Он распространяется на вызовы функций совершенные из файла, в котором этот режим включен, а не на функции, которые в этом файле объявлены.

```php
declare(strict_types=1);
```

В этом режиме в функцию можно передавать (и возвращать) значения только тех типов, которые объявлены для аргументов. Одно исключение: можно передать `int` в функцию, в ожидающую `float`.  Строгая типизация применима только к скалярным типам (т.е. не влияет на приведение классов к родительскому типу?).

### Анонимные функции

Анонимные функции (замыкания) могут быть использованы в качестве значений переменных; PHP автоматически преобразует такие выражения в экземпляры внутреннего класса `Closure`. 

Замыкания могут наследовать переменные из родительской области видимости с помощью конструкции `use`. 

При наследовании по значению, унаследованная переменная является копией и не меняется, при изменении значения в родительской области.

```php
$message = 'hello';
# Наследование по значению
$example = function () use ($message) {
    var_dump($message);
};

# Меняем $message
$message = 'world';
$example(); // выводит hello
```

При наследовании по ссылке, значение переменной в родительской области и в замыкании меняются вместе.

```php
$message = 'hello';
# Наследование по ссылке
$example = function () use (&$message) {
    var_dump($message);
};
# Меняем $message
$message = 'world';
$example(); //выводит world
```

Замыкания могут принимать обычные аргументы

```php
$example = function ($arg) use ($message) {};
```



Сохранение переменной между вызовами возможно так:

```php
function getTotal()
{
    static $count = 0;
    $callback =
        function() use (&$count) {};
    $callback();
}

getTotal();
getTotal();
```

или так:

```php
function getTotal()
{
    $count = 0;
    
    $callback =
        function() use (&$count) {}
    return $callback;
}

$a = getTotal();
$a();
$a();
```

По умолчанию, если анонимная функция объявлена в методе класса, то эта функция будет автоматически связана с этим классом и внутри функции будет доступна переменная `$this`. Если такое автоматическое связывание нежелательно, то можно объявить анонимную функцию как статическую (ниже написано).

```php
class Test
{
    public function testing()
    {
        return function() {
            var_dump($this);
        };
    }
}

$object = new Test;
$function = $object->testing();
$function(); # Выводит object(Test)#1 (0) {}

```

При этом запрещено и вызывает ошибку использование в `use` суперглобальных переменных, `$this` и переменных с теми же именами, что и параметры функции:

```php
$f = function () use ($_SERVER) {};     //ошибка
$f = function () use ($this) {};        //ошибка
$f = function ($param) use ($param) {}; //ошибка
```

Анонимные функции могут быть объявлены статически. Это значит, что эти функции не привязаны к экземпляру класса и в них не доступна переменная `$this`. 

```php
class Foo
{
    function __construct()
    {
        $func = static function() {
            var_dump($this);   # Ошибка
        };
        $func();
    }
};

```

Также статические функции нельзя привязать к объекту во время выполнения.

```php
$func = static function() {
    // тело функции
};
$func = $func->bindTo(new StdClass); # Error

```

### Arrow function

*Arrow function*'s (стрелочные функции), также называются *short closure*'s (короткие замыкания) – сокращенная запись для *anonymous function*'s с неявной привязкой *parent scope by value*.

Цель их введения: упростить синтаксис написания *anonymous function*'s, когда они выполняют простую операцию.

Синтаксис:

```php
fn(parameter_list) => expression;
```

*Arrow function* должна содержать только один *expression*, значение которого является возвращаемым значением *arrow function*, т.е. *expression* как бы вложено в оператор `return`.

*Arrow function* не поддерживают несколько *expression*'s, разделенных через символ `;`,

В `expression` можно использовать переменные из *parent scope*, переменные будут определены *by value*. Т.е. для переменной `$y`  неявно выполняется `use ($y)`. 

В примере ниже, функции `$fn1` и `$fn2` идентичны:

```php
$y = 1;
 
$fn1 = fn($x) => $x + $y;
 
$fn2 = function ($x) use ($y) {
    return $x + $y;
};
```

*Arrow function*'s позволяют использовать *typehinting*, аргументы и возврат значения *by reference*:

```php
fn(): int => $x;
fn(&$x) => $x;
fn&($x) => $x;
```

Как и для обычных *anonymous function*'s:

- *arrow function*'s, объявленные внутри класса будут автоматически связаны с этим классом и внутри функции будет доступна переменная `$this`. 
- *arrow function* может быть объявлена как `static` и тогда, эта функция не будет привязана к классу и в ней не будет доступна переменная `$this`. 

```php
class Test {
    public function method() {
        $fn = fn() => var_dump($this);
        $fn(); // object(Test)#1 { ... }
 
        $fn = static fn() => var_dump($this);
        $fn(); // Error: Using $this when not in object context
    }
}
```

*Arrow function* имеет самый низкий приоритет, так что выражение справа от `=>` всегда будет вычислено вначале.

*Arrow function*'s могут вкладываться друг в друга (право-ассоциативный оператор). Причем в каждый *child scope* пробрасываются переменные из всех *parent scope*'s.

```php
$z = 1;
$fn = fn($x) => fn($y) => $x * $y + $z;
```







### Класс `Closure`

Класс, используемый для создания анонимных функций.

Для привязки функции к объекту могут использоваться:

- динамический метод

  ```php
  public Сlosure::bindTo( object $newthis [, mixed $newscope = "static" ] ): Closure
  ```

  Создает и возвращает новую анонимную функцию с тем же телом функции и связанными переменными, но с другим связанным объектом  (т.е. который в функции будет доступен через `$this`) или новой областью видимости класса (класс, который определяет к каким `protected` (защищенным) и `private` (закрытым) элементам объекта будет иметь доступ анонимная функция). Для статических фунций первый параметр NULL.

  ```php
  $func = function($param) {var_dump($this);}; # функция не член класса
  class Obj {} # класс
  $obj = new Obj;
  $func_bind = $func->bindTo($obj, $obj); # привязка к классу и его области видимости
  $func_bind(1); # object(Obj)#2 (0) { }
  ```

- статический метод

  ```php
  public static bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] ) : Closure
  ```

  ```php
  $func_bind = Closure::bind($func, $obj, $obj);
  ```

Другие функции:

- Привязать функцию к объекту и вызвать, как в *javascript*. Не создавая новый `Closure` через `bindTo`

- ```php
  public Closure::call ( object $newthis [, mixed $arg1, ... ] ) : mixed
  ```

  - `$newthis` – объект для связи с замыканием на время его запуска.

  - `$arg1, ...` – параметры, которые передаются замыканию.

- ```php
  $func->call($obj, 2);
  ```

  При этом запрещено привязывать методы одного объекта к другому объекту, но можно привязать функции за пределами объекта, статические и анонимные функции (лямбда).


- Преобразовать  [`callable`](#callable) (в виде `string`, `array`, ...) → `Closure`:

- ```php
  public static Closure::fromCallable ( callable $callable ) : Closure
  ```
  
  ```php
  $closure = Closure::fromCallable ( [$object, 'method'] );
  ```
  
  

# Классы и объекты

Объекты можно объявлять без скобок:

```php
$a = new A;
```

Объекты допускают объявление динамических свойств, т.е. которых не существует в классе:

```php
$a->b = 5; 
```

## Property

Свойства класса представляются в `zend_object` структурой `HashTable`. Ключи могут иметь только тип `string`.

Свойства при объявлении могут инициализироваться, но они должны быть вычислены во время компиляции

- Корректные определения свойств:

- ```php
  class SimpleClass
  {
      public $var1 = 'hello ' . 'world';
      public $var2 = <<<EOD
  hello world
  EOD;
      public $var3 = 1 + 2;
      public $var6 = myConstant;
  }
  ```

- Некорректное определение *property*'s:

- ```php
  class SimpleClass
  {
      public $var4 = self::myStaticMethod();
      public $var5 = $myVar;
  }
  ```

Доступ к *property* по имени возможен:

- обычным способом:

  ```php
  $object->property
  ```

- с указанием `string` в фигурных скобках `{'...'}`:

  ```php
  $object->{'property'}
  ```

  Если имя *property* содержит недопустимые символы (`-`) или является числом (`0`), то доступ к нему можно получить только через фигурные скобки:

  ```php
  $obj = new stdClass;
  $obj->0 = 1;       # Error
  $obj->{'0'} = 1;   # OK
  $obj->{'a-b'} = 1; # OK
  ```

В PHP 7.4 были введены *typed property*'s (типизированные свойства) – определение *property* может включать *typehint*, кроме типов `void` и `callable`:

```php
class Bar
{
    public string $name;
    public ?int $amount;
    public Foo $foo;
}
```

## Преобразование других типов в `object` 

### Преобразование `array` в `object`

При преобразовании `array` в `object` будет  создан объект:

- названия *property* – ключи массива. Названия *property* (ключи в `HashTable properties`) могут иметь только тип `string`. Ключи с типом `int` преобразуются в `string`.
- значения *property* – значения массива. 

### Преобразование скалярных типов в `object`

Если значение скалярного типа преобразуется в `object`, создается новый экземпляр встроенного класса `stdClass`. Значение переменной будет помещено в поле с именем `scalar`.

```php
$a = 1;
var_dump((object)$a); # object(stdClass)#1 (1) {
                      #   ["scalar"] => int(1)
                      # }
```

`stdClass` это пустой класс, который используется при преобразовании других типов в объект. Он полезен для анонимных объектов, динамических свойств и т. д.

## Вызов метода родительского класса

Для вызова метода родительского класса может использоваться оператор конструкция  `<ParentClass>::<method>()`. Хотя используется оператор `::` для статического вызова, на самом деле вызов выполняется в контексте дочернего класса и переменная `$this`  определена.

```php
class A
{
    function foo()
    {
        var_dump($this);
    }
}

class B extends A
{
    function bar()
    {
        A::foo();
    }
}

$b = new B();
var_dump($b->bar());    # object(B)#1 (0) { }
```

Вызов *non-*`static` метода не родительского класса через оператор `::`  приводит к ошибке и переменная `$this` неопределена.

```php
class A
{
    function foo()
    {
        var_dump($this);
    }
}

class B  # не имеет родительского класса
{
    function bar()
    {
        A::foo();
    }
}

A::foo();    # Notice
$b = new B();
$b->bar();   # Notice

```

## Создание объекта

Существуют следующие способы создания объекта:

- со статическим указанием имени класса 

  ```php
  $object = new ClassName();
  ```

- с динамическим указанием имени класса в виде строки:

  ```php
  $className = 'ClassName';
  $object = new $className(); 
  ```

- в контексте класса, используя ключевые слова `new` и `parent`.

  ```php
  class B extends A
  {
      public function method()
      {
          $object1 = new self;
          $object2 = new parent;
      }
  }
  
  ```

## Наследование

К переопределенным методам или статическим свойствам можно обращаться через `parent::`

## Константы `const`

К константе можно обратить через `self`, имя класса, переменную с именем класса и объект класса:

```php
class MyClass
{
    const CONSTANT = 'значение константы';

    function showConstant() {
        # Обращение через self
        echo self::CONSTANT;
    }
}

# Обращение по имени класса
echo MyClass::CONSTANT;

# Обращение через переменную с именем класса
$classname = "MyClass";
echo $classname::CONSTANT;

# Обращение через объект
$class = new MyClass();
echo $class::CONSTANT;

```

Значение константы должно быть неизменяемым выражением, а не (к примеру) переменной, свойством или вызовом функции:

```php
class foo {
    const TWO = ONE * 2;
    const THREE = ONE + self::TWO;
    const SENTENCE = 'The value of THREE is '.self::THREE;
}
```

Для констант класса можно использовать модификаторы видимости:

```php
class Foo {
    public const BAR = 'bar';
    private const BAZ = 'baz';
}
```

Доступна специальная константа `class`, которой на этапе компиляции присваивается полное имя класса. Полезна при использовании с классами, использующие пространства имен. Так как константа `class` определяется на этапе компиляции, она недоступна на объектах.

```php
namespace foo {
    class Bar {}
    $bar = new Bar;

    var_dump(Bar::class); # string(7) "foo\bar"
    var_dump($bar::class); # Fatal error
}
```

Константы можно переопределять в дочерних классах:

```php
class A
{
    const c = '1';
}
class B extends A
{
    const c = '2';
}
```

## Конструкторы и деструкторы

Конструкторы старого типа, задаваемые функцией с именем класса, объявлены УСТАРЕВШИМИ в PHP 7.0 и будут удалены в будущих версиях.

```php
class Bar {
    public function Bar() {}
}
```

Как правило, конструкторы и деструкторы объявляются с модификатором `public`. Если конструктор объявлен как `protected` или `private`, создание экземпляра класса извне класса запрещено. Это имеет смысл, если необходимо запретить создание объектов через  `new` и объявить статическую функцию – фабрику объектов этого класса (как в [ServiceLocator](#ServiceLocatorКласс с набором конкретных методов))

## Область видимости

К приватному свойству родительского класса в дочернем обращаться нельзя, но после переопределения в дочернем – можно:

```php
class Class1
{
    private $private1 = 'Private1';
    private $private2 = 'Private2';
}

class Class2 extends Class1
{
    // Мы можем переопределить общедоступные и защищенные свойства, но не закрытые
    private $private1 = 'Private3';

    function func()
    {
        var_dump($this->private1);  # string(8) "Private3"
        var_dump($this->private2);  # PHP Notice:  Undefined property: Class2::$private2
    }
}

$obj2 = new Class2();
$obj2->func();
```

Переопределение приватных функций допускается, при этом они не являются полиморфными:

```php
class Bar
{
    public function test() {
        $this->testPrivate();
        $this->testPublic();
    }

    public function testPublic() {   }

    private function testPrivate() {  }
}

class Foo extends Bar
{
    public function testPublic() { }

    private function testPrivate() {  }
}

$myFoo = new Foo();
$myFoo->test(); // Bar::testPrivate
                // Foo::testPublic
```

Объекты, которые имеют общий тип (наследуются от одного класса), имеют доступ к элементам с модификаторами `private` и `protected` друг друга, даже если не являются одним и тем же экземпляром. 

```php
class Test
{
    private $foo;

    private function bar() {}
    public function baz(Test $other)
    {
        // Мы можем изменить закрытое свойство:
        $other->foo = 'hello';
        // Мы также можем вызвать закрытый метод:
        $other->bar();
    }
}
```

## LSP в PHP

Пусть объявлен `class A` (или `interface A`)  с функцией `func()`:

```php
class A
{
    public function func(int $x) {}
}
```

### Ковариантность и контравариантность

<u>Вариантность (*variance*) или совместимость присваивания (*assignment compatibility*) типов</u> – это существующие ограничения и разрешения на возможность подставлять  значение одного типа вместо другого типа, причем эти типы являются *variant* друг другу. 

В PHP *variant* типами являются:

- `ParentClass` → `ChildClass`
- `iterable` → (`array`, `Traversable`, ...  ([1](#iterable))
- `object` → любой `class` 

<u>Инвариантность (*invariance*) типа</u> – это ограничение на подстановку как надклассов, так и подклассов. То есть метод может принимать или возвращать только указанный тип и никакой больше. 

До версии 7.4 PHP поддерживал только *invariant* типы параметров и *invariant* типы возвращаемого значения для методов дочернего класса. Т.е. если метод родительского класса принимает параметр или возвращается значение типа `T`, то этот параметр или возвращаемое значение у дочернего класса также должно быть `T`.

![invariance](https://parshikovpavel.github.io/img/php/invariance.png)

<u>Ковариантность (*covariance*) типа</u> – это  запрет на подстановку надклассов (*overtype*) и возможность на подстановку подклассов. 

В PHP существует ковариантность типа возвращаемого значения (*covariant return type*) в методах дочернего класса (дочерний класс сужает область возвращаемых значений, постусловия могут быть усилены в подклассах):

- метод дочернего класса `B` указывает тип возвращаемого значения, тогда как в классе  `A` тип возвращаемого значения не указан:

  ```php
  class B
  {
      public function func(int $x): int {}
  }
  ```

- методы дочернего класса могут в качестве возвращаемого значения использовать как исходный класс, так и любой его подкласс (*subtype, child type*), но не могут использовать надкласс (*overtype, parent type*).

- ```php
  class OverType {}
  class Type extends OverType {}
  class SubType extends Type {}
  
  class ParentClass {
      function a() : Type {}
      function b() : Type {}
  }
  
  class ChildClass extends ParentClass {
      function a() : SubType {}  # OK
      function b() : OverType {} # PHP Fatal error:  Declaration must be compatible
  }
  ```

  ![covariance](https://parshikovpavel.github.io/img/php/covariance.png)

<u>Контравариантность (*contravariance*) типа</u> – это запрет на подстановку подклассов и возможность на подстановку надклассов. 

В PHP существует контравариантность типа параметра (*contravariant parameter type*) в методах дочернего класса (дочерний класс расширяет область принимаемых параметров, предусловия могут быть ослаблены в подклассах):

- метод дочернего класса `B` опускает (не указывает) тип параметра, тогда как в классе  `A` тип параметра указан :

  ```php
  class B
  {
  	public function func($x);
  }
  ```

- методы дочернего класса могут в качестве параметра использовать как исходный класс, так и любой его надкласс (*overtype, parent type*), но не могут использовать подкласс (*subtype, child type*).

  ```php
  class OverType {}
  class Type extends OverType {}
  class SubType extends Type {}
  
  class ParentClass {
      function a(Type $param) {}
      function b(Type $param) {}
  }
  
  class ChildClass extends ParentClass {
      function a(OverType $param) {}  # OK
      function b(SubType $param) {} # PHP Fatal error:  Declaration must be compatible
  }
  ```

  



![contravariance](https://parshikovpavel.github.io/img/php/contravariance.png)

### Совместимости сигнатур

Сигнатура – это описание функции (метода), включающее в себя:

- модификатор доступа


- имя функции (метода)


- cписок аргументов, где для каждого аргумента указаны:
  - тип
  - имя
  - значение по умолчанию
  - оператор «три точки» (`...$args`)
- тип возвращаемого значения

Сигнатура функции `func()` в `class`'е-наследнике (или `interface`-наследнике) `B` считается <u>совместимой</u> с функцией в `A` (порядок важен, отношение несимметрично!), если:

1. Они полностью совпадают

2. Имеются следующие отличия в аргументах, допустимые согласно *LSP*:

   - `B` добавляет к `A` аргументы, со значениями по умолчанию (предусловия могут быть ослаблены в подклассах). Примеры:

     ```php
     public function func(int $x, $y = null);
     ```

     ```php
     public function foo(int $x, ...$args);
     ```

   - `B` изменяет название аргументов из `A`:

     ```php
     public function func(int $another_name);
     ```

   - `B`  имеет параметры, контравариантного типа (как [выше написано](#ковариантность-и-контравариантность))

   - конструктор `B::__construct()` может быть переопределен с любыми параметрами (получается что LSP нарушается).
   
3. Имеются отличия в возвращаемом значении:

   - `B` имеет ковариантный тип возвращаемого значения (как [выше написано](#ковариантность-и-контравариантность))

4. Имеются отличия в модификаторе видимости: 

   - модификатор видимости  методов должен совпадать или быть менее строгим:

      ```php
      class Bar
      {
          protected function a() {}
      }
      class Baz extends Bar
      {
          public function a() {}
      }
      ```

      

5. Возможна комбинация из нескольких отличий:

  ```php
  function foo(int $x, ...$args): int;
  ```

Перечисленные правила учитываются при `extends` и `implements`

- классов `class`
- интерфейсов `interface`
- `abstract` классов и `abstract` методов

## Статические свойства и методы

К статическому свойству и методу можно обращаться:

- через класс `Foo::`
- через переменную с именем класса `$classname::`
- через объект:
  - при доступе к свойству нужно использовать только оператор `::` (а не`->`).
  - при доступе к методу можно использовать или `::` или `->`

```php
class Foo
{
    public static $property = 'foo';
    static public function method() {}
}

$classname = 'Foo';
$classname::$property; # OK
$foo = new Foo();
$foo::$property;       # ОК

$foo->property;        # Notice, не определено свойство property

$foo->method();  # OK
$foo::method();  # OK
```

При наследовании статическое *property* – это одна и та же переменная для родительского и дочернего класса, если статическое *property* явно не переопределено в дочернем классе

```php
class A {
    static $a;
}
class B extends A {}
A::$a = 10;
var_dump(B::$a); # int(10)
```

## Абстрактные классы

В абстрактном классе можно не объявлять явно абстрактными методы интерфейса. 

```php
interface InterfaceA
{
    # Этот метод будет объявлен абстрактным
    public function methodA();

    # Этот метод в абстрактном классе не объявлен
    public function methodB();
}

abstract class ClassA implements InterfaceA
{
    abstract public function methodA();
}
```

## Интерфейс

Интерфейс может содержать:

- `public` константы. Константы невозможно переопределить в интерфейсе-наследнике или в классе, реализующем данный интерфейс. 

  ```php
  interface SomeInterface
  {
      public const STATUSES = 1;
  }
  ```

- `public` методы без тела, с `;` на конце: 

  ```php
  interface SomeInterface
   {
       public function foo();
       public static function bar(Baz $baz);
   }
  ```

Нельзя включать в интерфейс: 

-  любые свойства


- не `public` методы


- не `public` константы


Интерфейс может наследоваться от множества других интерфейсов (в отличии от классов, которые наследуются от одного интерфейса). Для этого используется ключевое слово `extends`.

```php
interface First
{
    public function foo(int $x);
}

interface Second
{
    public function bar(string $s);
}

interface Third extends First, Second
{
    public function baz(array $a);
}
```

При множественном наследовании интерфейсов воможны конфликты. Для их разрешения:

- сигнатуры нескольких интерфейсов должны совпадать


- сигнатура метода интерфейса, упомянутого в списке первым, должна быть совместима с сигнатурой из последующего интерфейса


В интерфейсе есть предопределенная константа `ThisInterface::class`

Никаких ограничений на использование `static` методов в интерфейсе нет.

```php
interface I
{
    static function f();
}
```

Если класс и наследует `extends` и реализует интерфейс `implements`, то ключевые слова указываются в порядке `extends` – `implements`:

```php
class A extends B implements C {}
```

## Трейт

Трейт позволяет реализовать множественным наследование и смешивание (*mixin*). Невозможно создать самостоятельный экземпляр трейта. В трейте можно обращаться к родительскому классу через `parent`.

Порядок приоритета по убыванию:

- члены из текущего класса 


- методы в трейте


- унаследованные методы.

```php
class Base {
    public function sayHello() {
        echo 'Hello ';
    }
}

trait SayWorld {
    public function sayHello() {
        parent::sayHello();
        echo 'World!';
    }
}

class MyHelloWorld extends Base {
    use SayWorld;
}

$o = new MyHelloWorld();
$o->sayHello();
```

Если два трейта вставляют метод с одним и тем же именем, это приводит к фатальной ошибке в случае, если конфликт явно не разрешен. Необходимо использовать оператор `insteadof` для того, чтобы точно выбрать один из конфликтных методов. Оператор `as` может быть использован для включения одного из конфликтующих методов под другим именем.

При возникновении конфликтов имён методов недостаточно только назначить псевдонимы используя ключевое слово `as`. Сначала обязательно нужно заместить метод используя слово `insteadof`, только потом использовать `as`, так как эта конструкция назначает псевдоним только для замещённых методов.

```php
trait A {
    public function smallTalk() {}
    public function bigTalk() {}
}

trait B {
    public function smallTalk() {}
    public function bigTalk() {}
}



class Aliased_Talker {
    use A, B {
        B::smallTalk insteadof A; # метод B::smallTalk вместо A::smallTalk
        A::bigTalk insteadof B;   # метод A::bigTalk вместо B::bigTalk
        B::bigTalk as talk;       # метод B::bigTalk включить под псевдонимом talk
    }
}
```

Используя синтаксис оператора `as` можно также настроить видимость метода в использующем трейт классе.

```php
trait HelloWorld {
    public function sayHello() {
        echo 'Hello World!';
    }
}

// Изменение видимости класса sayHello
class MyClass1 {
    use HelloWorld { sayHello as protected; }
}

// Создание псевдонима метода с измененной видимостью
class MyClass2 {
    use HelloWorld { sayHello as private myPrivateHello; }
}
```

Аналогично тому, как классы могут использовать трейты, также могут и трейты использовать другие трейты.

```php
trait HelloWorld {
    use Hello, World;
}
```

Трейты поддерживают использование абстрактных методов:

```php
trait Hello
{
    abstract public function getWorld();
}
```

Внутри методов трейта можно определять статические переменные, причем у каждого класса будет свой экземпляр этой переменной.

```php
trait Counter {
    public function inc() {
        static $c = 0;
        print ++$c;
    }
}

class C1 {
    use Counter;
}

class C2 {
    use Counter;
}

$o = new C1(); $o->inc(); // echo 1
$p = new C2(); $p->inc(); // echo 1
```

В трейте можно объявить статическое свойство, при этом в каждом классе, его реализующем, будет свое значение этой переменной:

```php
trait A {
    static $a;
}
A::$a = 10;
```

Если трейт определяет свойство, то класс не может определить свойство с таким же именем, кроме случаев полного совпадения (те же начальное значение и модификатор видимости), иначе будет сгенерирована фатальная ошибка.

```php
trait PropertiesTrait {
    public $same = true;
    public $different = false;
}

class PropertiesExample {
    use PropertiesTrait;
    public $same = true;       // OK
    public $different = true;  // Error
}
```

### Примеры

Трейт для добавления функциональности синглтона.

```php
trait Singleton 
{
   static public $instance;
   
   static public function getInstance()
   {
      if(static::$instance === null) {
         static::$instance = new static();
      }
      
      return static::$instance;
   }
   
   
}

class Application 
{
   use Singleton;
}

$app = Application::getInstance();
```

## Анонимные классы

Анонимные классы используют тогда, когда нужен одноразовый класс и создавать полноценный класс, а потом его объект не имеет смысла.

Используется в форме `new class`, чтобы сразу создать экземпляр анонимного класса.

Способы применения:

- присвоить экземпляр переменной:

  ```php
  $class = new class {function echo() {}};
  $class->echo();
  ```

- передать экземпляр в качестве параметра:

  ```php
  $app->setLogger(new class implements Logger {
      public function log(string $msg) {
          echo $msg;
      }
  });
  ```

Анонимные классы обладают всеми возможностями обычных классов:

- передавать аргументы в конструкторы
- наследовать другие классы
- реализовывать интерфейсы
- использовать трейты

```php
class SomeClass {}
interface SomeInterface {}
trait SomeTrait {}

$object = new class(10) extends SomeClass implements SomeInterface {
    use SomeTrait;
    public function __construct($num) {}
};
```

Все объекты, созданные одной и той же декларацией анонимного класса, являются объектами одного класса. Анонимным классам присваиваются имена движком PHP .

```php
function f()
{
    return new class {};
}

$a = f();
$b = f();

assert($a == $b);
```

## Перегрузка и магические методы

Перегрузка в PHP – возможность динамически «создавать» свойства и методы через магические функции. Все методы перегрузки должны быть объявлены как `public`. Аргументы в магические методы не могут  передаваться *by reference*. 

### `__construct()` и `__destruct()`

### `__call()` и `__callStatic()`

```php
public __call ( string $name , array $arguments ) : mixed
```

Запускается при вызове недоступных методов в контексте объекта.

```php
public static __callStatic ( string $name , array $arguments ) : mixed
```

Запускается при вызове недоступных методов в статическом контексте.

### `__get()` и `__set()`

 ```php
public __set ( string $name , mixed $value ) : void
 ```

Вызывается при записи данных в недоступные свойства.

```php
public __get ( string $name ) : mixed
```

Вызывается при чтении данных из недоступных свойств

Можно использовать в нескольких присвоениях подряд. При этом игнорируется возвращаемое `__set` значение и не вызывается `__get`:

```php
$a = $obj->b = 8;
```

При обращении к приватным свойствам, происходит вызов `__get` и `__set`:

```php
class A
{
    private $pr = 1;

    public function __get($name) {}
    public function __set($name, $value) {}
}
$a = new A;
$a->pr = 2; //вызывается __set
```

### `__isset()` и `__unset()`

```php
public __isset ( string $name ) : bool
```

Вызывается при использовании `isset()` на недоступных свойствах.

```php
public void __unset ( string $name )
```

Выполняется при вызове `unset()` на недоступном свойстве.

### Сериализация

Есть три взаимоисключающих способа управления сериализацией:

- `__sleep()` и `__wakeup()` ([1](#sleep-wakeup))
- `__serialize()` и `__unserialize()` ([1](#serialize-unserialize))
- [Интерфейс `Serializable`](#Serializable)

#### `__sleep()` и `__wakeup()`

```php
public __sleep ( void ) : array
```

Выполняется перед `serialize()`. Метод должен подготовить объект к выгрузке (завершить работу с данными, записать нужные значения в *property*'s) и возвращает массив с именами всех *property*'s объекта, которые должны быть сериализованы. 

```php
public __wakeup ( void ) : void
```

Вызывается после `unserialize()` . Может использоваться для восстановления соединений с базой данных.

```php
class Connection
{
    private $link, $dsn, $username, $password;

    public function __sleep()
    {
        return ['dsn', 'username', 'password'];
    }

    public function __wakeup()
    {
        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
}

```

#### `__serialize()` и `__unserialize()`

```php
public __serialize ( void ) : array
```

Вызывается перед `serialize()`. Метод должен вернуть `array` с данными для сериализации.

```php
public __unserialize ( array $data ) : void
```

Вызывается после `unserialize()`. Методу будет передан восстановленный массив, который был возвращен из `__serialize()`. Затем он может вручную восстановить свойства объекта из этого массива.

```php
class Connection
{
    protected $link;
    private $dsn, $username, $password;

    public function __serialize(): array
    {
        return [
          'dsn' => $this->dsn,
          'user' => $this->username,
          'pass' => $this->password,
        ];
    }

    public function __unserialize(array $data): void
    {
        $this->dsn = $data['dsn'];
        $this->username = $data['user'];
        $this->password = $data['pass'];

        $this->link = new PDO($this->dsn, $this->username, $this->password);
    }
}
```

### `__toString()`

```php
public __toString ( void ) : string
```

Позволяет классу решать, как он должен реагировать при преобразовании в строку. 

### `__invoke()`

```php
__invoke ([ $... ] ) : mixed
```

Вызывается, когда скрипт пытается выполнить объект как функцию.

```php
class CallableClass
{
    public function __invoke($x)
    {
        var_dump($x);
    }
}
$obj = new CallableClass;
$obj(5);                       # int(5)
var_dump(is_callable($obj));   # bool(true)

```

### `__set_state()`

```php
static __set_state ( array $properties ) : object
```

Статический метод, который вызывается для тех классов, которые экспортируются функцией `var_export()`.

Функция `var_export()` выводит или возвращает интерпретируемое строковое представление переменной:

```php
/**
 * @param mixed $expression Переменная, которую необходимо экспортировать.
 * @param bool $return Если TRUE var_export() вернет представление переменной вместо его вывода
 * @return mixed Если return=TRUE => представление переменной, иначе NULL.
 */
mixed var_export ( mixed $expression [, bool $return = FALSE ] )
```

 Функция аналогична `var_dump()` за одним исключением: возвращаемое представление является полноценным PHP-кодом.  При применении этой функции к объекту PHP-код будет содержать вызов метода `__set_state()`.

```php
/* Пример экспорта и импорта объекта */
class A
{
    public $var;

    public static function __set_state($an_array)
    {
        $obj = new A;
        $obj->var = $an_array['var'];
        return $obj;
    }
}

$a = new A;
$a->var = 5;

eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(
                                            //    'var' => 5,
                                            // ));
var_dump($b);   # object(A)#2 (1) {
                #    ["var"]=>
                #      int(5)
                # }
```

### `__clone()`

[Клонирование объектов](#клонирование-объектов)

### `__debugInfo()` 

```php
__debugInfo ( void ) : array
```

`_debugInfo()` вызывается функцией `var_dump()` и должен вернуть для вывода массив свойств объекта и их значений. Если этот метод не определен, тогда будут выведены все `public`, `protected` и `private` свойства объекта.

```php
class C {
    private $prop;

    public function __construct($val) {
        $this->prop = $val;
    }

    /* Вместо свойства prop будет выведено propSquared */
    public function __debugInfo() {
        return [
            'propSquared' => $this->prop ** 2,
        ];
    }
}

var_dump(new C(42)); # object(C)#1 (1) {
                          #    ["propSquared"]=>
                          #     int(1764)
                          # }
```

## Итерирование

При итерации объекта, итерируются все видимые в данном контексте свойства (если снаружи итерирование – `public`, изнутри – также `private` и `protected`).

Подробнее про [`Iterator`](#Iterator), [`Traversable`](#Traversable), [`IteratorAggregate`](#IteratorAggregate).

В SPL включено несколько встроенных классов итераторов, которые позволяют обернуть в объект-итератор некую другую сущность, например `array`:

```php
$iterator = new ArrayIterator([1, 2, 3]);
foreach ($iterator as $key => $val) {
    // ... 
}
```

Список готовых обёрток-итераторов включает:

- `DirectoryIterator` – итерирует по списку файлов в заданной директории
- `RecursiveArrayIterator` – рекурсивный обход вложенных массивов
- `FilterIterator` – обход с отбрасыванием нежелательных значений
- ...

Эти обертки реализуют `Iterator`, а потому могут быть задекорированы внутри `IteratorAggregate`:

```php
class Example implements IteratorAggregate
{
    protected $storage = [];
    /* Дополнительная функция для добавления элемента */
    public function set($key, $val)
    {
        $this->storage[$key] = $val;
    }
    /* Дополнительная функция для получения значения элемента */
    public function get($key)
    {
        return $this->storage[$key];
    }
    /* Функция, требующаяся согласно интерфесу IteratorAggregate */
    public function getIterator(): Traversable
    {
        return new ArrayIterator($this->storage);
    }
}
```

Диаграмма классов для `iterable`:

```
iterable ---> array
          --> Traversable ---> Iterator
                           --> IteratorAggregate
                           --> Generator
```

`object`, допускающие нативную итерацию по своим видимым свойствам в `iterable` не вошли. 

## Ключевое слово `final`

Ключевое слово `final` можно ставить перед *method*'ом или перед *class*'ом. 

`final` перед *method*'ом означает, что *method* нельзя переопределить в дочерних классах. 

```php
class BaseClass {
    final public function moreTesting() {}
}
```

`final` перед *class*'ом означает, что он не может быть унаследован. 

```php
final class BaseClass { }
```

## Клонирование объектов

```php
__clone ( void ) : void
```

Вызывается для вновь склонированного объекта, для его дополнительной настройки

```php
class A {}

class B
{
    public $object1;
    public $object2;

    function __clone()
    {
        $this->object1 = clone $this->object1;
    }
}

$obj1 = new B();

$obj1->object1 = new A();
$obj1->object2 = new A();

$obj2 = clone $obj1;

/* object2 обоих объектов указывают на один экземпляр, а object1 на разные */
var_dump($obj1); # object(B)#1 (2) {
                 #   ["object1"] => object(A)#2 (0) {}
                 #   ["object2"]=>  object(A)#3 (0) {}
                 # }

var_dump($obj2); # object(B)#4 (2) {
                 #   ["object1"] => object(A)#5 (0) {}
                 #   ["object2"] => object(A)#3 (0) {}
                 # }
```

## Позднее статическое связывание

Позднее статическое связывание (*LSB*, *Late Static Binding*) – противоположность «раннему статическому связыванию» (через `self::`).

Функция:

```php
get_called_class ( void ) : string
```

возвращает имя класса, полученное с помощью *LSB*, в контексте которого в данный момент работает код.

Статические ссылки на текущий класс `self::` и `__CLASS__`, вычисляются в том месте, где они были определены.

Можно использовать `static::` и для вызова нестатических методов. Отличие от использование `$this` в том, что ссылка через `$this` на `private` метод приводит к вызову метода в родительском классе, ссылка на приватный метод через `static::` всегда приводит к его вызову в дочернем классе из контекста родительского, и в случае приватного метода выдаст ошибку:

```php
class A
{
    private function foo() {}

    public function test()
    {
        $this->foo();  # Вызов A::foo(), Success
        static::foo(); # Вызов C::foo(), Fatal error: Uncaught Error: Call to private method C::foo() from context 'A'
    }
}

class C extends A
{
    private function foo() {}
}

$c = new C();
$c->test();
```

В статическом контексте вызовы через `parent::` и `self::` перенаправляют в вызываемую функцию информацию вызова и поэтому вызов через `static::` сработает как ожидается на дочернем классе. Вызов с указанием названия родительского класса `A::` такую информацию не перенаправляет:

```php
class A
{
    static public function f1()
    {
        static::f2();
    }

    static public function f2()
    {
        print "A";
    }
}

class B extends A
{
    static public function test()
    {
        A::f1();      //print А
        parent::f1(); //print B
        self::f1();   //print B
    }

    static function f2()
    {
        print "B\n";
    }
}
```

## Сериализация

Функция `serialize()` возвращает строковое представление объекта и сохранит имя класса и все его свойства, однако методы не сохраняются. Для того, чтобы иметь возможность сделать `unserialize()` для объекта нужно, чтобы класс этого объекта был определен заранее. 

```php
class Name {
    public $property = 1;

    public function method() {}
}

$a = new Name;
var_dump($a);  # object(Name)#1 (1) {
               #    ["property"]=>
               #       int(1)
               # }

$s = serialize($a);

echo $s; # O:4:"Name":1:{s:8:"property";i:1;}

$b = unserialize($s);

var_dump($b); # object(Name)#2 (1) {
              #    ["property"]=>
              #       int(1)
              # }
```

# Namespace

Это один из способов инкапсуляции элементов, который предоставляет возможность группировать логически связанные `class`, `trait`, `interface`, `function`, `const`. 

```php
namespace Name;

const A = 1;
class B { /* ... */ }
function c() { /* ... */  }
```

Объявление `namespace` должно идти первым в файле. Теоретически одинаковое пространство имен может быть разнесено на несколько файлов.

В одном файле можно объявить несколько пространств имен:

```php
namespace MyProject;
...
namespace AnotherProject;
...
```

либо так более наглядно:

```php
namespace MyProject {
  ...
}
namespace AnotherProject {
  ...
}
```

Размещение в одном файле кода в пространстве имен и в глобальном пространстве:

```php
namespace MyProject {
  ...
}

namespace {       // глобальный код
  ...
}
```

Для функций и констант, PHP будет прибегать к глобальным функциям или константам, если функция или константа не существует в пространстве имен.

```php
namespace A\B\C;

const Constant = 45;
function func() {}

echo Constant;        // echo \A\B\C\Constant
echo GlobalConstant;  // echo \GlobalConstant

echo func();          // echo \A\B\C\func()
echo time()           // echo \time()

```

**Динамический доступ.** При динамическом доступе (т.е. через строковую переменную) к элементам в пространстве имен необходимо использовать абсолютное имя. Если пространство имен не указано, то обращение идет к глобальному элементу (классу, функции, константе).  Начальный обратный слэш не является необходимым.

```php
namespace namespacename;

class classname{}

function funcname() {}

const constname = "namespaced";

$a = '\namespacename\classname';
$obj = new $a;
$a = 'namespacename\classname';
$obj = new $a;
$b = 'namespacename\funcname';
$b();
$b = '\namespacename\funcname';
$b();
echo constant('\namespacename\constname'), "\n";
echo constant('namespacename\constname'), "\n";
```

Константа `__NAMESPACE__`  содержит имя текущего пространства, в глобальном пространстве содержит пустую строку.

```php
namespace XXX\YYY {
    var_dump(__NAMESPACE__); // string(7) "XXX\YYY"
}

namespace {
    var_dump(__NAMESPACE__); // string(0) ""
}
```

Ключевое слово `namespace`  используется для явного запроса элемента из текущего пространства имен:

```php
/* В пространстве имен MyProject */
namespace MyProject {
  blah\mine();            // вызывает функцию MyProject\blah\mine()
                          // то же самое что и
  namespace\blah\mine();  // вызывает функцию MyProject\blah\mine()
}

/* В глобальном пространстве */ 
namespace {
  namespace\func(); // вызывает функцию  \func() 
}
```

## Импортирование и создание *alias*'а

Импортирование и создание *alias*'а выполняется с помощью оператора `use`. 

Поддерживаются *alias*'ы: 

- имени `class`'а, `interface`'а, `trait`'а

  ```php
  use Namespace\ClassName as AnotherClassName;
  
  # аналогично Namespace\ClassName as ClassName
  use Namespace\ClassName;
  
  # создание псевдонима глобального класса
  use ArrayObject;
  ```

- имени *namespac*'а:

  ```php
  use Full\NamespaceName as AnotherNamespaceName;
  
  # аналогично Full\NamespaceName as NamespaceName
  use Full\NamespaceName;
  ```

  После создания *alias*'а его можно использовать как часть полного имени класса:

  ```php
  NamespaceName\Sub\func(); # вызывает функцию Full\NamespaceName\Sub\func
  ```

- имени `function`:

  ```php
  use function Namespace\functionName as func;
  use function Namespace\functionName;
  ```

- имени `const`:

  ```php
  use const Namespace\CONSTANT;
  ```

При импортировании и создании *alias*'а  не нужно и не рекомендуется указывать начальный `\` в полном имени *namespac*'а.

В одном операторе `use` можно задать несколько импортирований (но не рекомендуется по PSR):

```php
use Namespace\ClassName as AnotherClassName, Full\NamespaceName;
```

Импорт выполняется во время компиляции. Поэтому при использовании динамического непрямого доступа к `class`, `function` или `const` необходимо использовать абсолютные путь.

```php
use Namespace\ClassName;
$obj = new ClassName; # создает объект класса \Namespace\ClassName
$a = 'ClassName';
$obj = new $a;      // создает объект класса \Namespace\ClassName

```

Ключевое слово `use` должно быть указано в самом начале файла (в глобальной области) или внутри объявления пространства имен, т.к. импорт выполняется во время компиляции, а не во время исполнения. Ниже показано недопустимое применение ключевого слова `use`

```php
namespace NamespaceName;

function func()
{
    use NamespaceName\Sub; # Parse error
}

```

Правила импорта задаются на каждый файл отдельно и присоединяемые файлы НЕ будут наследовать правила импорта из родительского файла. 

`class`, `function` и `const` можно группировать в одном операторе `use`.

```php
use Some\Namespace\{ClassA, ClassB, ClassC as C};
use function Some\Namespace\{func1, func2, func3};
use const Some\Namespace\{ConstA, ConstB, ConstC};
```

C PHP7.2 разрешена завершающая запятая в списке сгруппированных классов, функций и констант в `use` (как в списке элементов `array`):

```php
use Namespace\{
    ClassA,
    ClassB,
    ClassC,
};
```

При использование `use` осуществляется вставка в таблицу импорта классов, `use function` – таблицу импорта функций, `use const` – таблице импорта констант. Эти таблицы импорта различны, т.е. могут быть классы, функции и константы с одинаковым названием.

# Ошибки

Если PHP установлен как модуль *Apache*, то ошибки PHP попадают также (в не зависимости от настроек PHP) в лог файл Apache, который настраивает в конфиге виртхостов:

```
ErrorLog  c:/php/home/fishki_files/logs/s_error_log
```

Выводимые ошибки указываются в параметре `error_reporting`  в конфигурации `php.ini`:

```
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT
```

Также значение директивы `error_reporting` можно задать во время выполнения с помощью функции  `error_reporting()`.

```php
// Добавлять сообщения об указанных ошибках
error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);

// Добавлять сообщения обо всех ошибках, кроме E_NOTICE
error_reporting(E_ALL & ~E_NOTICE);
```

На стадии разработки параметр `error_reporting` ставят в  `E_ALL`.  

Параметр `display_errors` определяет, включать ли данные ошибки в вывод скрипта или нет. В режиме отладки должен быть включен. 

```
; в php.ini
display_errors = On

# в коде
ini_set ( 'display_errors', true );
```

Включить вывод ошибок в лог можно с помощью параметра `log_errors`:

```ini
log_errors = On
```

Файл лога указывается в параметре `error_log`. 

```ini
error_log = php_errors.log
```

Задать пользовательскую функцию, как обработчик ошибок в скрипте:

```php
/**
 * @param callable $error_handler Пользовательская функция-обработчик ошибок
 * @param int $error_types Какие ошибки будут показаны в отчете
 */
mixed set_error_handler ( callable $error_handler [, int $error_types = E_ALL | E_STRICT ] )


```

При возникновении фатальных ошибок `E_ERROR` и фатальных ошибок с возможностью обработки `E_RECOVERABLE_ERROR` будет выброшено исключение, а не произойдет завершение скрипта. Другие виды ошибок, такие как `Warning` и `Notice` исключение не выбрасывают. Исключения выброшенные при ошибках `E_ERROR` и `E_RECOVERABLE_ERROR` не наследуются от `Exception`, чтобы предотвратить обработку этих ошибок кодом, написанным под PHP5. Они являются экземпляром нового класса `Error`. 

![Throwable](https://parshikovpavel.github.io/img/php/Throwable.png)

Подклассы `Error`:

- `TypeError` – выбрасывается, когда аргументы метода или возвращаемое значение не совпадает с объявленным типом.

  ```php
  function add(int $left, int $right) {}
  
  try {
      $value = add('left', 'right');
  }
  catch(TypeError $e)
  {
      echo 'Parsing error!';
  }
  ```

- `ParseError` – выбрасывается, когда подключаемый (путем `include`/`require`) файл или код в `eval` содержит ошибки синтаксиса. 

- `AssertionError` – выбрасывается когда условие, заданное методом `assert()` не выполняется

# Исключения

Исключение можно "выбросить" при помощи `throw`, и можно  "поймать" оператором `catch`. Каждый блок `try` должен иметь как минимум один соответствующий ему блок `catch` или `finally`.

Генерируемый объект должен наследоваться от `Throwable`. 

```php
try {
    throw new Exception('Some Exception');
} catch (Exception $e) {
    echo 'Выброшено исключение: ',  $e->getMessage(), "\n";
} finally {
    echo "Блок finally.\n";
}
```

Если исключение не будет перехвачено, PHP выдаст сообщение об ошибке, если не был определен обработчик ошибок при помощи функции `set_exception_handler()`. После вызова `$exception_handler` выполнение будет остановлено.

```php
/**
 * @param callable $exception_handler Функция, которая будет вызываться каждый раз, когда выбрасывается неперехватываемое исключение.
 * @return callable Предыдущий заданный обработчик или NULL в случае ошибки.
 */
callable set_exception_handler ( callable $exception_handler )
```

Блок `catch` может принимать несколько типов исключений, эти типы разделяются символом `|`. 

```php
try {
    ...
} catch (FirstException | SecondException $e) {
    ...
}
```

Блоки `try` можно вкладывать друг в друга. Для того чтобы обработку исключения передать из вложенного блока на уровень выше, исключение нужно выбросить повторно:

```php
try {
    try {
        throw new Exception('foo!');
    } catch (Exception $e) {
        // повторный выброс исключения
        throw $e;
    }
} catch (Exception $e) {
    var_dump($e->getMessage()); # string(4) "foo!"
}
```

## Наследование исключений

Определенный пользователем класс исключения должен быть определен, как класс расширяющий (наследующий) встроенный класс Exception.  При наследовании исключений в переопределяемом конструкторе, необходимо вызвать конструктор `parent::__construct()`. Метод `__toString()` может быть переопределен, что бы обеспечить нужный вывод, когда объект преобразуется в строку.

```php
/** Cвой класс исключения */
class MyException extends Exception
{
    /* Переопределение конструктора, возможно с другими параметрами, т.к. конструктор это позволяет */
    public function __construct($message = null, $code = 0, Exception $previous = null)
    {
        // некоторый код
        echo "MyException::construct\n";
        parent::__construct($message, $code, $previous);
    }

    // Переопределим строковое представление объекта.
    public function __toString() {
        return __CLASS__ . ": [{$this->code}]: {$this->message}\n";
    }

    public function customFunction() {
        echo "MyException::customFunction\n";
    }
}

try {
    throw new MyException('Message exception', 1);
}
catch(MyException $e) {
    echo $e;
    $e->customFunction();
}
```

Последний параметр конструктора предназначен для указания ссылки на предыдущее исключение и используется при создания цепочки исключений. При обработке исключения, используя метод `Exception::getPrevious()`, можно пройтись по всей цепочке исключений.

```php
try {
    try {
        # Вложенное исключение
        throw new InvalidArgumentException("Exception1", 1);
    } catch(Exception $e) {
        # Повторное выбрасывание с указанием $previous 
        throw new BadMethodCallException("Exception2", 2, $e);
    }
} catch(Exception $e) {
    # Проход по цепочке исключений
    do {
        printf("%s:%d %s (%d) [%s]\n", $e->getFile(), $e->getLine(), $e->getMessage(), $e->getCode(), get_class($e));
    } while($e = $e->getPrevious());
}
```

#  `Generator`

*Generator* (генератор, сопрограмма, «корутина», *coroutine*) — подпрограмма, которая дополнительно поддерживает множество входных точек (а не одну, как обычная подпрограмма), остановку и продолжение выполнения с сохранением определённого положения.

Генераторы предоставляют лёгкий способ реализации простых итераторов без сложностей, связанных с реализацией интерфейса `Iterator`. Пишется функция-генератор, которая вместо возвращения единственного значения может делать `yield` столько раз, сколько необходимо сгенерировать значений. 

<ins>Пример</ins>: реализация в виде генератора функции `range()`, которая генеририрует массив значений из диапазона. Использование генератора позволяет не создавать огромных массивов, занимая память, а только хранить текущее состояние генератора при переборе:

```php
function mrange($start,$end) 
{
   for($i = $start; $i<$end; $i++) {
      yield $i;
   }
}

$generator = mrange(10,20);

var_dump($generator);          # object(Generator)#1 (0) {}

foreach($generator as $number) {
   echo $number."\n";
}
```

Когда функция генератор будет вызвана первый раз, она вернет объект встроенного класса `Generator`, который реализует интерфейс `Iterator`. 

```php
Generator implements Iterator {
public current ( void ) : mixed
public getReturn ( void ) : mixed # Получить значение, возвращаемое генератором
public key ( void ) : mixed
public next ( void ) : void
public rewind ( void ) : void
public send ( mixed $value ) : mixed # Передать значение в генератор
public throw ( Throwable $exception ) : mixed # Бросить исключение в генератор
public valid ( void ) : bool
public __wakeup ( void ) : void
}
```

Когда все значения в генераторе закончились, функция просто завершит работу ничего не вернув. После этого основной код продолжит работу, аналогично как, например, когда в массиве закончились элементы для перебора. 

Начиная с PHP 7, используя `Generator::getReturn()` можно получить значение, возвращаемое генератором через `return` после завершения генератора.  

```php
/* Генератор перебора argv с возвратом количества параметров */
function arg_iterator()
{
    global $argv;
    for($i = 1; $i<count($argv);$i++)
    {
        yield $argv[$i];
    }
    return $i-1; // Return the count of arguments
}

$generator = arg_iterator();
foreach($generator as $arg_value) {
    echo "$arg_value\n";
}
echo "Count arguments: {$generator->getReturn()}";

```

Из генератора можно не только получать, но и отправлять в него значения с помощью Generator::send(). 

```php
/**
 * @param mixed $value Что отправляется в генератор, будет возвращаемым значением yield в генераторе.
 * @return mixed что было сгенерировано в генераторе через yield
 */
public Generator::send ( mixed $value ) : mixed

```

Эта функция передает значение в генератор как результат вызова `yield`  в генераторе и возобновляет работу генератора.

```php
/* Через send() в генератор передается строка для печати */
function printer() {
    while (true) {
        $string = yield;
        echo $string . PHP_EOL;
    }
}

$printer = printer();
$printer->send('Hello world!');
$printer->send('Bye world!');
```

Функция `Generator::send()` возвращает сгенерированное через `yield` значение.

```php
# Отправка значения в генератор через параметр send()
# и получение результата через возвращаемое значение send()
function square()
{
    $number = yield; # Здесь получается значение первый раз
    while(1) {
        # Здесь значение отправляется, а потом получается новое
        $number = (yield $number*$number);
    }
}

var_dump(square()->send(5));   # int(25)
var_dump(square()->send(10));  # int(100)
```

`yield` может также генерировать значения с ключами:

```php
function gen()
{
    for($i=1;;$i++)
        yield "Line$i" => $i;
}

$gen = gen();
echo "{$gen->key()} => {$gen->current()}"; # Line1 => 1
$gen->next();
echo "{$gen->key()} => {$gen->current()}"; # Line2 => 1
```

Генераторы могут отдавать значения по ссылке. Как и при возврате ссылки из функции необходимо добавить амперсанд `&` перед именем функции.

```php
function &gen_reference() {
    $value = 3;
    while ($value>0) {
        yield $value;
        echo $value; # 2... 1... 0... 
    }
}

# Так как генератор возвращает ссылку
# при изменении $number в цикле
# $value в gen_reference() также меняется
foreach (gen_reference() as &$number) {
    $number--.'... ';
}
```

Делегирование *generator*'а позволяет получать значения из другого `Generator`, объекта `Traversable` или `array`, используя `yield from`. 

`yield from` не сбрасывает ключи – ключи, возвращенные из объекта `Traversable` или `array`, сохранятся. В итоге ключи для каждого из генераторов (внутреннего и внешнего) считаются отдельно, поэтому могут совпадать, как в примере:

```php
# Внешний генератор
function generator()
{
    yield 1;
    yield from inner();
    yield 3;
}
# Внутренний генератор
function inner()
{
    yield 2;
}

foreach(generator() as $key => $value) {
    echo "$key => $value... "; # 0 => 1... 
                               # 0 => 2... 
                               # 1 => 3...
}
```

Функция `iterator_to_array()` обходит `Traversable` (в т.ч. `Generator`) и сохраняет значения в массив:

```php
/**
 * @param Traversable $iterator Итератор (в т.ч. генератор) для обхода
 * @param bool $use_keys Ключи из итератор игноровать или нет
 * @return array Массив с элементами из $iterator, полученный при обходе
 */
array iterator_to_array ( Traversable $iterator [, bool $use_keys = true ] ): array
```

При возврате значений с одинаковыми ключами из внешнего `yield` и внутреннего `yield from`, они перезапишут друг друга. Нужно отключить использование ключей, установив `$use_keys = false`. 

Можно в качестве значения `return` генератора указать `yield from`, тогда результатом внешнего генератор будет результат внутреннего генератора:

```php
//Возврат значения из функции-генератора через yield from
function outer_generator()
{
    yield from [1]; # iterable-массив
    yield from new ArrayIterator([2]); # iterable объект класса Traversable
    return yield from inner_generator(); # возврат значения внутреннего генератора
}

function inner_generator()
{
    yield 3;
    return 4;
}

$gen = outer_generator();
foreach($gen as $num)
{
    echo "$num... "; # 1... 2... 3...
}
echo $gen->getReturn(); # 4

```

Т.к. генератор реализует интерфейс `Traversable`, он может использоваться внутри интерфейса `IteratorAggregate`. Это поволяет сделать *custom*'ный итерируемый класс со своими функциями, например, *custom*'ный итератор с массивом внутри:

```php
//Использование генератора совместно с IteratorAggregate
class myArrayObject implements IteratorAggregate
{
   private $data = [];
   
   public function __construct($data) 
   {
      $this->data = $data;
   }
   
   public function getIterator() {
      foreach($this->data as $key => $value) {
         yield $key => $value;
      }
   }
}


foreach(new myArrayObject([1,2,3]) as $key => $value) {
   echo "$key=>$value\n";
}
```

`Generator` (как и любой `iterable`) можно использовать при вызове функции вместе с многоточием `...`, чтобы распаковать в список аргументов ([1](#список-аргументов-переменной-длины))

Недостатки *generator*'ов по сравнению с другими *iterator*'ов:

- *generator*'ы могут быть только однонаправленными итераторами. Их нельзя перемотать назад после старта итерации. 

- один и тот же *generator* нельзя использовать несколько раз: *generator* необходимо пересоздавать каждый раз, снова вызвав функцию *generator*'а.




# zval

### Структура zval

#### PHP5

Каждая PHP переменная хранится в виде структуры:

```c
struct zval {
    zvalue_value value;   // Значение
    unsigned char type;   // Тип переменной
    unsigned char is_ref; // Флаг - существуют ли переменные-ссылки, определенные через `&`, 
                          // на этот zval или нет (аналог symlink)
    short refcount;       // Количество переменных, которые напрямую связаны с этим zval 
                          // (аналог `hardlink`)
};
```

Объединение `zend_value`:

```c
typedef union _zvalue_value {
    long lval;                 // int, bool
    double dval;               // float
    struct {                   // string
        char *val;             //   сама строка
        int len;               //   ее длина
    } str;
    HashTable *ht;             // array
    zend_object_value obj;     // object
} zend_value;
```

Перечень констант для указания типа в поле `zval.type`. Константы также определяют, какие из полей `zvalue_value` используется для хранения значения:

```c
#define IS_NULL     0      /* Значение не нужно хранить */
#define IS_LONG     1      /* Значение в lval */
#define IS_DOUBLE   2      /* Значение в dval */
#define IS_BOOL     3      /* В lval значения 0 или 1 */
#define IS_ARRAY    4      /* Хранится в ht */
#define IS_OBJECT   5      /* Хранится в obj */
#define IS_STRING   6      /* Хранится в str */
#define IS_RESOURCE 7      /* В lval хранится resource_ID */
```

<u>Размещение в памяти</u>

Имена созданных переменных хранятся в специальной таблице имен (*symbol table*), отдельной для каждой области видимости: одной глобальной (*global scope*) и множества локальных для каждой функции и метода (*local scope*). 

*Symbol table* размещается на стеке (*vm stack*) и хранит указатели (*pointers*) на `zval`'ы.  `zval`'ы хранятся в куче (*heap*) и в `zval` хранится счетчик ссылок `refcount`.

Пример программы с 4 переменными и количество CPU инструкций для доступа к данным:

![доступ к zval](https://parshikovpavel.github.io/img/php/zval1.png)

Недостатки:

- большой размер структуры `zval`
- `zval` хранится отдельно и доступен по *pointer*'у
- требуется отдельная *CPU instruction* для доступа по *pointer*'у к `zval`'у, даже для элементарных типов вроде `int`

Подробную информацию по структуре `zval` можно получить утилитой *XDebug*.

#### PHP7

Каждая PHP переменная хранится в виде структуры (128 бит):

```c
struct _zval_struct {
    zend_value value;            // Значение (64 бит)
    union {
        struct {
            unsigned char type,       // Тип переменной
            unsigned char type_flags  // Флаги типа
            /* ... */    
        } v;
     /* ... */
    } u1;
    union {
        uint32_t next;                 // индекс следующего bucket'а в цепочке коллизий
        /* ... */
    } u2;
};
```

Объединение `zvalue_value` (64 бит, т.к. *pointer*'ы 64 битные и *scalar* типы тоже 64-битные):

```c
typedef union _zend_value {
    zend_long         lval;    // int
    double            dval;    // float
 /* zend_refcounted  *counted; ??? */
    zend_string      *str;     // string
    zend_array       *arr;     // array
    zend_object      *obj;     // object
    zend_resource    *res;     // resource
    zend_reference   *ref;     // ссылка
} zend_value;

```

Перечень констант для указания типа в поле `zval.type`. Константы также определяют, какие из полей `zend_value` используется для хранения значения:

```c
#define IS_UNDEF                    0  // неинициализированная переменная
#define IS_NULL                     1
#define IS_FALSE                    2  // bool разделен на два типа, это позволяет читать
#define IS_TRUE                     3  // только тип и не читать значение
#define IS_LONG                     4
#define IS_DOUBLE                   5
#define IS_STRING                   6
#define IS_ARRAY                    7
#define IS_OBJECT                   8
#define IS_RESOURCE                 9
#define IS_REFERENCE                10 // новый тип, ссылка
```

`type_flags` – флаги, набор битов, каждый из которых указывает что поддерживает этот тип. Например, один из флагов `IS_TYPE_REFCOUNTED` – *refcounted* переменная.

Все типы делятся на:

- скалярные (*scalar*). Особенности:

  - значение хранится прямо внутри `zval`
  - не используют подсчёт ссылок (всегда относятся к одной переменной)
  - не имеют подчиненной структуры.
  - значение изменяется прямо внутри `zval`, не требуется доступ к подчиненной структуре

- подсчитываемые (*refcounted*). К ним относятся `array`, `string`, `object`, ссылки.

  Особенности:

  - хранят в `zval` ссылку на подчиненную структуру-значение на *heap*'е. 

  - в `type_flags` флаг `IS_TYPE_REFCOUNTED == 1`.

  - подчиненная структура-значение содержит следующую структуру для подсчета ссылок:

    ```c
    struct _zend_refcounted {
        uint32_t refcount;
        // и служебные данные
    };
    ```

    

  

![](https://parshikovpavel.github.io/img/php/zval3.png)

<ins>Размещение в памяти</ins>

Особенности:

- `zval`  хранится прямо на *stack*'е. 
- `refcount` убран из `zval`.

Преимущества:

- не требуется отдельная *CPU instruction* для доступа к `zval`, `zval` хранится прямо на *stack*'е.
- Поэтому возможно привязывать такую подчиненную структуру-значение любого *refcounted* типа к нескольким `zval`. Например, привязывать `zend_string` к ключам `array`.

Пример программы с 4 переменными и количество CPU инструкций для доступа к данным:

![доступ к zval](https://parshikovpavel.github.io/img/php/zval2.png)



### Основные сценарии

#### Инициализация переменной

Алгоритм выполнения `$var = <value>`.

- в *symbol table* создается имя `$var`

- оно связывается с `zval` вида:

  ```
  zval {
      value: <value>
      type: <type>
      /* ... */
  }
  ```

  - *scalar* значения не имеют подчиненную структуры-значения и хранятся прямо в поле `zval.value`. Это обозначается символом `=` вместо `→`. 

    ```php
    $a = 42;                  # $a = zval_1(type=IS_LONG, value=42)
    xdebug_debug_zval('a');   # a: (refcount=0, is_ref=0)=42
    ```

  - *refcounted* типы имеют подчиненную структуру-значение, доступную по указателю. Это обозначается символом `→`:

    ```php
    $a = [];
    $a[] = 1;   # $a = zval_1(type=IS_ARRAY) -> zend_array_1(refcount=1, value=[1])
    xdebug_debug_zval('a'); # a: (refcount=1, is_ref=0)=
                            #.                array (0 => (refcount=0, is_ref=0)=1)
    ```

#### Удаление переменной

Алгоритм выполнения `unset($var)`

- в *symbol table* удаляется имя `$var`

- в структуре `zval` изменяется `type = IS_UNDEF`

  - для *scalar* типов, больше никаких действий:

    ```php
    $a = 1;
    unset($a); # $a = zval_1(type=IS_UNDEF)
    ```

  - для *refcounted* типов, дополнительные действия:

    - в подчиненной структуре-значении выполняется `refcount--`

    - если `refcount == 0`, то PHP уничтожает подчиненную структуру.

      ```php
      $a = [];   // $a = zval_1(type=IS_ARRAY) -> zend_array_1(refcount=1, value=[])
      unset($a); // $a = zval_1(type=IS_UNDEF) и zend_array_1 уничтожен
      ```

      

#### Изменение значения переменной

Алгоритм выполнения `$var = <another_value>`:

- имя `$var`  в *symbol table* связывается с новым `zval`.
- в старой структуре `zval` изменяется `type = IS_UNDEF`
- дополнительные действия для *refcounted* типов:
  - в подчиненной структуре-значении выполняется `refcount--`
  - если `refcount == 0`, то PHP уничтожает подчиненную структуру.

#### Присвоение одной переменной значения другой переменной

##### Присвоение *scalar* типа

*Scalar* значения не имеют подчиненной структуры-значения и хранятся прямо в поле `zval.value`.          Поэтому *scalar* переменные не могут иметь общую подчиненную структуру, каждая *scalar* переменная независима от другой переменной.

```php
$a = 42;   # $a = zval_1(type=IS_LONG, value=42)

$b = $a;   # Никакой подчиненной структуры нет, каждый zval независим от другого
           # $a = zval_1(type=IS_LONG, value=42)
           # $b = zval_2(type=IS_LONG, value=42)

$a += 1;   # $a = zval_1(type=IS_LONG, value=43)
           # $b = zval_2(type=IS_LONG, value=42)
```

##### Присвоение *refcounted* типа

Используется оптимизация *Сopy-on-write* (копирование-при-записи), которая позволяет снизить потребление памяти.

Алгоритм присвоении `$b = $a` (*by value*):

- в `zval` переменной `$b` задается указатель на подчиненную структуру-значение переменной `$a`
- в подчиненной структуре `refcount++` инкрементируется.  

Этот алгоритм выполняется и при передаче аргумента в функцию *by value*.

##### Изменение *refcounted* типа

Алгоритм изменении значения переменной `$a` или изменения содержания переменной `$a` (с `refcount > 1`) (кроме изменения содержания `object`, для `object` изменение содержания выполняется в подчиненной структуре-значении, без создания копии)

-  разделить путем копирования (или создать новую) подчиненную структуру-значение
-  сделать изменения в копии (или в новой структуре)
-  связать `zval` переменной `$a`  с копией (или новой) подчиненной структуры-значения.
-  уменьшить `refcount` в подчиненной структуре-значении переменной `$b`

```php
$a = [];   # $a = zval_1(type=IS_ARRAY) -> zend_array_1(refcount=1, value=[])
$b = $a;   # $a = zval_1(type=IS_ARRAY) -> zend_array_1(refcount=2, value=[])
           # $b = zval_2(type=IS_ARRAY) ---^
         
$a[] = 1; # Изменение содержания переменной
          # Выполняется разделение zval путем копирования 
          # $a = zval_1(type=IS_ARRAY) -> zend_array_2(refcount=1, value=[1])
          # $b = zval_2(type=IS_ARRAY) -> zend_array_1(refcount=1, value=[])

$a = [5]; # Изменение значения переменной
          # Выполняется создание новой подчиненной структуры-значения
          # $a = zval_1(type=IS_ARRAY) -> zend_array_3(refcount=1, value=[5])
          # $b = zval_2(type=IS_ARRAY) -> zend_array_1(refcount=1, value=[])
```

###  Хранение разных типов

#### Ссылки

##### PHP5

При создании ссылки на переменную устанавливается флаг `is_ref = 1`, и далее оптимизация *copy-on-write* для этого *zval*'а применяться не будет. Т.е. присвоение переменной с `is_ref=1` приводит к ее копированию, `zval` разделяться между ссылкой и нессылкой не может.

| PHP                             | Под капотом                                                  |
| ------------------------------- | ------------------------------------------------------------ |
| `$a = 1`<br/>`$b = $a`          | `a, b: {`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 0`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 2`<br/> `}` |
| `$ref = &$a`                    | `a, ref: {` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 1`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 2`<br/> `}` <br/> `b: { # переменная b выделена в отдельный zval` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 0`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 1`<br/> `}` |
| `$c = $a`<br/>(или `$c = $ref`) | `a, ref: {` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 1`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 2`<br/> `}` <br/> `b: {` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 0`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 1`<br/> `}` <br/> `c: {        # оптимизация copy-on-write не применяется`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 0 # переменная была выделена в отдельный zval` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 1`<br/> `}` |

В итоге, при использовании ссылок производительность оказывается ниже, чем без их использования. Например:

```php
$array = range(0, 1000000);  # $array → zval (is_ref=0)
$ref =& $array;              # $array, $ref → zval (is_ref=1)    
count($array);               # Здесь происходит дублирование огромного массива
```

`count()` принимает аргумент *by value*, а `$array` является PHP-ссылкой, а `zval` не может быть одновременно значением (`is_ref=0`) и ссылкой (`is_ref=1`) поэтому полная копия массива создаётся до того, как он передается в `count()`. Если бы `$array` не был ссылкой, то `zval` был бы расшарен между формальным (formal) и фактическим (*actual*) параметрами.

Создание ссылки и затем изменение значения по ссылке

| PHP                       | Под капотом                                                  |
| ------------------------- | ------------------------------------------------------------ |
| `$a = 1`<br/>`$ref = &$a` | `a, ref: {` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`value: 1`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 1`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 2`<br/> `}` |
| `$ref = 2`                | `a, ref: {` <br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`value: 2`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`is_ref: 1`<br/>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`refcount: 2`<br/> `}` |

##### PHP7

Для работы со ссылками введен новый `type = IS_REFERENCE`. Для этого типа введена подчиненная структура-значение:

```c
struct _zend_reference {
    zend_refcounted   gc;
    zval              val;
};
```

В `zend_reference` вложен `zval` переменной и добавлен подсчёт ссылок. 

Этот тип не доступен для скриптов. Скрипты видят тот `zval`, который находится внутри `zend_reference`.

###### Создание и удавление ссылки на `zval`

При определении ссылки, создается `zval` с `type = IS_REFERENCE` и в его подчиненную структуру-значение `zend_reference` вкладывается `zval` самой переменной. В подчиненной структуре-значении `zend_reference`  поле  `refcount` выполняет подсчет ссылок на `zval`, всегда `refcount > 1`.

При удалении ссылки, если становится `refcount == 1`, то выполняется обратная процедура. `zval` с `type = IS_REFERENCE` удаляется, а вложенный в нее `zval` переносится в последнюю оставшуюся ссылку.

```php
$a = [];  # $a -> zend_array_1(refcount=1, value=[]) 
$b =& $a; # $a, $b -> zend_reference_1(refcount=2) -> zend_array_1(refcount=1, value=[]) 
$b[] = 1; # $a, $b -> zend_reference_1(refcount=2) -> zend_array_1(refcount=1, value=[1])
unset($a); # $b -> zend_array_1(refcount=1, value=[1]) 
```

Важно: что у ссылки `refcount = 2` (потому что две переменные являются ссылками на одно значение), но у `zval` значение `refcount = 1`, поскольку на него ссылается одна структура `zend_reference`. 

###### Одновременное использование `zval` *by value* и *by reference*

В отличии от PHP5, возможно одновременное использование `zval` для *refcounted* типов, вне зависимости от того, присвоены они *by value* или *by reference*. 

Особенности:

- если переменная присвоена *by value* – она привязана к своему `zval` напрямую
- если переменная присвоена *by reference* – она привязана к своему `zval` через структуру `zend_reference`. Несколько переменных, являющихся ссылками друг на друга, делят общий  `zend_reference`.

В примере, массив будет отделён только после внесения некоторых изменений. То есть можно безопасно передать в `count()` большой массив-ссылку, и он не будет продублирован в памяти. 

```php
$a = [];  # $a         -> zend_array_1(refcount=1, value=[])
$b = $a;  # $a, $b,    -> zend_array_1(refcount=2, value=[])
$c = $b;  # $a, $b, $c -> zend_array_1(refcount=3, value=[])

$d =& $c; # Переменные, присвоенные by value и by reference, используют один zend_array.
          # В PHP5 на этом шаге произошла бы дупликация zend_array, 
          # т.к. он не может быть сразу и ссылкой и не ссылкой
          # $a, $b                                 -> zend_array_1(refcount=3, value=[])
          # $c, $d -> zend_reference_1(refcount=2) ---^

$e = $d   # Переменная, присвоенная by value привязывается напрямую к zval
          # $a, $b, $e                             -> zend_array_1(refcount=3, value=[])
          # $c, $d -> zend_reference_1(refcount=2) ---^

$d[] = 1; # Только в данный момент происходит дупликация zend_array,
          # после операции присваивания.
          # $a, $b                                 -> zend_array_1(refcount=2, value=[])
          # $c, $d -> zend_reference_1(refcount=2) -> zend_array_2(refcount=1, value=[1])

```

###### Присваивание ссылке ссылки

При присваивании переменной другого значения *by reference* (`= &`), не важно к какому `zval` эта переменная была привязана ранее, она просто перепривязывается на структуру `zend_reference`. Это не влияет на другие переменные, привязанные к тому же `zval`.

При присваивании переменной другого значения *by value* (`=`), даже если это значение является ссылкой на что-то, это значение подставляется в `zval` этой переменной. 

При присваивании переменной-ссылке другой ссылки, переменная-ссылка перепривязывается на другую структуру `zend_reference`. Т.е. не важно, была переменная раньше ссылкой или нет, переменная полностью инициативе Т.е. нет возможности через одну ссылку на  `zend_reference` повлиять на привязку других ссылок.

```php
$a = 1;   # $a = zval_1(type=IS_LONG, value=1)
$b = &$a;  # $a, $b -> zend_reference_1(refcount=2) -> zval_1(type=IS_LONG, value=1)

$c = 2;   # $c = zval_2(type=IS_LONG, value=2)
$d = &$c; # $c, $d -> zend_reference_1(refcount=2) -> zval_2(type=IS_LONG, value=2)

$b = &$d; # $b перепревязывается на другую структуру zend_reference
          # $a привязывается к zval напрямую, т.к. другая ссылка удалена
          # $a = zval_1(type=IS_LONG, value=1)
          # $b, $c, $d -> zend_reference_1(refcount=3) -> zval_2(type=IS_LONG, value=2)
```

Аналогично выполняется 

 

<u>Тут не доделано</u>

Написать про присваивании ссылке

Переменная $inner в функции foo будет связана с $outer в вызывателе, но затем она будет перепривязана к $GLOBALS["baz"]. Нет способа связать $outer в области видимости вызывателя с другой структурой, т.к. $inner это всего лишь ссылка на структуру IS_REFERENCE . Если необходимо изменить внешнюю ссылку, можно воспользоваться возвращением ссылок из функции.

**function** foo(&$inner)
 {               # $outer, $inner -> zend_reference_1(refcount=2) -> zval_1
     

     $var =& $GLOBALS[**"baz"**]; # $outer -> zval_1
                              \# $inner -> zend_reference_2(refcount=2) -> zval_2

 }
 foo($bar);

Аналог в PHP5:

| **PHP**              | **Под капотом**                                              |
| -------------------- | ------------------------------------------------------------ |
| $a = 1;    $b =& $a; | a,b: {         is_ref: 1         refcount: 2   }             |
| $c = 2;    $b =& $c; | a: {         is_ref: 0         refcount: 1   }   b,c: {       is_ref:   1       refcount:   2   } |

### 



#### `string`

##### PHP5

Cтруктура `str` для строки:

```c
struct {                   // string
    char *val;             //   сама строка
    int len;               //   ее длина
} str;
```

##### PHP7

Подчиненная структура-значение `zend_string` для строки:

```c
struct _zend_string {
    zend_refcounted   gc;   // структура для подсчета
    zend_ulong        h;    // хеш строки
    size_t            len;  // длина строки
    char             *val;
};
```

Хотя длина строки хранится, строки все равно заканчиваются нулевым байтом (*NUL-terminated*), чтобы обеспечить совместимость с библиотечными функциями. 

#### `object` (`zval`)

##### PHP5

Объекты хранятся в отдельном хранилище (*object store*).

Структура `zend_object_value` для объектов имеет вид:

```php
typedef struct _zend_object_value {
    zend_object_handle handle; // уникальный ID объекта, используемый для его поиска 
    					       // в object store
    const zend_object_handlers *handlers;    // массив указателей на методы
} zend_object_value;
```

Структура объекта в *object store*:

```c
{
    zend_class_entry *ce;                    // указатель на класс
    HashTable        *properties;            // массив свойств
    zval *property1;                         // значение свойства N
    ...
    HashTable        *guards;              // массив динамически добавленных property's    
} zend_object_value;
```



![](https://parshikovpavel.github.io/img/php/zval4.png)

##### PHP7

Структура `zend_object`:

```c
struct _zend_object {
    zend_refcounted   gc;                  // счетчик ссылок
    zend_class_entry *ce;                  // указатель на класс
    const zend_object_handlers *handlers;  // массив указателей на методы
    HashTable        *properties;          // массив свойств
    zval property1;                        // значение свойства N
    ...
    HashTable        *guards;              // массив динамически добавленных property's
    /* ... */
};
```

![](https://parshikovpavel.github.io/img/php/zval5.png)

Считается, что объекты присваиваются и передаются в функцию по ссылке по умолчанию. Однако это не так, присваивание объекта *by value*  `$a = $b` – это не то же самое, что присваивание объекта *by reference* `$a = &$b`.

###### Присвоение (передача, возврат из функции) *by value*

При любом присвоении (передаче, возврате из функции) *by value*, `object` переменная ведет себя как обычная *refcounted* переменная, используется техника *copy-on-write*. Используется обычный алгоритм [присвоения *refcounted* типа](#присвоение-refcounted-типа) – создается новый *zval*, который указывает на ту же самую подчиненную структуру-значение.

```php
$a = new stdClass; # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=1, value={})

var_dump($a);      # object(stdClass)#1 (0) {}

$b = $a;           # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=2, value={})
                   # $b = zval_2(type=IS_OBJECT) ---^

var_dump($b);      # object(stdClass)#1 (0) {}
                   # zval указывает на тот же zend_object_1
```

###### Изменение значения `object`  переменной

При изменении <u>значения</u> `object` переменная ведет себя как обычная *refcounted* переменная. Используется обычный алгоритм [изменение *refcounted* типа](#изменение-refcounted-типа) – создается новая подчиненная структура-значение и связывается с `zval`.

```php
$a = new stdClass; # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=1, value={})

$b = $a;           # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=2, value={})
                   # $b = zval_2(type=IS_OBJECT) ---^

$b = 100;          # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=1, value={})
                   # $b = zval_2(type=IS_LONG, value=100)
```

###### Изменение содержания `object` переменной

При изменении <u>содержания</u> `object` переменная ведет себя как <u>ссылка</u> на *refcounted* переменную. Изменения выполняются в той же подчиненной структуре-значении, отделение копии не происходит.

```php
$a = (object) ['prop' => 1]; 
# $a = zval_1(type=IS_OBJECT) -> -> zend_object_1(refcount=2, value={ 1 ))

var_dump($a);      # object(stdClass)#1 { public $prop => int(1) }

$b = $a;           # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=2, value={ 1 ))
                   # $b = zval_2(type=IS_OBJECT) ---^

$b->prop = 2;      # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=2, value={ 2 ))
                   # $b = zval_2(type=IS_OBJECT) ---^

var_dump($b);      # object(stdClass)#1 (0) { public $prop => int(2) }
                   # zval указывает на тот же zend_object_1
```

Поэтому функция, в которую объект передан *by value*, не может повлиять на значение фактического (*actual*) параметра-объекта. Но может повлиять на его содержимое.

###### Присвоение (передача, возврат из функции) *by reference*

При любом присвоении (передаче, возврате из функции) *by reference*, `object`-ссылка ведет себя как обычная [ссылка](#ссылки).

```php
$a = new stdClass;  # $a = zval_1(type=IS_OBJECT) -> zend_object_1(refcount=1, value={})
$b =& $a; # $a, $b -> zend_reference_1(refcount=2) -> zend_array_1(refcount=1, value=[]) 
$b->pr = 1; # $a, $b -> zend_reference_1(refcount=2) -> zend_object_1(refcount=1, value={1})
$b = 100; # $a, $b -> zend_reference_1(refcount=2) -> zval_2(type=IS_LONG, value=100)
```



#### `array` (`zval`)

##### PHP5

Для реализации `array` используется *HashTable* с [методом цепочек и связанными списками](Algorithm.md#метод-цепочек).

В `zval` хранится ссылка на `Hashtable`:

```c
HashTable *ht;
```

Структура `HashTable`:

```c
typedef struct _hashtable {
    uint nTableSize; //размер таблицы, при превышении которого размер таблицы увеличивается в 2 раза
    uint nTableMask; //значение nTableSize-1 как маска для выделения последних битов из хеша
    uint nNumOfElements; //число элементов
    ulong nNextFreeElement; //следующий целочисленный ключ, с которым будет вставлен $a[]
    Bucket *pInternalPointer; //текущий бакет для итерирования
    Bucket *pListHead; //стартовый бакет
    Bucket *pListTail; //конечный бакет
    Bucket **arBuckets; //связанные списки бакетов
...................//есть еще несколько
} HashTable;
```

В PHP терминология отличается. `Bucket` – это элемент *linked list* (в другой терминологии, это *entry*). Массив, содержащий заголовки *linked list*'s, называется `arBuckets`. 

![](https://parshikovpavel.github.io/img/algorithm/hashtable2.png)

Структура `Bucket`:

```c
typedef struct bucket {
    ulong h; //для целого ключа само значение, для строкового его хеш
    uint nKeyLength;  //длина хеша для строковых ключей
    void *pData; //указатель на данные
    void *pDataPtr; //если элемент указатель, то здесь он хранится, а pData ссылается на pDataPtr
    struct bucket *pListNext;  // для обхода массива в порядке добавления элементов
    struct bucket *pListLast;
    struct bucket *pNext;      // для организации linked list'а bucket'ов,
    struct bucket *pLast;      // которые отражаются хеш-функцией на один index.
    char *arKey; //исходный ключ для строковых ключей
} Bucket;
```

Каждый `Bucket` включен в два двусвязных *linked list*'а:

- *linked list of bucket*'ов, которые отражаются хеш-функцией на один *index*. `Bucket` хранит указатель на следующий (`pNext`) и предыдущий (`pLast`) *bucket*'ы. Это позволяет легко производить поиск, добавление и удаление *bucket*'ов.

  ![](https://parshikovpavel.github.io/img/algorithm/hashtable6.png?1)

- *linked list* в порядке добавления *entry*'s в `array`, т.к. `array` в PHP упорядочен. Если вы обходите `array`, то вы будете получать *entry*'s в том порядке, в котором они были вставлены. `Bucket` хранить указатель на следующий элемент (`pListNext`) и на предыдущий (`pListLast`). `HashTable` хранить указатели на начало списка (`pListHead`) и конец (`pListLast`). 

  Например, для массива `['a', 'b', 'c']` *linked list* имеет вид:

  ![](https://parshikovpavel.github.io/img/algorithm/hashtable3.png?1)

В PHP структура `HashTable` используется для хранения многих служебных списков:

- списки переменных в *scop*'e
- методы и поля классов
- определение классов.
- ...

Поэтому это важнейшая структура для производительности PHP.

##### PHP7

Основная причина увеличения производительности – вся *hash table* размещена локально в памяти, многие обращения к памяти выбираются из кеша ЦП. В PHP5 требовался проход по нескольким указателям, разбросанным по памяти, возникали cache miss и ожидание чтения данных из ОП.

В `zval` хранится ссылка на `zend_array`:

```c
zend_array       *arr;     // array
```

Структура `zend_array`:

```c
struct _zend_array {
    zend_refcounted   gc; //  счетчик ссылок
    Bucket      *arData;  // массив bucket'ов
	/* ... */
};
```

В `zend_array` теперь хранится сам массив *bucket*'ов, а не указатели на указатели. 

Структура `Bucket`:

```c
typedef struct _Bucket {
    zval              val; /* значение */
    zend_ulong        h;   /* хэш (или числовой индекс)   */
    zend_string      *key; /* строковый ключ или NULL для числовых значений */
} Bucket;
```

`zval` хранится прямо внутри `Bucket`.  Убраны все *linked list*'ы. 

`Bucket`'ы хранятся в *slot*'ах непрерывном фрагменте памяти `arData`, в порядке добавления, что позволяет быстро их итерировать. 

Например, для массива `[3 => 'foo', 8 => 'bar', 'baz' => []]`  массив `arData` имеет вид:

![](https://parshikovpavel.github.io/img/algorithm/hashtable4.png)

При удалении  элемента из массива, соответствующему `zval` в `arData` устанавливается `type = IS_UNDEF`:

![](https://parshikovpavel.github.io/img/algorithm/hashtable5.png)

<u>Поиск в *hash table*</u>

Вначале, по ключу с использованием *hash function* находим *index bucket*'а. Для преобразования *index*'а *bucket*'а в *slot* в массиве `arData` используется таблица перевода (*translation table*). *Translation table* размещается в памяти непосредственно перед `arData`, использует отрицательные смещения от  начала `arData`.

Например, для массива:

```php
[
    'bar' => 'bar-val',  # index = 3 (расчитан с использованием hash function)
    'foo' => 42          # index = 5
]
```

в памяти получаем:

![](https://parshikovpavel.github.io/img/algorithm/hashtable7.png)

Если массив использует только числовые ключи, вида:

```php
[
    0 => ...,
    1 => ...
]
```

то создается *packed hashtable* (упакованная) без *translation table*. Доступ к элементам осуществляется по индексу в `arData` со скоростью, сравнимой с массивами C. 

<u>Разрешение *collision*</u>

Если возникает *collision*, и *index* элемента совпадает с *index*'ом уже существующего элемента (т.е. ячейка в *translation table* для этого *index* уже занята). Тогда мы записываем *slot* элемента в поле `zval.u2.next`, *bucket*'а с тем же *index*'ом. Т.е. в поле `zval.u2.next` хранится *slot* элемента с тем же значением *index*'а.  Т.е. получаем *linked list*, построенный не через указатели, а через поля `zval.u2.next`.  При этом мы читаем локальный массив `arData`, а не разбросанные по памяти указатели.

##### Примеры

<u>Пример 1</u>

Когда мы входим в `foreach`, то для `array` создается копия с использованием техники *copy-on-write* и именно эта копия итерируется. И если  `array` изменяется внутри цикла, то выполняется отделение *zval*. В итоге `foreach` продолжает итерировать копию исходного `array` и, как бы, не видит никаких изменений над `array` внутри `foreach`.

```php
$a = [1,2];
xdebug_debug_zval('a');   # a: (refcount=2, is_ref=0)= ... (2 - из-за особенностей xdebug)
foreach ($a as $item) {  
    xdebug_debug_zval('a');   # a: (refcount=3, is_ref=0)=... (создана копия)
    $a[2] = 0;
    xdebug_debug_zval('a');   # a: (refcount=1, is_ref=0)=a (выполнено отделение)
    echo $item."\n";          # Выводит:
                              # 1
                              # 2
}
var_dump($a); # array(2) {
              #   [0] => int(1)
              #   [1] => int(0)
              # }
```

На экран будет выведены значения из копии исходного `array` (а не измененного `array`)

<u>Пример 2</u>

```php
$a = [1,2];
foreach ($a as $item1) {
    foreach ($a as $item2) {
        if (($item1 == 1) && ($item2 == 1)) {
            unset($a[1]);
        }
        echo $item1.",".$item2." ; ";
    }
    echo "\n";
}

# Вывод:
# 1,1 ; 1,2 ;
# 2,1 ;
```

Т.е. после удаления элемента `$a[1]`, этот элемент итерируется во внутреннем цикле на 1 итерации внешнего цикла. Но не итерируется на 2-й итерации внешнего цикла, т.к. на 2-й итерации внутренний цикл подхватывает уже измененный массив `$a`. При этом внешний цикл не видит изменения массива `$a` до окончания цикла.

##### Элементы `array`

Элементы массива следует рассматривать как отдельные, независимые переменные, которые находятся внутри контейнера-массива. Их поведение не зависит от типа присвоения этого массива. Если элемент массива `IS_REFERENCE`, то при копировании массива этот элемент останется `IS_REFERENCE` и в обоих массивах будет ссылка на один `zval`.

```php
$arr = array(0, 0);
$a =& $arr[0];   # $arr[0] становится IS_REFERENCE
$arr2 = $arr;    # Присвоение не по ссылке, а по значению
$arr2[0]++;      # Изменение элементов массива в копии
$arr2[1]++;
var_dump($a);    # int(1) - изменилась переменная-ссылка на первый элемент

var_dump($arr);  # Содержимое $arr изменилось, хотя было присвоено не по ссылке! 
                 # array(2) {
                 #   [0] => &int(1)  - здесь явно показано амперсандом, что это IS_REFERENCE
                 #   [1] => int(0)
                 # }
```

<u>Тут не доделано</u>

### Присваивание объекта

Когда происходит присвоение объекта переменной, эта переменная будет указывать на этот же экземпляр.



При создании ссылки на объект, создается zval с типом IS_REFERENCE, содержащий в себе исходный zval с указателем на объект zend_object. Т.е. обе переменные $b и $d ссылаются на один zval типа IS_REFERENCE:

$a = **new** stdClass;
 $b = $a;
 $d = &$b;

Присвоение одной ссылке другого значения, меняет значение zval внутри структуры zval с типом  и по второй ссылке:

$b = **null**;

 *var_dump*($d); *# NULL*

Unset для одной ссылки просто уменьшает счетчик count в структуре zval:

**unset**($b);

 *var_dump*($d); *# object(stdClass)#1 (0) { }*

Создает новый пустой объект по классу объекта $a:

$a = **new** stdClass;
 $a->**bar** = 123;
 $b = **new** $a;

Свойства и методы класса живут в разделенных "пространствах имен", так что возможно задавать свойство и метод с одним и тем же именем. Ссылки как на свойства, так и на методы имеют одинаковую нотацию, и получается, что получите вы доступ к свойству или же вызовете метод - определяется контекстом использования.

**class** A
 {
     **public** **$bar**;

     **public function** bar() {}

 }

 $obj->**bar**;
 $obj->bar();

### Передача по ссылке в функцию

По ссылке можно передавать:

·         Переменные, например *foo($a)*

·         Оператор new, например *foo(new foobar())*

·         Ссылки, возвращаемые функцией, например:

**function** foo(&$var) {}

 **function** &bar() {
     $a = 1;
     **return** $a;
 }

 foo(bar());

Любое другое выражение не должно передаваться по ссылке, например недопустимо передавать:

·      выражение

foo($a = 5); // Выражение, а не переменная

·      константу

foo(5); *// Константа, а не переменная*

### Возврат ссылки из функции

& здесь нужно использовать в обоих местах - для указания на то, что вы возвращаете ссылку, и для указания того, что происходит связывание по ссылке.

**class** foo {
     **public** **$value** = 42;

     **public function** &getValue() {
         **return** $this->**value**;
     }

 }

 $obj = **new** foo;
 $myValue = &$obj->getValue(); *# $myValue, $obj->value -> zend_reference_1(refcount=2) -> zval_1*  $obj->**value** = 2;
 *var_dump*($myValue);           *// int(2) - новое значение $obj->value*

Если при присваивании не указан & то происходит присваивание значения.

По ссылке можно возвращать только переменные и ничего больше. в том числе  return ($this->value);, так как вы возвращаете по ссылке результат выражения, а не переменную.

Тернарный оператор является выражением и не может быть вовращен по ссылке из функции 

**function** &func($var)
 {
   **return** $var == 42 ? $a : $b; *# Ошибка
\* }

При передачи ссылки в функцию из другой функции, не нужно ставит впереди & (&collector() неправильно)

**function** &collector() {
     **static** $collection = [];
     **return** $collection;
 }
 *array_push*(collector(), **'foo'**);

### Присвоение по ссылке неинициализированных переменных

Если при присваивании по ссылке элемент массива или переменная отсутствует, то создается ссылка на NULL.

\# $b не объявлено
 var_dump($b);   # NULL
 $a = &$b;       # $a, $b -> zend_reference_1(refcount=2) -> zval(type=IS_NULL)
 var_dump($a);   # NULL
 $a = 5;         # $a, $b -> zend_reference_1(refcount=2) -> zval(type=IS_LONG, value=5)
 var_dump($b);   # int(5)

При присвоении, передаче или возврате неинициализированной переменной по ссылке, происходит ее создание.

**function** foo(&$var) { }

 foo($a); *// $a создана и равна null*  $b = **array**();
 foo($b[**'b'**]);
 *var_dump*(*array_key_exists*(**'b'**, $b)); *// bool(true)*  $c = **new** StdClass;
 foo($c->**d**);
 *var_dump*(*property_exists*($c, **'d'**)); *// bool(true)*

## Сборка мусора

Как только `refcount` станет равным нулю, контейнер уничтожается. `refcount` уменьшается на единицу при уходе переменной из области видимости (например, в конце функции) или при удалении этой переменной (например при вызове `unset()`).

```php
$a = "new string";
$c = $b = $a;
xdebug_debug_zval( 'a' ); //a: (refcount=3, is_ref=0)='new string'
$b = 42;
xdebug_debug_zval( 'a' );// a: (refcount=2, is_ref=0)='new string'
unset( $c );
xdebug_debug_zval( 'a' );// a: (refcount=1, is_ref=0)='new string'
```

Все усложняется с составными типами данных, такими как `array` и `object`. В отличии от *scalar*'ных значений, `array` и `object` хранят свои свойства в собственных таблицах имен. Это значит, что следующий пример создаст сразу три `zval` контейнера:

```php
$a = ['meaning' => 'life', 'number' => 42 ];
xdebug_debug_zval( 'a' );  # a: (refcount=1, is_ref=0)=array [
                           #     'meaning' => (refcount=1, is_ref=0)='life',
                           #     'number' => (refcount=1, is_ref=0)=42
                           # ]
```

![garbage](https://parshikovpavel.github.io/img/php/garbage1.png)

Элементы `array` работают как отдельные переменные. Т.е. при присвоении по значению одного элемента другому используется техника *copy-on-write*. 

```php
$a = array( 'meaning' => 'life', 'number' => 42 );
$a['life'] = $a['meaning'];
xdebug_debug_zval( 'a' );  # a: (refcount=1, is_ref=0)=array (
                           #     'meaning' => (refcount=2, is_ref=0)='life',
                           #     'number' => (refcount=1, is_ref=0)=42,
                           #     'life' => (refcount=2, is_ref=0)='life'
                           # ]
```

![garbage](https://parshikovpavel.github.io/img/php/garbage2.png)

Интересное начинается, если добавить ссылку на массив в этот же массив:

```php
$a = array( 'one' );
$a[] =& $a;
xdebug_debug_zval( 'a' );
```

![garbage](https://parshikovpavel.github.io/img/php/garbage3.png)

при удалении массива `$a` происходит утечка памяти:

![garbage](https://parshikovpavel.github.io/img/php/garbage4.png)

   

PHP удалит эти данные при завершении запроса, но до этого момента данные будут занимать место в памяти. Такая ситуация часто случается с объектами, потому что они всегда неявно используются *by reference*. Проблема часто возникает в долгоработающих скриптах, таких как демоны, где запрос не заканчивается никогда, или в больших наборах модульных тестов.

В PHP реализован механизм поиска циклических ссылок. Утечки памяти с циклическими ссылками могут получиться только при уменьшении счетчика ссылок до ненулевого значения. Затем, в выделенных контейнерах можно найти мусор проверив возможность уменьшения всех счетчиков ссылок на единицу и определив те контейнеры, у которых счетчик станет равным нулю. 

Допустим, были произведены следующие действия:

```php
$array[] = ['one'];
$a =& $array[0];
$array[] =& $array;
unset($array);
```

Результат таких операций показан на шаге **A**.

![garbage](https://parshikovpavel.github.io/img/php/garbage5.png)

При каждом уменьшении счетчика ссылок, алгоритм добавляет все возможные корни (`zval` контейнеры) в "корневой буфер" (`root`). Когда в «корневой буфер» (`root`) попало определенное количество ссылок, в которых уменьшился счетчик, стартует алгоритм (также старт можно сделать функцией `gc_collect_cycles()`). На шаге **B** производится уменьшение счетчиков ссылок на `1` у всех дочерних элементов. На шаге **C** помечаются те `zval`, у которых счетчик стал 0 и возвращаетcя назад значение счетчика у остальных. На шаге **D** удаляются помеченные контейнеры.

Сборку мусора можно включить и выключить в настройках. Применение сборщика мусора позволяет уменьшить использование памяти за счет удаления циклических ссылок, при этом замедление работы по тестам около 7%. Оценить используемую память можно функциями `memory_get_usage()` и `memory_get_peak_usage()`.

# Суперглобальные переменные

Доступны в любом месте скрипта –  для доступа к ним в *local scope* нет необходимости использовать синтаксис:

```php
global $variable;
```

В `php.ini` параметр:

```php
variables_order = "GPCS"
```

отвечает за то, какие суперглобальные переменные доступны.

Полный список:

- `$GLOBALS` — ссылки на все переменные глобальной области видимости:

  ```php
  array(7) {
      ["_GET"] => []
      ["_POST"] => []
      ["_COOKIE"] => []
      ["_FILES"] => []
      ["_SESSION"] => []
      ["variable"] => int(1)
      ["GLOBALS"] => {*RECURSION*}
  }
  ```

- `$_SERVER` – заголовки, пути и местоположения скриптов;
  - `PHP_SELF` – имя файла скрипта `/foo/bar.php`

  - `argv` – массив аргументов, переданных скрипту

  - `argc` – количество аргументов, переданных скрипту

  - `SERVER_NAME` – имя хоста, на котором выполняется текущий скрипт (например, `localhost`)

  - `REQUEST_METHOD` – метод запроса (например, `GET`, `POST`)

  - `REQUEST_TIME` – временная метка начала запроса (например, `int(1504188059)`)

  - `QUERY_STRING` – строка запроса после `?` (например, `param=123`)

  - `DOCUMENT_ROOT` – директория корня документов (например, `/www/site`)

  - `HTTP_HOST` – содержимое заголовка `Host` запроса (например, `localhost`)

  - `HTTP_USER_AGENT` – содержимое заголовка `User-agent`

  - `HTTP_<HEADER_NAME>` –  содержимое заголовка `Header-name` запроса

  - `REMOTE_ADDR` – IP-адрес, с которого пользователь просматривает текущую страницу.

  - `REQUEST_URI` –  URI из заголовка запроса (например, `/news/first.php?param=123`)

  - `PHP_AUTH_DIGEST` – заголовок `Authorization` при выполнении *HTTP Digest* аутентификации (его необходимо потом использовать для соответствующей валидации).

  - `PHP_AUTH_USER` – имя пользователя при HTTP-аутентификация

  - `PHP_AUTH_PW` – пароль пользователя

  - `SCRIPT_FILENAME` – путь к скрипту (например, `/www/news/first.php`)

  - `SCRIPT_NAME` –  путь к скрипту относительно корня (например, `/news/first.php`)

  - `CONTENT_TYPE` – заголовок `Content-Type` ([1](#content-type))

- `$_GET` – ассоциативный массив параметров, переданных скрипту через URL

- `$_POST` – ассоциативный массив данных, переданных скрипту через метод `POST`
- `$_FILES` – массив описания файлов, загруженных через метод `POST`.

- `$_REQUEST` – данные переменных `$_GET`, `$_POST` и `$_COOKIE`.

- `$_SESSION` – переменные сессии, которые доступны для текущего скрипта.

- `$_ENV` – значения из переменных окружения системы.

- `$_COOKIE` – значения заголовка *Cookie* в виде массива.

# Встроенные интерфейсы

## `Traversable` 

Интерфейс, делает класс обходимым (*traversable*) с использованием `foreach`. Абстрактный базовый интерфейс, который не может быть реализован сам по себе. Вместо этого должен реализовываться `IteratorAggregate` или `Iterator`. Этот интерфейс не имеет методов, его единственная цель - быть базовым интерфейсом для всех обходимых классов.

```php
interface Traversable 
{
}
```

## `Iterator`

Используется для реализации собственных алгоритмов итерации: 

```php
Iterator extends Traversable {
    // Метод должен вернуть значение текущего элемента
    abstract public mixed current ( void );

    // Метод должен вернуть ключ текущего элемента
    abstract public scalar key ( void );

    // Метод должен сдвинуть "указатель" на следующий элемент
    abstract public void next ( void );

    // Метод должен поставить "указатель" на первый элемент
    abstract public void rewind ( void );

    // Метод должен проверять - не вышел ли указатель за границы?
    abstract public bool valid ( void );
}
```

Метод `key` может возвращать данные любого типа (а не только строки и числа). Итерироваться с помощью `foreach` нам позволяет интерфейс `Traversable`, а `Iterator` является его наследником. 

## `IteratorAggregate`

Интерфейс `IteratorAggregate`[ ](http://php.net/manual/ru/class.iteratoraggregate.php#class.iteratoraggregate) – интерфейс для создания внешнего итератора, что-то вроде декоратора над другим итератором:

```php
IteratorAggregate extends Traversable {
    /* Получить итератор для перебора */
    abstract public Traversable getIterator ( void )
}
```

```php
class Example implements IteratorAggregate {
    public $data = [1,2,3];

    public function getIterator() {
        return new ArrayIterator($this->data);
    }
}
```

## `Throwable`

Родительский интерфейс для всех объектов, выбрасывающихся с помощью выражения `throw`, включая классы `Error` и `Exception`. Классы исключений не могут напрямую реализовать интерфейс `Throwable`.

```php
interface Throwable {
    abstract public string getMessage ( void )       # Получает сообщение ошибки
    abstract public int getCode ( void )             # Возвращает код исключения
    abstract public string getFile ( void )          # Возвращает файл, в котором произошло исключение
    abstract public int getLine ( void )             # Получает строку скрипта, в которой данный объект был выброш
    abstract public array getTrace ( void )          # Возвращает трассировку стека
    abstract public string getTraceAsString ( void ) # Получает результаты трассировки стека в виде строки
    abstract public Throwable getPrevious ( void )   # Возвращает предыдущий Throwable
    abstract public string __toString ( void )       # Получает строковое представление
}
```

## `ArrayAccess`

```php
interface ArrayAccess {
    abstract public bool offsetExists ( mixed $offset ) # Существует ли заданное смещение (ключ)
    abstract public mixed offsetGet ( mixed $offset )   # Возвращает заданное смещение (ключ)
    abstract public void offsetSet ( mixed $offset , mixed $value ) # Присваивает значение заданному смещению
    abstract public void offsetUnset ( mixed $offset )    # Удаляет по смещению
}
```

## `Serializable`

Есть три взаимоисключающих способа управления сериализацией:

- `__sleep()` и `__wakeup()` ([1](#sleep-wakeup))
- `__serialize()` и `__unserialize()` ([1](#serialize-unserialize))
- Интерфейс `Serializable`

```php
interface Serializable {
    abstract public string serialize ( void ) # Представляет объект в виде строки
    abstract public void unserialize ( string $serialized ) # Создает объект по строке (замещает конструктор)
}
```

- `serialize()` – вызывается при сериализации. 
- `unserialize()` – вызывается при десериализации, выступает как конструктор вместо вызова `__construct()`. Если необходимо вызвать стандартный конструктор, то нужно это сделать в этом методе.

```php
class ValueSerializable implements Serializable
{
    private $value;

    public function __construct($value)
    {
        $this->value = $value;
    }

    public function serialize()
    {
        return json_encode(["value" => $this->value]);
    }

    public function unserialize($serialized)
    {
        $data = json_decode($serialized, true);
        $this->__construct($data['value']);
    }
}
```

## `Closure`

Класс, экземплярами которого являются анонимные функции.

```php
class Closure {
    # Конструктор, запрещающий создание экземпляра
    private __construct ( void )
    # Статический метод, дублирует и возвращает замыкание на основе указанного замыкания, связанного объекта и области видимости класса
    public static Closure bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] )
    # Нестатический метод, дублирует и возвращает замыкание на основе связанного объекта и области видимости класса
    public Closure bindTo ( object $newthis [, mixed $newscope = "static" ] )
    # Связывает и запускает замыкание
    public mixed call ( object $newthis [, mixed $... ] )
    # Конвертирует callable в замыкание
    public static Closure fromCallable ( callable $callable )
}
```

## `Generator`

[1](#generator)

## `Countable`

Классы, реализующие интерфейс `Countable`, могут быть использованы с функцией `count()`.

```php
interface Countable {
    abstract public int count ( void )
}
```

```php
class A implements Countable
{
    public function count()
    {
        return 123;
    }

}

var_dump(count(new A())); # int(123)

```

Функция `is_countable()` проверяет возможность использования аргумента  с функцией `count()`. Возвращает `true`, если аргумент является `array` или `object`, реализующий `Countable` интерфейс. 

## `WeakReference`

`WeфakReference` (слабая ссылка) позволяет программисту получить такую ссылку на объект `$object`, которая не влияет на количество ссылок на него, поэтому сборщик мусора сможет освободить этот объект. Аналог распределенных систем кеширования типа `memcached` с вытеснением из кеша. Могут использоваться для реализации кеша в рамках *request*'а.

Структура класса:

```php
final class WeakReference {
    /* Создать weak reference на объект $object */
    public static function create(object $object) : WeakReference;
 
    /* Получить исходный объект */
    /* Если возвращен null - объект уничтожен */
    public function get() : ?object;
}
```

Пример использования:

```php
$obj = new stdClass;
$weakref = WeakReference::create($obj);
var_dump($weakref->get()); # object(stdClass)#1 (0) {}
unset($obj);
var_dump($weakref->get()); # NULL
```

# Поддерживаемые протоколы и встроенные обработчики

Предназначены для использования с функциями файловой системы, такими как `fopen()`, `copy()`, `file_exists()` и `filesize()`. Можно создать свой обработчик через `stream_wrapper_register()`.

- `file://`

  Доступ к локальной файловой системе (по умолчанию)

- `http://`, `https://` 

  Доступ к URL-адресам по протоколу HTTP(s)

- `ftp://`, `ftps://`

  Доступ к URL-адресам по протоколу FTP(s)

- `php://`

  Доступ к потокам ввода-вывода
  - `php://stdin`

    Чтение из стандартного потока ввода (из консоли через командную строку).  Поток только для чтения.

    ```php
    $input = fopen("php://stdin", "r");
    $line = fgets($input);
    fclose($input);
    var_dump($line);
    ```

    либо короче:

    ```php
    $line = fgets(STDIN);
    var_dump($line);
    ```

  - `php://stdout`

    Вывод в стандартный поток (в консоль и срабатывает вывод в браузер). Поток только для записи.

    ```php
    $output = fopen("php://stdout", "w");
    
    fputs($output, "Hello world!");
    fclose($output);
    ```

    или короче:

    ```php
    fputs(STDOUT, "Hello world!");
    ```

  - `php://input`

    Поток только для чтения. Позволяет читать необработанные данные из тела запроса. Рекомендуется использовать этот поток для получения необработанных данных POST вместо удаленной в PHP7 предопределенной переменной `$HTTP_RAW_POST_DATA`. `php://input` недоступен с типом содержимого `enctype="multipart/form-data".`

    ```php
    $input = fopen("php://input", "r");
    $line = fgets($input);
    fclose($input);
    ```

    или короче:

    ```php
    $input = file_get_contents("php://input");
    ```

    Пример вывода для POST запроса:

    ```php
    param1=value1&param2=value2&param3=value3
    ```

  - `php://output`

    Поток только для записи. Позволяет записать данные в выходной буфер, аналогично `print` и `echo`.

    ```php
    $output = fopen("php://output", "w");
    
    fputs($output, "Hello world!");
    fclose($output);
    ```

  - `php://memory` и `php://temp` 

    Являются потоками для чтения/записи и позволяют сохранять временные данные в файлоподобной обертке. `php://memory` будет всегда хранить данные в оперативной памяти, тогда как `php://temp` будет использовать временный файл в том случае, когда объем хранимой информации достигнет заданного лимита (по умолчанию 2 Мб). 

    ```php
    $fp = fopen('php://memory', "rw+");
    fputs($fp, "hello,");
    fputs($fp, " world.");
    rewind($fp);
    echo fgets($fp);
    echo fgets($fp);
    fclose($fp);
    ```

  - `php://filter`

    Применяет фильтры к потоку во время открытия. Позволяет применить фильтр к потоку до того, как содержимое будет прочитано.
    
    Поток `php://filter` принимает следующие параметры как часть своего пути. В одном пути можно указать несколько цепочек фильтров. 
    
    | **Название**                                                 | **Описание**                                                 |
    | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | `resource=<поток для фильтрации>`                            | Этот параметр является необходимым. Он указывает   потоку, что его необходимо отфильтровать. |
    | `read=<список фильтров для применения к цепочке чтения>`     | Этот параметр является необязательным. Одно или более имен фильтров может быть указано здесь, разделенные вертикальной чертой   `|`. |
    | `write=<список фильтров для применения к цепочке записи>`    | Этот параметр является необязательным. Одно или более имен фильтров может быть указано здесь, разделенные вертикальной чертой  `|`. |
    | `<список фильтров для применения к обеим цепочкам чтения и записи>` | Любой список фильтров, которые используются без   префиксов `read=` или `write=`, будет применен к обоим потокам на чтение и на запись при необходимости. |
    
    Параметр `resource` должен быть расположен в конце вашей спецификации `php://filter` и должен указывать на поток, который вы хотите фильтровать.
    
    ```php
    # readfile - направление содержимого потока в поток вывода. Эквивалентно
    # readfile("http://www.example.com");
    # так как на самом деле фильтры не указаны
    readfile("php://filter/resource=http://www.example.com");
    ```
    
    ```php
    # Вывод содержимого www.example.com 
    # в верхнем регистре и кодирование алгоритмом ROT13 
    readfile("php://filter/read=string.toupper|string.rot13/resource=http://www.example.com");
    ```
    
    ```php
    # Фильтровать строку "Hello World" через фильтр rot13,
    # затем записывать результат в файл example.txt в текущей директории
    file_put_contents("php://filter/write=string.rot13/resource=example.txt","Hello World");
    ```

# Формы

При передаче методом POST параметров точки и пробелы в имени заменяются подчеркиваниями. 

```
form.x → $_POST[form_x]
form x → $_POST[form_x]
```

Создание поля с числовым ключом в POST

`<input name="param[]" />`

Создание поля с строковым ключом в POST

`<input name="param[email]" />`

## Отправка файлов

Форма:

```html
<form enctype="multipart/form-data" action="<url>" method="POST">
    <!-- Поле MAX_FILE_SIZE должно быть указано до поля загрузки файла -->
    <input type="hidden" name="MAX_FILE_SIZE" value="30000" />
    <!-- Название элемента input определяет имя в массиве $_FILES -->
    Отправить этот файл: <input name="<name>" type="file" />
    <input type="submit" value="Send File" />
</form>

```

Если задано поле `MAX_FILE_SIZE`, то его размер проверяется PHP на стороне сервера и в случае превышения пишет ошибку в `$_FILES`.

Структура `$_FILES`:

```php
$_FILES = [
	<name> => [
        'name' =>  # оригинальное имя файла на компьютере клиента
        'type' => # mime-тип файла: "image/gif"
        'size' => # размер в байтах принятого файла
        'tmp_name' => # временное имя, с которым принятый файл был сохранен на сервере
        'error' => # Код ошибки, которая может возникнуть при загрузке файла
    ]    
];
```

В случае невыбора файла, `size=0` и `name=''`

При указании массива файлов в `name="userfile[]"`, каждый из элементов массива `$_FILES` будет массивом из двух элементов, например:

```php
$_FILES = [
	<name> => [
        'name' => [
            0 => <file1_name>
            1 => <file2_name>
        ],
        ...
    ]    
];
```

# Сессии

Сессии – способ сохранения некоторых данных между несколькими последовательными доступами. 

## Принцип работы

Каждому посетителю сайта присваивается уникальный идентификатор, называемый идентификатором сессии `session_id`. Он хранится либо в *cookie* на стороне пользователя, либо передается через URL. 

Поддержка сессий позволяет сохранять данные между запросами в суперглобальном массиве `$_SESSION`. В тот момент, когда посетитель получает доступ к сайту, PHP проверяет (автоматически, если `session.auto_start=1`, или по запросу явным образом через вызов `session_start()`) наличие идентификатора сессии в заголовках запроса. Если это так, восстанавливается сохраненное ранее окружение.

`$_SESSION` сериализуются внутри PHP после выполнения запроса, используя обработчик сериализации, указанный в INI-опции `session.serialize_handler`. 

Отсутствие идентификатора сессии или сессионного *cookie* сообщает PHP о том, что необходимо создать новую сессию и сгенерировать новый `session_id`. 

PHP заполнит суперглобальную переменную `$_SESSION` сессионной информацией после того, как будет запущена сессия. 

Когда PHP завершает работу, он автоматически сериализует содержимое суперглобальной переменной `$_SESSION` и отправит для сохранения, используя сессионный обработчик для записи сессии.

Нельзя использовать ссылки в `$_SESSION`, так как не существует  способа восстановления ссылки к другой переменной.

Сессии могут запускаться:

- вручную, с помощью функции `session_start()`. 
- автоматически в начале запроса, если директива `session.auto_start=1`. 

Функция `session_start()` по умолчанию выставляет следующие заголовки:

```http
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
```

Управление выдаваемыми заголовками возможно через ini-опцию `session.cache_limiter` (варианты `public`, `private`, `nocache`, либо отключить вообще заголовки передав пустую строку `''`).

Сессия обычно завершает свою работу, когда PHP заканчивает исполнять скрипт, но может быть завершена и вручную с помощью функции `session_write_close()`.

<ins>Пример</ins>

Требуется реализовать счетчик просмотров внутри сессии:

```php
session_start();
if (!isset($_SESSION['count'])) {
    $_SESSION['count'] = 0;
} else {
    $_SESSION['count']++;
}
```

Удаление счетчика из сессии:

```php
session_start();
unset($_SESSION['count']);
```

## Места хранения сессий

Опция `session.save_handler` определяет имя обработчика, который используется для хранения и извлечения данных, связанных с сессией. По умолчанию имеет значение `files`. Все данные, связанные с конкретной сессией будут храниться в файле в директории, указанной в опции `session.save_path` файла конфигурации. Файл создается для каждой сессии (независимо от наличия ассоциированных с ней данных).

Некоторые расширения могут зарегистрировать собственные обработчики (*save_handler*), которые затем можно использовать с опцией `session.save_handler`. Так, например, доступен обработчик *redis*.

Хранение сессий в файлах имеет ряд проблем: 

- Сессии, использующие файлы, блокируют файл сессии сразу при открытии сессии. После блокировки, ни один другой скрипт не может получить доступ к этому же файлу сессии, пока он не будет закрыт. Эта проблема чаще всего проявляется с сайтами, которые делают параллельно множество запросов через AJAX. 


- доступ к диску очень медленный


- работа с сессиями нагружает I/O


- могут кончиться *inode* 


Если надежность хранения сессий не требуется, то чаще всего сессии размещают в распределенных кеширующих системах: *redis* или *memcached*.

Для *custom*'ной реализации хранения сессий можно использовать:

- функцию `session_set_save_handler()`. Порядок вызова *callback*'ов:
  - когда стартует сессия, вызывается обработчик `open` с последующим вызовом обработчика `read`, который должен вернуть закодированную строку – в точности такую, какая передавалась для сохранения. После возвращения обработчиком `read` закодированной строки, PHP декодирует ее и заполнит получившимся массивом суперглобальный массив `$_SESSION`.
  - Когда PHP завершает исполнение скрипта, PHP закодирует суперглобальный массив `$_SESSION`, и передаст эти данные с `session_id` *callback*'у `write`. После того, как отработает *callback* `write`, PHP вызовет *callback* `close`. 
  - Когда сессия будет уничтожена, PHP вызовет обработчик `destroy` с `session_id`. 
  - PHP будет вызывать *callback* `gc` время от времени, чтобы пометить сессии как истекшие в соответствии с временем жизни сессий.
- интерфейс `SessionHandlerInterface`
- расширить внутренние обработчики PHP, унаследовав класс `SessionHandler`.

PHP может отслеживать прогресс загрузки отдельных файлов при включенной опции `session.upload_progress.enabled`. Во время загрузки приложение может посылать POST-запросы на отдельную страницу (например, с помощью XHR) для проверки статуса.

## Защита сессий

Основная проблема при защите сессий – утечка существующего идентификатора сессии третьим лицам. 

Основные способы защиты:

- защита от XSS и кражи *cookie*
- `session.use_strict_mode = 1` – запрещается получение от клиента неинициализированного `session_id`. Это не позволяет злоумышленнику рассылать ссылки, с известным ему заранее `session_id`. 
- Пересоздание идентификаторов сессий сильно уменьшает риск кражи сессии, соответственно надо на переодической основе запускать `session_regenerate_id()`.

- Разработчики должны следить за активными сессиями каждого пользователя и оповещать его, сколько есть активных сессий, с каких IP (и где географически), как долго они активны и т.д. Если обнаружена попытка доступа к устаревшей сессии, необходимо сбросить флаги авторизации для всех активных сессий пользователя.


# Регулярные выражения

## Функции для работы

### `preg_match`

Ищет в заданном тексте `$subject` совпадения с шаблоном `$pattern`.

```php
preg_match ( string $pattern , string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0 ]]] ) : int
```

<ins>Параметры</ins>

- `$pattern` – регулярное выражение

- `$subject` – сопоставляемая строка

- `$matches`  – результаты сопоставления. Причем:
  - ` $matches[0]` – содержит часть строки, соответствующую вхождению всего шаблона
  -  `$matches[1]` – часть строки, соответствующую первой подмаске 
  - и так далее.

- `$flags`

  Возможен флаг:

  - `PREG_OFFSET_CAPTURE`

    Для каждой найденной подстроки будет указана ее позиция в исходной строке. Т.е. флаг меняет формат `$matches`, так что каждый элемент будет содержать массив, где:

    - индекс `[0]` – найденная подстрока, 
    - индекс `[1]` – смещение этой подстроки в `$subject`.

    ```php
    preg_match('/foo(bar)baz/', 'foobarbaz', $matches, PREG_OFFSET_CAPTURE);
    print_r($matches);
    ```

    Вывод:

    ```php
    Array
    (
        [0] => Array
            (
                [0] => foobarbaz
                [1] => 0
            )
        [1] => Array
            (
                [0] => bar
                [1] => 3
            )
    )
    ```

  - `offset` – Начальная позиция для поиска (в байтах).

    Использование параметра `$offset` не эквивалентно замене сопоставляемой строки выражением `substr($subject, $offset)` при вызове функции `preg_match()`, поскольку шаблон `$pattern` может содержать такие условия как `^`, `$` или `(?<=x)`. 

    В примере строка не соответствует паттерну:

    ```php
    $subject = "abcdef";
    $pattern = '/^def/';
    preg_match($pattern, $subject, $matches, PREG_OFFSET_CAPTURE, 3);
    print_r($matches); # Array ()
    ```

<ins>Возвращаемые значения</ins>

- `1`, если `$pattern` соответствует `$subject`, 

- `0`, если нет

- `false` в случае ошибки.

### `preg_match_all`

Ищет в строке `$subject` все совпадения с шаблоном `$pattern` и помещает результат в массив `$matches` в порядке, определяемом комбинацией флагов `$flags`.

После нахождения первого соответствия последующие поиски будут осуществляться с позиции последнего найденного вхождения.

```php
preg_match_all ( string $pattern , string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0 ]]] ) : int
```

<ins>Параметры</ins>

- `$pattern`, `$subject`, `$matches`, `$offset` – имеют тот же смысл, что и в функции `preg_match()`. Параметр `$matches` будет содержать многомерный массив.

- `$flags`

  Может быть указан, как один из двух флагов:

  - `PREG_PATTERN_ORDER`

    Возвращает в `$matches` массив с элементами–подмассивами, соответствующими номеру открывающей скобки `(`. Т.е. в общем виде обращение к конкретному совпадению имеет вид: `$matches[B][N]`, где `B` — порядковый номер открывающей скобки `(` в шаблоне, a N — номер совпадения, если было несколько совпадений. 

    Например:

    - в `$matches[0]` будет содержаться список подстрок, ПОЛНОСТЬЮ совпавших c шаблоном `$pattern`
    - в `$matches[1]` — список совпадений, которым соответствует первая открывающая скобка
    - и т. д. 

    Данный режим подразумевается по умолчанию.

    ```php
    preg_match_all('/(.)(.)/','abcd', $matches, PREG_PATTERN_ORDER);
    var_dump($matches);
    array(3) {
      [0]=>
      array(2) {
        [0]=>
        string(2) "ab"
        [1]=>
        string(2) "cd"
      }
      [1]=>
      array(2) {
        [0]=>
        string(1) "a"
        [1]=>
        string(1) "c"
      }
      [2]=>
      array(2) {
        [0]=>
        string(1) "b"
        [1]=>
        string(1) "d"
      }
    }
    ```

  - `PREG_SET_ORDER`

    Наиболее интуитивный режим поиска. Возвращает в `$matches` массив с элементами– подмассивами, соответствующими номеру совпадения.  Т.е. сколько раз шаблон `$pattern` совпал, столько элементов и окажется в `$matches`. При этом каждый элемент будет иметь точно такую же структуру, как и при вызове обычной функции `preg_match()`, а именно, это список совпавших скобочных выражений:

    - нулевой элемент `0` — все выражение
    - первый `1` — первая скобка
    -  и т. д. 

    Обращение к массиву организуется так: `$matches[N][B]`, где `N` — порядковый номер совпадения, а `B` — номер скобки.

    ```php
    preg_match_all('/(.)(.)/','abcd', $matches, PREG_SET_ORDER);
    var_dump($matches);
    array(2) {
      [0]=>
      array(3) {
        [0]=>
        string(2) "ab"
        [1]=>
        string(1) "a"
        [2]=>
        string(1) "b"
      }
      [1]=>
      array(3) {
        [0]=>
        string(2) "cd"
        [1]=>
        string(1) "c"
        [2]=>
        string(1) "d"
      }
    }
    ```

  - `PREG_OFFSET_CAPTURE`

    К двум, указанным выше флагам может быть добавлен флаг `PREG_OFFSET_CAPTURE`. Для каждой найденной подстроки будет указана ее позиция в исходной строке. Он меняет формат каждого совпадения в массиве `$matches` так (аналогично `preg_match()`):

    - в индексе `0` содержится найденная подстрока
    - в индекса `1` – смещение этой подстроки.

    ```php
    preg_match_all('/(.)(.)/','abcd', $matches, PREG_SET_ORDER | PREG_OFFSET_CAPTURE);
    var_dump($matches);
    array(2) {
      [0]=> array(3) {
        [0]=> 
        array(2) {
          [0]=> string(2) "ab"
          [1]=>
          int(0)
        }
        [1]=>
        array(2) {
          [0]=>
          string(1) "a"
          [1]=>
          int(0)
        }
        [2]=>
        array(2) {
          [0]=>
          string(1) "b"
          [1]=>
          int(1)
        }
      }
      [1]=>
      array(3) {
        [0]=>
        array(2) {
          [0]=>
          string(2) "cd"
          [1]=>
          int(2)
        }
        [1]=>
        array(2) {
          [0]=>
          string(1) "c"
          [1]=>
          int(2)
        }
        [2]=>
        array(2) {
          [0]=>
          string(1) "d"
          [1]=>
          int(3)
        }
      }
    }
    ```

<ins>Возвращаемое значение</ins>

- Возвращает количество найденных вхождений шаблона (которое может быть и нулем) либо `false`, если во время выполнения возникли какие-либо ошибки.


### `preg_replace`

Поиск в строке `$subject` всех подстрок, совпадающих с выражением `$pattern`, и замена их на `$replacement`.

```php
preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed
```

<ins>Параметры</ins>

- `$pattern`

  Шаблон для поиска в строке. Может быть строкой или массивом строк.

- `$replacement`

  `string` или `string[] ` для замены. Если этот параметр является строкой, а `$pattern` является массивом, каждый шаблон из `$pattern` будет заменен этой строкой. Если и `$pattern` и `$replacement` являются массивами, каждый элемент `$pattern` будет заменен соответствующим элементом из `$replacement`.

  `$replacement` может содержать ссылки вида `\\\\n`, либо `$n`, причем последний вариант предпочтительней. Каждая такая ссылка будет заменена на подстроку, соответствующую `n`-ой подмаске. `n` может принимать значения от `0` до `99`, причем `$0` соответствует вхождению всего шаблона. 

- `$subject`

  Строка или массив строк для поиска и замены. 

  Если `$subject` является массивом, то поиск с заменой осуществляется для каждого элемента массива `$subject`, а возвращаемое значение также будет являться массивом.

- `$limit`

  Максимально возможное количество замен каждого шаблона для каждой строки `$subject`. По умолчанию равно -1 (без ограничений).

- `$count`

  Если указана, то эта переменная будет заполнена количеством произведенных замен.

<ins>Возвращаемые значения</ins>

- Если параметр `$subject` является массивом – возвращает массив, иначе возвращается строка.


### `preg_replace_callback`

Работает аналогично `preg_replace()`, только вместо замены строкой `$replacement` запускает функцию `$саllback` и передает ей содержимое карманов при очередном совпадении. Результат, возвращенный функцией, используется для подстановки.

```php
preg_replace_callback ( mixed $pattern , callable $callback , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed
```

<ins>Параметры</ins>

- `$pattern`, `$subject`, `$limit`, `$count` 

  имеют тот же смысл, что и в функции `preg_replace()` 

- `$callback`

  Вызываемая *callback*-функция, которой будет передано содержимое карманов при очередном совпадении. Прототип функции следующий:

  ```php
  function handler ( array $matches ) : string
  ```

  Удобно использовать в качестве `$callback` анонимную функцию.

<ins>Возвращаемое значение</ins>

Возвращает измененную строку, а если параметр `$subject` является массивом – возвращается массив. 

<ins>Пример:</ins> 

Требуется преобразовать название всех тегов в верхний регистр:

```php
$str = '<html><body class="">Hello world!</body></html>';
var_dump(preg_replace_callback(
			'|(</?)(\w+)(.*?>)|',
			function ($matches) {
                   return $matches[1].mb_strtoupper($matches[2]).$matches[3];
            },$str));
# string(47) "<HTML><BODY class="">Hello world!</BODY></HTML>"
```

### `preg_replace_callback_array`

```php
preg_replace_callback_array ( array $patterns_and_callbacks , mixed $subject [, int $limit = -1 [, int &$count ]] ) : mixed
```

Работает аналогично `preg_replace_callback()`. Однако `$pattern` и `$callback` совмещены в первом параметре `$patterns_and_callbacks` – это ассоциативный массив, ключами которого выступают шаблоны `$pattern`, а значениями — функции обратного вызова `$callback`. В итоге для каждого `$pattern` используется соответствующая ему функция обратного вызова `$callback`.

### `preg_split`

```php
preg_split ( string $pattern , string $subject [, int $limit = -1 [, int $flags = 0 ]] ) : array
```

Эта функция очень похожа на функцию `explode()`. Она тоже разбивает строку `$subject` на части, но делает это, руководствуясь регулярным выражением `$pattern`. А именно те участки строки, которые совпадают с этим выражением, и будут служить разделителями.

<ins>Параметры</ins>

- `flags`

  Может быть любой комбинацией следующих флагов (объединенных с помощью побитового оператора `|`):

  - `PREG_SPLIT_NO_EMPTY`

    Из результирующего списка будут удалены элементы, равные пустой строке.

  - `PREG_SPLIT_DELIM_CAPTURE`

    В результат будут включены не только участки строк между совпадениями, но также и сами совпадения. 

  - `PREG_SPLIT_OFFSET_CAPTURE`

    Тот же флаг, что возможен для `preg_match()` и `preg_match_all()`, который меняет формат возвращаемого массива. Функция возвращает массив из массивов, у которых:

    - `0` элемент – подстрока
    - `1` элемент – позиция

<ins>Пример</ins>

Найти все уникальные слова в тексте

```php
$words = preg_split("/(\s+)/", 'ab cd ab');
var_dump(array_unique($words));
array(2) {
  	[0] => string(2) "ab"
  	[1] => string(2) "cd"
}
```

### `preg_quote`

Экранирует все управляющие символы ([1](#управляющие-символы)) регулярных выражений во входной строке `$str`, путем добавления обратного слеша. Полезна в том случае, если шаблон `$pattern` формируется динамически в процессе работы скрипта.

```php
preg_quote ( string $str [, string $delimiter = NULL ] ) : string
```

<ins>Параметры:</ins>

- `$delimiter`

  Через этот параметр можно дополнительно указать символы, которые нужно экранировать. Чаще всего используется для экранирования ограничителя (наиболее распространенный разделитель `/`).

<ins>Пример:</ins> 

Требуется поместить в теги `<b>...</b>` некоторую фразу переданную в функцию, возможно содержащую управляющие символы.

```php
function highlight($phrase, $text)
{
    $re = '/'.preg_quote($phrase, "/").'/';
    return preg_replace($re, '<b>$0</b>', $text);
}

var_dump(highlight('|', '| ^ |')); # string(19) "<b>|</b> ^ <b>|</b>"
```

### `preg_grep`

Возвращает массив, состоящий из элементов входящего массива `$input`, которые соответствуют заданному шаблону `$pattern`.

```php
preg_grep ( string $pattern , array $input [, int $flags = 0 ] ) : array
```

<ins>Пример:</ins> 

Найти все элементы массива, которые состоят только из цифр

```php
$arr = [1, '23', 'ab'];
var_dump(preg_grep('/^\d+$/', $arr));
# array(2) {
#  [0]=> int(1)
#  [1]=> string(2) "23"
# }
```

## Управляющие символы

К управляющим символам относятся следующие: `\`, `.` , `*`, `+`, `?` , `|`, `(`, `)`, `[`, `]`, `{`, `}`, `$`, `^`. Все остальные символы обозначают сами себя. 

## Ограничители паттерна

Паттерн должен быть заключен между ограничителями. По умолчанию, в литературе в качестве ограничителя используется символ `/`. После заключительного ограничителя могут быть указаны модификаторы. 

```regexp
/expr/M
```

где `M` обозначает ноль или более модификаторов. 

Рекомендуется использовать для записи паттерна строку в апострофах `''`, а не в кавычках `""`. Так как символ `$` (начало строки в регулярках) также обозначает в кавычках переменную в РНР. 

Если ограничитель часто используется в паттерне, в целях удобочитаемости (чтобы его не экранировать), лучше выбрать другой ограничитель для этого шаблона. Ограничителем может быть любой символ не являющийся буквой, цифрой, обратной косой чертой или каким-либо пробельным символом, например:

```php
'#path/to/file#i'
'"path/to/file"i'
'+ path/to/file+'
```

Скобки в качестве ограничителя используются парой: стартовый и завершающий ограничитель являются соответственно открывающей и закрывающей скобками. Допустимые ограничители: `()`, `{}`, `[]` и `<>`:

```php
'(path/to/file}i'
'[path/to/file]i'
'{path/to/file}i'
```

Если ограничители-скобки встречаются внутри паттерна, то их не нужно экранировать обратным слешем, т.к. анализатор PCRE самостоятельно "считает" вложенность скобок. Например, это корректно:

```php
'[a[0-9]b]i'
```

Если ограничитель (например, `/`) встречается в паттерне, перед ним необходимо поставить обратный слеш `\` для экранирования. В строках PHP один слеш записывается как `//`.

```php
preg_match('/path\\/to\\/file/i', "path/to/file");
```

Например, стоит задача найти в строке имя файла, предваренное обратным слешем `\` (как в Windows). Выражение записывается так:

```php
$rе = '/\\\\filename/';
```

Один слеш превратился в четыре, так как:

1. Удвоенный слеш в строках РНР обозначает один слеш. Это видно на примере:

   ```php
   echo '/\\\\filename/'; # /\\filename/
   ```

2. Слеш ` \`является специальным символом в PCRE, он позволяет экранировать управляющие символы. Поэтому удвоенный слеш означает один слеш. Таким образом, получив на вход выражение `/\\filename/`, анализатор поймет, что от него требуется найти nодстроку, начинающуюся с одного слеша. 

Например, если требуется найти подстроку `а*b`, то символ `*` необходимо экранировать в выражении `а\*b` (в РНР соответветственно `а\\*b`), т.к. символ `*` является управляющим.

Стоит обратить внимание, что зачастую можно не удваивать для PHP слеши в конструкциях вида `\*`, `\s` и т.д. Хотя их следовало бы записать как `\\*` и `\\s`, но РНР может проверить самостоятельно, что после слеша стоит буква (`*`, `s` и т.д.), не входящая ни в один строковый метасимвол, не выдает ошибок и не трубует записывать удвоенный слеш.

```php
var_dump("\\* \\s"); # string(2) "\* \s"
var_dump("\* \s");   # string(2) "\* \s"
```

### Модификаторы

Модификаторы указываются после заключительного ограничителя.

#### Модификатор `i` (*case insensitive*)

По умолчанию, проводится точное сравнение символов шаблона и строки. Модификатор `i` позволяет включить режим игнорирования регистра.

Для корректной работы с русскими буквами в UTF8 необходимо:

- правильно настроить локаль (функция `setlocale()`).


- дополнительно использовать модификатор `u`.


#### Модификатор `х` (*extended*)

При наличии данного модификатора пробельные символы (в том числе перевод строки), не являющиеся частью символьного класса, а также однострочные комментарии, предваренные решеткой (`#`) будут проигнорированы в шаблоне.

Пример шаблона поиска парных тегов:

```php
$pattern = '|
    <(\w+)> # открывающий тег
    (.*?)  # минимум любых символов
    </\1>  # и закрывающий тег, парный открывающему
|ixs';
```

#### Модификатор `m` (*multiline*, многострочность)

Модификатор многострочного режима `m` меняет поведение некоторых управляющих символов:

- Мнимый символ `^` соответствует теперь не только началу всей строки, но и началу каждой внутренней подстроки, т.е. позиции после символа `\n`.


- Мнимый символ `$` соответствует теперь не только концу всей строки, но и концу каждой внутренней подстроки, т.е. позиции перед символом `\n`.

Важно, что символ `\r` считается обычным символом и не относится к концу строки. Поэтому:

```php
var_dump(preg_match('/a$/m', "a\r\n"));
# int(0)
```

Для корректной работы регулярных выражений иногда нужно предварительно удалить из строки все знаки `\r`.

Так как символы в данном режиме `^` и `$` меняют свой смысл, для поиска начала и конца данных необходимо использовать `\A`, `\z`, `\Z`.

<ins>Пример:</ins> добавить знак табуляции в начале каждой строки: 

```php
$str = preg_replace('/^/m', "\t", $str);
```

#### Модификатор `s` (*singleline*, однострочность)

При использовании модификатора символ "точка" `.`  начинает соответствовать всем символам, включая перевод строк `\n`. 

Символьный класс с отрицательной логикой всегда соответствует переводу строки `\n` вне зависимости от наличия модификаторов:

```php
var_dump(preg_match('/./', "\n"));  # int(0)
var_dump(preg_match('/./s', "\n")); # int(1)
```

#### Модификаторы `m` и `s` по умолчанию

Умолчания:

- в функциях поиска (`preg_match()`) по умолчанию действует модификатор `m`
- в функциях замены (`preg_replace()`) по умолчанию действует модификатор `s`

Рекомендуется для надежности всегда явно указывать модификатор `m` или `s`.

#### Модификатор `u` (UTF-8)

Шаблон и целевая строка начинают рассматриваться как строки в формате UTF-8. Он **ДОЛЖЕН**  включаться, если в строке есть русские символы. 

## Простые символы (литералы)

Любой символ в выражении обозначает сам себя, если он не является управляющим. Для вставки управляющего символа (например, `*` ) – его нужно экранировать слешем `\`.

## Общие типы символов

| Тип символов | Описание                                                     |
| ------------ | ------------------------------------------------------------ |
| `.` (точка)  | Любой символ, кроме перевода строки `\n` (в обычном режиме, без   модификатора `s`) |
| `\s`         | Пробельный символ (пробел, `\t`, `\r`, `\n`)                 |
| `\S`         | Не пробельный символ                                         |
| `\w`         | Буква или цифра                                              |
| `\W`         | Не буква и не цифра                                          |
| `\d`         | Цифра (`0-9`)                                                |
| `\D`         | Не цифра (`0-9`)                                             |

## Символьные классы (квадратные скобки `[]`)

### Положительная логика

Символьные классы при положительной логике позволяют искать один из нескольких указанных символов. Для этого символы заключаются в квадратные скобки:

```regexp
/а[ххуу]с/
```

Внутри скобок специальными символами являются только: `\`, `-`, `]` (не вначале), `^` (вначале). Т.е. остальные символы не являются специальными и не требуют экранирования.

Внутри скобок символ `-` (дефис) используется для задания диапазона символов. Можно указать сразу несколько диапазонов символов. 

```regexp
/[a-z]/        # Буквы a-z
/[a-zA-Z0-9+]   # Буквы в любом регистре, цифры, символ +
```

Внутри скобок `[]` можно использовать классы символов в формате `[:класс:]`. Поддерживаются следующие классы:

| Символьный класс | Описание                                                  |
| ---------------- | --------------------------------------------------------- |
| `[:alpha:]`      | Буква                                                     |
| `[:digit:]`      | цифра (то же самое, что и `\d`)                           |
| `[:alnum:]`      | буква или цифра                                           |
| `[:space:]`      | пробельный символ(почти то же самое, что и `\s`)          |
| `[:blank:]`      | только пробел или символ табуляции                        |
| `[:cntrl:]`      | управляющий символ                                        |
| `[:graph:]`      | печатный символ, исключая пробел                          |
| `[:lower:]`      | символ нижнего регистра                                   |
| `[:upper:]`      | символ верхнего регистра                                  |
| `[:print:]`      | печатный символ, включая пробел                           |
| `[:punct:]`      | печатный символ, исключая буквы и цифры (знак пунктуации) |
| `[:ascii:]`      | символ с кодом 0 - 127                                    |
| `[:word:]`       | буква или цифра (то же самое, что и `\w`)                 |
| `[:xdigit:]`     | шестнадцатеричная цифра                                   |

Эти классы моrут встречаться *только* внутри скобок `[ ]`, т.е. недопустимо:

```php
'/abc[:alnum:]+/'   # Недопустимо
'/abc[[:alnum:]]+/' # Правильно
```

Внутри скобок `[ ]` также можно использовать символы-классы, описанные в предыдущем подразделе ([1](#общие-типы-символов)). Например:

```php
'/abc[\w.]/'
```

ищет подстроку `'abc'`, после которой идет любая буква, цифра или точка (точка не является специальным символом). 

### Отрицательная логика

Если при сопоставлении устраивают все символы, за исключением некоторых, проще не перечислять устраивающие символы, а использовать отрицательную логику и указать те, которые нас не устраивают. 

Если первым символом в скобках `[ ]` является `^`, логика работы инвертируется: класс соответствует любому одиночному символу, кроме тех что перечислены в скобках `[ ]`. Например:

```regexp
/<[^>]+>/
```

находит начало тега `<`, за которым следуют любые символы, кроме `>`, завершающиеся символом `>`, закрывающим тег. Эта конструкция предназначена для поиска тегов в строке, однако может срабатывать неправильно, если внутри тега содержится символ `>`, например неверно выделит тег в примере:

```html
<img src="1.gif" alt="a>b">
```

## Квантификаторы повторений

### Общий квантификатор повторения `{ }`

Указывает минимальное и/или максимальное допустимое количество совпадений, согласно двум числам, заключенными в фигурные скобки `{ }` и разделенными запятой. 

Все квантификаторы (общий квантификатор и односимвольные `*`, `+`, `?`) по умолчанию **жадные**.

Разновидности общего квантификатора повторений:

- `X{n,m}` — символ `X` повторяется от `n` до `m` раз;

- `X{n}` — символ `X` повторяется ровно `n` раз;

- `X{n,}` — символ `X` повторяется `n` или более раз.

Для удобства три наиболее распространённых квантификатора можно записать  одним символом.

| Символ | Квантификатор        |
| ------ | -------------------- |
| `*`    | эквивалентен `{0,}`  |
| `+`    | эквивалентен `{1,}`  |
| `?`    | эквивалентен `{0,1}` |

### Жадные и ленивые квантификаторы

Все квантификаторы (общий квантификатор и односимвольные `*`, `+`, `?`) по умолчанию **жадные**, т.е. пытаются захватить максимально возможное число символов.

В примере ниже, квантификатор сработает некорректно и захватит текст от первого открывающего тега до последнего закрывающего:

```php
$str = "Begin <b>Bold</b> Middle <b>Bold</b> End";
$pattern = "|<b>.*</b>|";
preg_match($pattern, $str, $matches);
var_dump($matches);
# array(1) {
#    [0]=>
#  string(30) "<b>Bold</b> Middle <b>Bold</b>"
# }
```

Если сразу же после квантификатора идет вопросительный знак `?`, он становится «ленивым» и соответствует минимально допустимому количеству раз. Соответственно возможны ленивые квантификаторы `*?`,`+?`, `{}?` и `??`.

Обычно "ленивые” квантификаторы применяют для поиска конструкций, претендующих на роль парных. Например, следующий код удаляет все теги из строки (т.е. текст между парными символами `<` и `>`):

```php
echo preg_replace('/<.+?>/s', '', $str);
```

### Рекурентные структуры

Под «рекуррентными» структурами подразумеваются те, которые имеют вложенные элементы, например:

```php
$html = '<div>Внешний блок<div>Внутренний блок</div> вернулись</div>';
```

Корректно выявить «рекуррентные» структуры с помощью PCRE невозможно, ни жадные, ни ленивые квантификаторы в этой задаче не работают.

```php
$html = '<div>Внешний блок<div>Внутренний блок</div> вернулись</div>';
preg_match('|<div>.*</div>|', $html, $matches1);
preg_match('|<div>.*?</div>|', $html, $matches2);
var_dump($matches1[0]); 
# string(93) "<div>Внешний блок<div>Внутренний блок</div> вернулись</div>"
var_dump($matches2[0]); 
# string(68) "<div>Внешний блок<div>Внутренний блок</div>"
```

Регулярные выражения тут могут помочь только найти подстроки, но вести учет вложенности нужно вручную (кстати, тут удобно использовать стек и функции `array_push()` и `array_pop()`).  

## Мнимые символы 

Мнимый символ — это некая позиция в строке. 

Перечень мнимых символов:

- `^` — соответствует началу строки (не первому символу строки, а в точности началу строки, позиции перед первым символом);

- `$` — соответствует концу строки (т.е. позиции за концом строки), либо позиции перед завершающим текст `\n`, т.е:

  ```php
  var_dump(preg_match('/a$/', "a\n")); 
  # int(1)
  ```

- `\A` –  начало данных (позиция перед первым символом). В многострочном режиме `/ /m` отличается от `^`.

- `\z` –  строго конец данных (позиция после последнего символа). В многострочном режиме `/ /m` отличается от `$`.

- `\Z` – конец данных, либо позиция перед завершающим текст `\n`.

- `\b` — соответствует началу или концу слова (т.е. позиции между `\w\W` или `\W\w`)

- `\B` — любая позиция, кроме начала или конца слова.

Если шаблон ограничен совпадением в начале строки (с помощью `\A` или с помощью `^` в однострочном режиме), то говорят что шаблон "заякорен". 

## Оператор альтернативы

Если необходимо задать оператор альтернативы для отдельных символов, то следует использовать символьные классы (квадратные скобки `[ ]`, [1](#символьные-классы)).

Для указания альтернативы между группами символов необходимо использовать оператор `|`. 

Особенности:

- Альтернативы проверяются слева направо, поиск останавливается после первого найденного соответствия.


- Оператор `|` пытается применить себя к *как можно более длинной* последовательности команд, т.е. считает за альтернативу все, что не ограничено скобками `()`


- Оператор `|` работает медленнее, чем символьные классы `[ ]`.


<ins>Пример</ins>: 

Проверить, что строка содержит имя файла в формате GIF или JPEG:

```regexp
/\.gif$|\.jpe?g$/
```

Допускается указывать пустые альтернативы:

```regexp
/cat|dog|/
```

Этот шаблон совпадет с любой строкой, т.к. соответствует пустой строке.

## Скобки

Скобки могут имеют две функции.

### Группирующие скобки

Для ограничения списка альтернатив при использовании оператора `|`, т.к. без скобок оператор `|` пытается применить себя к *как можно более длинной* последовательности команд.

Например, этот шаблон соответствует строкам `cat`, `cataract` или `caterpillar`:

```regexp
/cat(aract|erpillar|)/
```

Без использования скобок он соответствовал бы строкам `cataract`, `erpillar` или пустой строке.

```regexp
/cataract|erpillar|/
```

### Подмаски (карманы)

Скобки используются для выделения подмаски (части шаблона). По подмаске в совпадении можно выделенить соответствующую подстроку. Подстрока, соответствующая подмаске (части шаблона в скобках), записывается в "карман”. 

Карманы нумеруются по порядку открывающихся круглых скобок слева направо, независимо от вложенности. Нумерация начинается с 1. В нулевой карман записывается все найденное совпадение. 

#### Использование карманов в `preg_match()`

Содержимое карманов возвращается в третьем параметре `$matches` функции `preg_match()`.

```php
preg_match("/(\d+):(\d+)/", "12:34", $matches);
var_dump($matches); 
# array(3) {
#       [0]=> string(5) "12:34"
#       [1]=> string(2) "12"
#       [2]=> string(2) "34"
# }
```

#### Использование карманов в `preg_replace()`

Параметр `$replacement` функции `preg_replace()` может содержать ссылки вида `$n`. Каждая такая ссылка будет заменена на подстроку, соответствующую `n`-ой подмаске. `n` может принимать значения от `0` до `99`, причем ссылка `$0` соответствует вхождению всего шаблона. Вместо `$1` можно также использовать сочетание `\1` (т.е. в строке PHP `\\1`).

Пример: нужно все имена переменных PHP (т.е. слова, начинающиеся с "доллара" (`$`),обрамить тегами `<b>…</b>`:

```php
$text = '$a $b';
$pattern = '/(\$[a-z]\w*)/is';
echo preg_replace($pattern, '<b>$1</b>', $text);

# <b>$a</b> <b>$b</b>
```

#### Обратная ссылка

Обратные ссылки позволяют задействовать содержимое карманов в функциях `preg_match()` и `preg_replace()` раньше, чем закончится сопоставление целиком. В шаблоне обратный слеш с последующей цифрой больше нуля (`\n`) интерпретируется как ссылка на предшествующую подмаску с соответствующим номером `n`. 

Указать обратную ссылку на именованную подмаску можно с помощью `\g<name>` или `\g'name'`.

<ins>Пример</ins>: 

Требуется найти текст, обрамленный любыми парными HTML-тегами: 

```php
$text = '<tag id="t">Content</tag>';
$pattern = '|<(\w+).*?>(.*?)</\1>|';
preg_match($pattern, $text, $matches);
var_dump($matches);
# array(3) {
#    [0]=> string(18) "<tag>Content</tag>"
#    [1]=> string(3) "tag"
#    [2]=> string(7) "Content"
# }
```

#### Игнорирование карманов

Если круглые скобки используются исключительно для группировки символов, т.е. без необходимости выделения подмаски, то сразу после открывающейся круглой скобки можно указать последовательность `?:`. Такой карман не попадет в массив `$matches` функции `preg_match()` и не может использоваться при замене в `preg_replace()`:

```php
preg_match('/(?:a)(b)/', 'ab', $matches);
var_dump($matches);
# array(2) {
#    [0]=>
#  string(2) "ab"
#    [1]=>
#  string(1) "b"
# }
```

#### Именованные карманы

Чтобы не путаться с номерами карманов, особенно при отладке регулярных выражений, удобно использовать именованные карманы. Для этого после открывающейся круглой скобки указывается знак вопроса, после которого в угловых скобках или апострофах задается имя кармана. В параметре `$matches` к числовым ключам, дополнительно добавляются дублирующие ключи с именами карманов:

```php
$str = "abc123def";
$pattern = "|^.+(?<digits>\d+).+$|";
preg_match($pattern, $str, $matches);
var_dump($matches);
# array(3) {
#    [0]=>
#  string(9) "abc123def"
#    ["digits"]=>
#  string(1) "3"
#    [1]=>
#  string(1) "3"
# }
```

## Незахватывающий поиск

Конструкции незахватывающего поиска позволяют найти *позицию* в строке без захвата каких-либо подстрок и изменения текущей позиции поиска. Такие конструкции *имеет нулевую ширину совпадения*, т.е. заключив конструкцию в круглые скобки, мы всегда получим в кармане строку нулевой длины. 

К таким конструкциям относятся мнимые символы `$`, `^`, `\A`, `\z`, `\Z`, `\b`, `\B`. Также имеется набор более сложных конструкций – утверждений. Уверждения – это проверка относительно символов, стоящих перед или после текущей позиции сопоставления, без захвата символов. Утверждения записываются в круглых скобках (как подмаски).

### Позитивный просмотр вперед

```regexp
(?=подвыражение)
```

Когда в выражении встречается такая конструкция, текущая позиция считается допустимой, если с нее начинается подстрока, совпадающая с подвыражением в скобках. При этом «захвата» символов не происходит, и следующая конструкция будет работать с той же самой позиции в строке, которой только что «дали добро».

На подвыражение в скобках не накладываются никакие ограничения: это может быть полноценное регулярное выражение.

<ins>Пример</ins>:

Заменить букву `a`, за которой сразу идет буква `b`, на букву `z`. При этом букву `b` не трогать:

```php
var_dump(preg_replace('/a(?=b)/', "z","abacadbab"));
# string(9) "zbacadbzb"
```

### Негативный просмотр вперед

Утверждение о том, что с текущей позиции не начинается некоторое подвыражение. 

```regexp
(?! подвыражение)
```

Удобно использовать для условий вида: выбрать по регулярному выражению, за исключением одного (нескольких) случаев. Что-то вроде инструкции `continue` в начале цикла, которая по условию пропускает некоторые итерации.

<ins>Пример</ins>:

Требуется найти любую цифру за исключением `5` и заменить на букву `z`:

```php
var_dump(preg_replace('/(?!5)\d/', "z", "123456789"));
# string(9) "zzzz5zzzz"
```

#### Позитивный просмотр назад

Используется подмаска:

(?<=подвыражение)

Пример: найти название тега из одного слова:

/

​     {?<=<) # слева идет "<" — начало тега...

​     (\w+)  # дальше – слово с названием тега

/х

На подвыражения внутри (?<=...) накладывается ограничение: оно должно быть фиксированной "ширины", или каждая альтернатива из набора должна иметь фиксированную ширину. 

Например, следующее выражение допустимо:

$pattern = **'/ (?<=** **1 | 2) (\w+)/x'**;

 *var_dump*(*preg_match*($pattern, **'2abc'**)); *# int(1)*

А в примере ниже выбрасывается ошибка:

**$pattern** **=** '/ (?<= 2*) (\w+)/x'**;**
 **preg_match(****$pattern****,** '2abc'**);** 

\# Compilation failed: lookbehind assertion is not fixed length 

#### Негативный просмотр назад

Используется подмаска:

(?<!подвыражение)

Заменить все цифры, которым не предшествуют другая цифра, на букву z.

var_dump(preg_replace(**'/(?<!\d)\d/'**, **'z'** ,**'12a34'**));
 \# string(5) "z2az4"

 

 

## Библиотеки функций

Порядок параметров функций:

- функции для работы с массивами – `function(needle, haystack, ...)`
- строковые функции – `function(haystack, needle, ...)`

### Для работы с массивами

count(array_or_countable)

Возвращает количество элементов в array_or_countable. Если параметр не является массивом или объектом, реализующим интерфейс Countable, будет возвращена 1. Однако count(NULL)=0.

array **array_map** ( [callable](http://php.net/manual/ru/language.types.callable.php) `$callback` , array `$array1` [, array `$...` ] )

bool **array_walk** ( array `&$array` , [callable](http://php.net/manual/ru/language.types.callable.php) `$callback` [, [mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) `$userdata` = `NULL` ] )

Обе применяют callback-функцию ко всем элементам указанных массивов. Но array_map копирует массив и возвращает копию, а array_walk получает массив по ссылке и не копирует его.

 

### Для работы с БД Mysql

Для работы с mysql в PHP используется драйвер mysqlnd (native driver). mysqlnd создавался специально для PHP систем, у него есть преимущество в скорости и расходах памяти перед libmysqlclient. Поэтому его использование предпочтительней. Он предоставляет 3 API: mysql, mysqli (improved, улучшенный) и PDO.  

#### Mysqli

Mysqli на 6% быстрее PDO и поддерживает дополнительные фичи, например, асинхронные запросы. Поддерживаются процедурная и объектно-ориентированная парадигмы. Особенности:

·      Объектно-ориентированный интерфейс

·      Поддержка подготавливаемых запросов

·      Поддержка мультизапросов

·      Поддержка транзакций

·      Улучшенные возможности отладки

·      Поддержка встроенного сервера

Функция mysqli_query() использует текстовый протокол, т.е. запрос отправляется в текстовом виде и все данные в результирующем наборе также преобразуются в текстовые строки. Можно указать параметром MYSQLI_STORE_RESULT – буферизированный результат, MYSQLI_USE_RESULT – небуферизированный.

##### Подготовленные запросы. 

Каждый подготавливаемый запрос использует ресурсы сервера. Если запрос больше не нужен, его необходимо сразу закрыть. Использование подготавливаемых запросов не всегда приводит к повышению эффективности. Иногда удобнее использовать не несколько однотипных запросов, а один запрос, выполняющий все операции за несколько (например INSERT (1,2,3), а не отдельные запросы INSERT).

Параметризованные запросы используют двоичный протокол, в том числе и для возврата результата: 

$stmt = $mysqli->prepare("SELECT id, label FROM test WHERE id = 1");

$stmt->execute();

$res = $stmt->get_result();

var_dump($res->fetch_assoc());

id = 1 (integer)

Можно настроить и обычный запрос на возврат результата в нужном типе через параметр `MYSQLI_OPT_INT_AND_FLOAT_NATIVE`.

Результаты из подготовленного запроса можно получить либо привязав выходные переменные, либо запросив результат через get_result.

$stmt->bind_result($out_id, $out_label)

Подготавливаемые запросы по умолчанию возвращают не буферизованные результирующие наборы (например, путем bind_result и последующего fetch), занимая ресуры сервера. Можно буферизовать данные с помощью функции store_result(). Также можно вместо использования привязки переменных к результатам запроса использовать get_result(), который возвращает буферизованный результирующий набор строк.

###### *Привязывание переменных к параметрам запроса*

Также можно привязать переменные к параметрам запроса, они не нуждаются в экранировании, так как никогда не подставляются непосредственно в строку запроса. 

Привязка переменных к параметрам подготавливаемого запроса выполняется функцией bind_param(). Функция требует указания типов привязанных переменных, т.к. эти типы отправляются на сервер для последующего использования при преобразованиях.

**bool** mysqli_stmt::*bind_param* ( **string** $types , **mixed** &$var1 [, **mixed** &$... ])

Аргументы:

$types –  строка, где каждый символ определяет тип переменной из списка аргументов $var1, var2, .... 

Возможные типы символов:

| Символ | Описание                                       |
| ------ | ---------------------------------------------- |
| i      | соответствующая   переменная имеет тип integer |
| d      | соответствующая   переменная имеет тип double  |
| s      | соответствующая   переменная имеет тип string  |

 

$var1, var2, .... – переменные, которые привязываются. Длина строки $types должны в точности соответствовать количеству переменных.

Возвращаемое значение:

Возвращает TRUE в случае успешного завершения или FALSE в случае возникновения ошибки.

Пример:

$stmt = $mysqli->prepare(**"INSERT INTO CountryLanguage VALUES (?, ?, ?, ?)"**);
 $stmt->bind_param(**'sssd'**, $code, $language, $official, $percent);

 $code = **'DEU'**;
 $language = **'Bavarian'**;
 $official = **"F"**;
 $percent = 11.2;

 */\* выполнение подготовленного запроса \*/* $stmt->execute();

 

**Хранимые процедуры**. Входные параметры указываются внутри предложения CALL.

$mysqli->query("CREATE PROCEDURE p(IN id_val INT) BEGIN INSERT INTO test(id) VALUES(id_val); END;")

$mysqli->query("CALL p(1)")

Значения INOUT/OUT параметров доступны через переменные сессии.

$mysqli->query('CREATE PROCEDURE p(OUT msg VARCHAR(50)) BEGIN SELECT "Hi!" INTO msg; END;'))

$mysqli->query("SET @msg = ''")

$mysqli->query("CALL p(@msg)")

$res = $mysqli->query("SELECT @msg”);

Хранимая процедура может возвращать несколько результирующих наборов. Функция query() выполняет две операции: запускает запрос и извлекает первый результирующий набор, помещая его в буфер. Функциями real_query() или multi_query() можно получить любое количество результирующих наборов из хранимой процедуры. 

$mysqli->query('CREATE PROCEDURE p() READS SQL DATA BEGIN SELECT id FROM test; SELECT id + 1 FROM test; END;'))

$mysqli->multi_query("CALL p()"))

do {

​      $res = $mysqli->store_result();

​      var_dump($res->fetch_all());

​      $res->free();

​      

} while ($mysqli->more_results() && $mysqli->next_result());

MySQL поддерживает наличие нескольких SQL предложений в тексте одного запроса, это уменьшает количество клиент-серверных взаимодействий:

$sql = "SELECT COUNT(*) AS _num FROM test; ";

$sql.= "INSERT INTO test(id) VALUES (1); ";

$mysqli->multi_query($sql)

do {

​      if ($res = $mysqli->store_result()) {

​               var_dump($res->fetch_all(MYSQLI_ASSOC));

​               $res->free();

​      }

] while ($mysqli->more_results() && $mysqli->next_result());

mysqli_query() НЕ устанавливает на сервере специальный флаг, необходимый для выполнения мультизапросов, поэтому инъекция в запрос «; DROP DATABASE mysql» не будет запущена, только если не используется multi_query.

Транзакциями можно управлять как средствами SQL, так и вызовами API функций (рекомендуется).

/* Рекомендуется управлять настройками транзакций средствами API */
 $mysqli->autocommit(false);

/* Не будет распознаваться и учитываться плагинами репликации и балансировки нагрузки */
 if (!$mysqli->query('SET AUTOCOMMIT = 0'))

$mysqli->rollback();

$mysqli->commit();

Соединение должно быть либо закрыто явно, либо автоматически закрывается по завершении работы скрипта.

###### Постоянные соединения

mysqli поддерживает постоянные соединения с базой данных, которые не закрываются, а помещаются в пул для повторного использования в дальнейшем. Если требуется подключиться к тому же серверу и базе данных, с тем же именем пользователя, паролем, сокетом и портом, то вместо создания нового подключения из пула извлекается уже существующее. Повторное использование подключений позволяет избежать накладных расходов на создание новых соединений. Каждый PHP процесс использует свой пул подключений mysqli. 

В режиме CGI PHP-интерпретатор создается и уничтожается при каждом запуске скрипта, поэтомувсе используемые им ресурсы закрываются и, следовательно, постоянные соединения отсутствуют. 

В php.ini параметры: mysqli.allow_persistent  - включение механизма постоянных соединений, mysqli.max_links - максимальное количество соединений, которые может открыть один скрипт, ограничено значением, mysqli.max_persistent - максимальное количество соединений, которые может открыть один PHP процесс (веб-сервер может порождать множество PHP процессов).

Чтобы открыть постоянное соединение, при создании подключения к имени хоста нужно добавить префикс p:.

При использовании постоянных соединений возникает проблема – клиенты могут оставлять такие подключения в непредсказуемом состоянии. Например, клиент ставит блокировку на таблицу, а затем аварийно завершает работу. В mysqli эта проблема решена. В расширении есть встроенный функционал, осуществляющий очистку соединений и переводящий их в состояние пригодное для использования. 

Термин пул соединений в mysqli означает поддержку постоянных соединений.  Количество постоянных подключений в пуле равно последнему количеству выполняемых максимальных параллельных PHP-скриптов или равным верхнему пределу, установленному в php.ini.

**Асинхронные запросы** пригодятся если в проекте используете шардирование данных на уровне бизнес-логики и возникает необходимость сделать 10 одинаковых запросов к 10 разным серверам

Выполнениt асинхронного запроса:

$link->query($query, **MYSQLI****_****ASYNC**);

Возвращаемое значение true вместо mysqli_result. 

Опрос подключений:

**$link->poll**(array &`$read`, array `&$error` , array `&$reject` , int `$sec` [, int `$usec` ])

$read, $error, $reject – какие соединения проверять на возможность чтения, ошибки, отказа;

$sec, $usec – секунды и миллисекунды ожидания ответа.

Возвращает количество готовых к работе соединений в случае успеха,FALSE в случае неудачи.

Получение результата запроса:

$result = $link->reap_async_query()

#### PDO

PDO предоставляет API интерфейс взаимодействия с базой данных, не зависящий от конкретной СУБД. Можно поменять сервер баз данных, например с Firebird на MySQL, и это приведет лишь к незначительным изменениям в PHP коде. PDO поддерживает не все возможности MySQL, например, множественные запросы, именованные параметры

Драйвер PDO MYSQL располагается между самим PDO и сервером MySQL. Программист вызывает функции интерфейса PDO API, а PDO в свою очередь использует драйвер PDO MYSQL для обмена данными и командами с сервером MySQL. Драйвер PDO MYSQL лишь один из многих PDO драйверов

### Межпроцессное взаимодействие и асинхронное исполнение

Межпроцессное взаимодействие (Inter-Process Communication, IPC) — набор способов обмена данными между множеством потоков в одном или более процессах. 

#### PCNTL

Расширение реализует самый базовый функционал, например, работа с сигналами UNIX – отправка сигнала, установка обработчика сигнала. Этот подход самый малофункциональный, так как он не позволяет передавать данные. Поможет организовать старт\стоп воркеров, или считывание задач из буфера (файл, БД, память, etc.), или сигнализацию одной части системы другой о каком то событии.

Установка обработчика сигнала

bool **pcntl_signal** ( int `$signo` , callable|int `$handler` [, bool `$restart_syscalls` = true ] )

Разветвить (fork) текущий запущенный процесс:

int **pcntl****_****fork** ( void )

#### Сокеты

Возможны вариант:

·      создать сокет-сервер, клиентами-потоками коннектиться к нему. 

·      create_socket_pair, которая создаёт пару связанных сокетов.

#### Shared Memory (shmop)

Включает операции чтения, записи, резервирования и удаления сегментов разделяемой памяти Unix. Наиболее быстрое и наименее ресурсозатратное. 

Резервирование или использование блока разделяемой памяти

resource shmop_open ( int $key , string $flags , int $mode , int $size )

*key*  – генерируется через ftok()

flags –"a" (сегмент ранее создан, чтение), "c" (создание сегмента, чтение/запись), "w" (чтение/запись, чаще всего), "n" (создание нового сегмента, если существует – отказ). 

Запись данных в разделяемую память

int shmop_write ( resource $shmid, string $data , int $offset )

Чтение данных из участка разделяемой памяти

string shmop_read ( resource $shmid , int $start , int $count )

Также функции shmop_close – зыкрытие блока, shmop_delete – удаление блока.

#### Семафоры, Shared Memory и IPC (shm)

Включает в себя возможности предыдущего, добавляет возможности синхронизации ресурсов, семафоры, обмен сообщениями.

Каждый объект IPC идентифицируется ключом. Приложения должно сгенерировать ключи. Обязанность проектирования алгоритма генерации ключей лежит на программисте прикладного приложения. Можно использовать ftok().

int ftok (string $pathname , string $proj )

Преобразует *pathname* существующего, доступного файла и идентификатор проекта в целое для использования, например, в *shmop_open()* и других ключах System V IPC.

$shm_key = ftok(‘.’, 't');

**Семафоры** – счетчик доступа к публичным ресурсам. Используется для работы с разделяемой памятью. 

Получение идентификатора семафора (keymax_acquire – число процессов, которые могут одновременно использовать семафор):

resource sem_get ( int $key [, int $max_acquire = 1 [, int $perm = 0666 [, int $auto_release = 1 ]]] )

Захват семафора (nowait – ждать захвата семафора или нет, если не ждать вернет false когда не может быть захвачен).

bool sem_acquire ( resource$sem_identifier [, bool $nowait = false ] )

Освобождение семафора:

bool sem_release ( resource $sem_identifier )

Удаление семафора:

bool sem_remove ( resource $sem_identifier )

**Разделяемая память** обеспечивает доступ к глобальным переменным для различных процессов.

Создание или открытие сегмента разделяемой памяти

resource shm_attach ( int $key [, int $memory_size [, int $perm = 0666]] )

Записать или изменить значение ($variable_key -  ключ для переменной, поддерживаются все переменные допускающие сериализацию):

bool shm_put_var ( resource $shm_identifier , int $variable_key , mixed $variable )

Получение значение из памяти

mixed shm_get_var ( resource $shm_identifier , int $variable_key )

Удаление сегмента общей памяти:

bool shm_remove ( resource $shm_identifier )

**Функции сообщений** могут посылать сообщения одним процессам и принимать сообщения от других.

#### APC

Этот тип памяти является общим для различных процессов/потоков и, в отличие от статических переменных, данные, которые кэшируются таким способом, будут существовать между несколькими запросами.

#### Pthreads

#### Специфические функции

multi_curl

Нужно в curl задать несколько адресов, потом

int **curl_multi_exec** ( resource `$mh` , int `&$running` )

Запускает под-соединения  по мульти-дескриптору md, still_running  – сколько активных соединений запущено.

int **curl_multi_select** ( resource `$mh` [, float `$timeout` = 1.0 ] ) 

Блокирует выполнение скрипта, пока какое-либо из curl_multi соединений не станет активным. И потом результаты выбрать функцией *curl_multi_getcontent*.

### Файловая система

pathinfoс

Возвращает информацию о пути к файлу

[mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) **pathinfo** ( string `$path` [, int `$options` = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME ] )

PATHINFO_FILENAME – название файла бе расширения

### Использование системных ресурсов

#### memory_get_usage

Количество памяти выделенной PHP

int memory_get_usage ([ bool $real_usage = false ] )

*real_usage* – TRUE - реальное количество памяти, выделенной PHP скрипту, включая неиспользуемые страницы; FALSE – количество используемой памяти.

#### memory_get_peak_usage

Пиковое значение объема памяти, выделенной PHP: 

int memory_get_peak_usage ([ bool $real_usage = false ] )

#### Заготовка для benchmark

**function** benchmark($function)
 {
     *gc_collect_cycles*();
     $t0=*microtime*();
     **for**($i=1e6;$i--;) $function($i);
     $t1=*microtime*();
     $t0=*explode*(**' '**, $t0); $t1=*explode*(**' '**, $t1);

     **echo** ($t1[0]-$t0[0])+($t1[1]-$t0[1]), **" s****\t**$function**\n****"**;

 }

#### gc_collect_cycles

Принудительный запуск сборщика мусора для поиска циклических ссылок.

int **gc_collect_cycles** ( void )

Возвращает число найденных ссылок.

#### microtime

Возвращает текущую метку времени Unix с микросекундами

[mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) **microtime** ([ bool `$get_as_float` = false ] )

get_as_float – вернуть число с плавающей точкой ([float](http://php.net/manual/ru/language.types.float.php)) вместо строки ([string](http://php.net/manual/ru/language.types.string.php)).

**echo** microtime().**"****\n****"**;  //0.66406200 1516274911
 **echo** microtime(**true**);   //1516274911.6641

#### set_time_limit

bool **set_time_limit** ( int `$seconds` )

Задает время в секундах, в течение которого скрипт должен завершить работу. Если скрипт не успевает, вызывается фатальная ошибка. По умолчанию дается 30 секунд, либо время, записанное в настройке max_execution_time в php.ini (если такая настройка установлена).

### Отражения

#### call_user_func

Вызывает пользовательскую функцию и параметры через запятую:

[mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) **call_user_func** ( [callable](http://php.net/manual/ru/language.types.callable.php) `$callback` [, [mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) `$parameter` [, [mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) `$...` ]] )

#### call_user_func_array

Вызывает пользовательскую функцию с массивом параметров:

[mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) **call_user_func_array** ( [callable](http://php.net/manual/ru/language.types.callable.php) `$callback` , array `$param_arr` )

#### method_exists

Проверяет, существует ли метод в данном классе

bool **method_exists** ( [mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) `$object` , string `$method_name` )

#### get_class

Возвращает имя класса, к которому принадлежит объект

**string** get_class ([**object** $object])

Если параметр object не указан – возвращается имя класса, где записана функция (т.е. без позднего связывания).

Имя класса возвращается с указанием пространства имен:

**namespace** Foo\Bar;

 **class** Baz {}

 $baz = **new** \Foo\Bar\Baz;

 *var_dump*(*get_class*($baz)); *# string(11) "Foo\Bar\Baz"*

 

#### is_subclass_of

Является ли объект или класс дочерним к указанному классу, либо напрямую реализует этот класс

bool **is_subclass_of** ( [mixed](http://php.net/manual/ru/language.pseudo-types.php#language.types.mixed) `$object` , string `$class_name` [, bool `$allow_string` = `TRUE` ] )

$object – имя дочернего класса или экземпляр дочернего объекта. 

$class_name – имя родительского класса

$allow_string – если установлено в false, не допускается имя класса в виде строки в качестве параметра object. 

 

### Математические

Возвращает строку, содержащую двоичное представление указанного аргумента number.

string **decbin** ( int `$number` )

**echo** decbin(12); // 1100

### Служебные

#### assert

Проверяет заданное утверждение assertion и совершит соответствующее действие, если результатом проверки окажется FALSE.

**bool** *assert* ( **mixed** $assertion [, **Throwable** $exception ] )

Если assertion задается в виде строки, оно будет рассматриваться функцией assert() как PHP-код. Однако использование значения типа string в параметре assertion объявлено УСТАРЕВШИМ с PHP 7.2. Если вы передадите в качестве параметра assertion логическое выражение, выражение будет преобразовано в строку перед вызовом функции обработчика, а в случае FALSE будет использована пустая строка.

Цель функции – тестирования условий, которые в штатных ситуациях всегда принимают значение TRUE, значение FALSE должно указывать на программные ошибки. Утверждения не должны использоваться в обычных операциях, таких как проверка входных параметров. Скрипт должен корректно выполняться, если отключить проверку утверждений.

Поведение функции assert() можно изменять с помощью функции assert_options() или установкой .ini-настроек. Функция assert_options() и директива ASSERT_CALLBACK позволяют задать callback-функцию, которая будет вызываться при провале проверки утверждения.

В PHP 7 assert() - это языковая конструкция, позволяющая определять ожидания: утверждения, которые работают в среде разработки и тестирования, но в целях оптимизации отключены на продуктовом окружении.

В то время как функция assert_options() может по-прежнему быть использована для контроля над поведением программы описанным выше образом, для обратной совместимости, но в PHP 7 код должен использовать две новые конфигурационные директивы для управления поведением assert() и не вызывать функцию assert_options().

| **Директива**    | **Значение по умолчанию** | **Возможные значения**                                       |
| ---------------- | ------------------------- | ------------------------------------------------------------ |
| zend.assertions  | *1*                       | ·           *1*: генерирует и   выполняет код (режим разработки)   ·           *0*: генерирует код, но   перепрыгивает через него во время выполнения   ·           *-1*: не генерирует код   (рабочий режим) |
| assert.exception | *0*                       | ·           *1*: выбрасывает   исключение, когда утверждение терпит неудачу, класса, предоставленного в   параметре exception,   либо класса AssertionError, если параметр exception не передан.   ·           *0*: использует или   создает экземпляр класса Throwable как описано выше, но только генерирует   предупреждение на основе этого объекта, не выбрасывая его (для совместимости   с поведением PHP 5) |

Пример:

*assert*(**false**);
 **echo** **'Hi!'**;

При zend.assertions=0:

Hi!

При zend.assertions=1 и assert.exception=0:

**Warning**: assert(): assert(false) failed in - on line 2 Hi! 

При zend.assertions=1 и assert.exception=1:

**Fatal error**: Uncaught AssertionError: assert(false) in -:2

#### **get_defined_vars**

Возвращает массив, содержащий список всех определенных переменных: переменные окружения, серверные переменные, переменные, определенные пользователем, в той области видимости, в которой была вызвана get_defined_vars().

**array** get_defined_vars ( **void** )

 

<?php
$a = 1;

var_dump(get_defined_vars());  # array(5)
{

                               #   ["_GET"] => array(0) {}

                               #   ["_POST"] => array(0) {}

                               #   ["_COOKIE"] => array(0) {}

                               #   ["_FILES"] => array(0) {}

                               #   ["a"]=> int(1)

                               # }

#### header

Отправка HTTP-заголовка

**void** *header* ( **string** $header [, **bool** $replace = **TRUE** [, **int** $http_response_code ]] )

Существует два специальных заголовка. Один из них начинается с "HTTP/" и используется для отправки кода состояния HTTP. 

*header*(**"****HTTP****/1.0 404** **Not** **Found****"**);

Другим специальным видом заголовков является "Location:". В этом случае функция не только отправляет этот заголовок браузеру, но также возвращает ему код состояния 302 Moved Permanently, если ранее не был установлен код 201 или 3xx.

*header*("Location: http://example.com/newpage.html");

$http_response_code – принудительно задает код ответа HTTP. 

### die и exit

Функции [die](http://php.net/manual/en/function.die.php)() и [exit()](http://php.net/manual/en/function.exit.php) эквивалентны и являются псевдонимами друг друга. Именование exit() взято из C, die() из Perl. 

**void** **exit** ([ **string** $status ] )
 **void** **exit** ( **int** $status )

exit (die) - это конструкция языка, и она может быть вызвана без круглых скобок, если не передается параметр $status.

Если $status задан в виде строки, то эта функция выведет содержимое $status перед выходом. Если $status задан в виде integer, то это значение будет использовано как статус выхода и не будет выведено (должны быть в диапазоне от 0 до 254, статус 0 – успешное завершение). 

## Архитектура запуска

### Способы запуска

Если в случае php-fpm речь идет исключительно об экономии ресурсов на запуск интерпретатора php, то при использовании настоящего асинхронного fast-cgi, вроде упомянутого выше react, (это не выходя за пределы php) можно вообще избежать в ходе обработки запроса накладных расходов на bootstrap, производя его один раз при старте приложения.

### Акселераторы

Обработка сценария на PHP интерпретатором включает:

·      Чтение файла;

·      Генерация байткода;

·      Выполнение кода;

·      Выдача результата.

Процесс генерации байткода выполняется каждый раз и отнимает большую часть времени обработки сценария. Акселераторы кэшируют скомпилированный байт-код в памяти и/или на диске и в итоге обращения к исходному файлу не происходит. После изменения исходного файла код перекомпилируется. Расширения также включают функции для хранения переменных в разделяемой процессами памяти (OPCache нет).

**Alternative PHP Cache (APC)**. Поддерживает кеширование данных в разделяемой памяти. Поддержка до 5.4. Разработка прекращена.

**eAccelerator**. Поддержка до PHP 5.4. разработка прекращена

**XCache**. Поддерживает функции оптимизации скриптов, кэширование байт-кода в оперативную память, кэширование пользовательских данных в shared memory, простое профилирование работы скриптов. Поддержка до 5.6. Статус проекта: на поддержке.

**Zend OPcache.** Сохраняет скомпилированный байт-код в разделяемой памяти. Включен по умолчанию начиная с PHP 5.5. Проект развивается. Многие оптимизации (вывод типов, jit) являются частью opcache и без него не работают.

### Потокобезапость (Thread-safety)

Код потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно. В частности, он должен обеспечивать правильный доступ нескольких потоков к разделяемым данным.

Про модели мультипроцессинга Apache смотреть здесь Модели мультипроцессорности

На HTTP-запросы отвечает Apache, который пересылает их на обработку в PHP.

Способы взаимодействия PHP с веб-сервером:

·      mod_php для Apache (наиболее популярный) – PHP скомпилирован как модуль для веб-сервера, и поэтому загружается прямо внутри него. Поэтому в случае worker MPM (с потоками) необходим Thread safe PHP. Однако безопасность потоков в PHP оспаривается и без необходимости лучше использоваться prefork MPM, который по умолчанию устанавливается менеджерами пакетов.

·      В другие сервера (nginx, lighttpd) PHP встроить нельзя. Веб-сервер взаимодействует с внешними процессами PHP через FastCGI, Thread safety значения не имеет. 

·      Для CLI режима Thread safety значения не имеет

В каком режиме работает PHP показывает phpinfo():

 Server API – Apache 2.0 Handler (или CGI/FastCGI).

Если Thread Safety не имеет значения, лучше выбрать Non thread safety, т.к. он наверно быстрее.

### Альтернативные интерпретаторы/компиляторы

#### HHVM

HipHop for PHP (HPHPc) — транслятор исходного кода, созданный компанией Facebook. HipHop превращает исходный код, написанный на языке PHP, в оптимизированный код на C++, а затем использует компилятор g++ для его компиляции. Позже Facebook разработал HHVM —виртуальная машина для исполнения и JIT оптимизации PHP кода, и язык программирования Hack, близкий к PHP и реализованный поверх HHVM, в котором дополнительно введена статическая типизация. Пример:

<?hh

function negate(bool $x): bool {

​    return !$x;

}

#### KPHP

KPHP (kPHP, KittenPHP) —транслятор PHP-кода в С++ от компании ВКонтакте. Приставка К- происходит от слова kitten (рус. котёнок), что стало своеобразной традицией во внутренних разработках ВКонтакте.

### Способы компиляции

#### AOT-компиляция

Ahead-of-Time (AOT) компилятор — это вид транслятора, который использует метод компиляции перед исполнением (англ. ahead-of-time compilation, досрочная компиляция). Под этим понимается как компиляция непосредственно в машинный код (например, Си, С++ или Паскаль), так и компиляции в «промежуточный» байт-код (Java, .NET, PHP).

Процесс компиляции состоит из следующих этапов:

·      [Лексический анализ](https://ru.wikipedia.org/wiki/Лексический_анализ) – последовательность символов преобразуется в последовательность лексем (например, ИМЯ «variable», ПРИСВАИВАНИЕ, СЛОЖЕНИЕ).

·      [Синтаксический (грамматический) анализ](https://ru.wikipedia.org/wiki/Синтаксический_анализ) (*p**arsing, **па́рсинг**)* – процесс сопоставления линейной последовательности [лексем](https://ru.wikipedia.org/wiki/Лексический_анализ) (слов, токенов) с [формальной грамматикой](https://ru.wikipedia.org/wiki/Формальная_грамматика). Результатом является дерево разбора (синтаксическое дерево). 

   

·      [Семантический анализ](https://ru.wikipedia.org/wiki/Семантический_анализ) – дерево разбора обрабатывается с целью установления его семантики (смысла) — например, проверка ошибок типа, [ привязка объектов](https://en.wikipedia.org/wiki/Object_binding) ([связывание](https://en.wikipedia.org/wiki/Object_binding) ссылок переменных и функций с их определениями), определение типов выражений, выбрасывание исключений и предупреждений. Результат может быть дополненным деревом разбора или чем-то ещё удобным для дальнейшей обработки. 

·      [Оптимизация](https://ru.wikipedia.org/wiki/Оптимизация_компилятора) – выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла. 

·      [Генерация кода](https://ru.wikipedia.org/wiki/Генерация_кода). Из промежуточного представления порождается код на целевом языке.

В конкретных реализациях компиляторов эти этапы могут быть разделены или, наоборот, совмещены в том или ином виде.

#### JIT-компиляция

JIT-компиляция (Just-in-time compilation, компиляция «на лету»), динамическая компиляция (dynamic translation) — технология увеличения производительности путём компиляции байт-кода в машинный код непосредственно во время работы программы. Таким образом достигается высокая скорость выполнения по сравнению с интерпретируемым байт-кодом (сравнимая с компилируемыми языками) за счёт увеличения потребления памяти (для хранения результатов компиляции) и затрат времени на компиляцию. 

Особенно подходит для динамических языков программирования , т.к. обеспечивает позднее связывание типов данных. Например, текстовый редактор может на лету компилировать регулярные выражения для более быстрого поиска по тексту, что невозможно сделать AOT, т.к. регулярное выражение формируется во время выполнения.

JIT – комбинация AOT и интерпретации. Их преимуществ: 

·      скорость скомпилированного кода

·      гибкостью интерпретации, адаптивная оптимизация

·      отсутствие компиляции до исполнения

Их недостатков:

·      перекомпиляция на лету

·      задержка при запуске на компиляцию. Причем, чем лучше и чем больше оптимизаций выполняет JIT, тем дольше получается задержка. Требуется поиск компромисса между качеством генерируемого кода и временем запуска.

Основная цель использования JIT — превзойти производительность статической компиляции, сохраняя при этом преимущества динамической компиляции, за счёт оптимизаций, возможных только во время исполнения:

·      компиляция под конкретный процессор и операционную систему. Например, использование SSE при их поддержке процессором.

·      сбор статистики о работающей программе и оптимизация с учётом этой информации.

·      глобальные оптимизации кода (например, встраивание библиотечных функций в код)

·      компилируются только те участки кода, которые используются чаще всего. 

JIT используется в реализациях Java, JavaScript, .NET Framework, интерпретаторы PHP, Ruby, Perl, Python используют ограниченные JIT.

Общая схема запуска: 

\1.    Приложение компилируется в байт-код для исполнения под виртуальной машиной (bytecode compilation). На этом этапе выполняется большинство тяжеловесных операций: [парсинг](https://ru.wikipedia.org/wiki/Парсинг) исходного кода и выполнение базовых оптимизаций.

\2. JIT-компилятор непрерывно анализирует исполняемый код и идентифицирует части кода, где ускорение, полученное от компиляции, перевешивает накладные расходы на эту компиляцию. JIT компилирует байт-код непосредственно в машинный код, убирая стадию интерпретации. Скомпилированный код кэшируется и в дальнейшем повторно используется без перекомпиляции.

##### Байт-код

Байт-код — это компактное представление программы, уже прошедшей синтаксический и семантический анализ. В нём в явном виде закодированы типы, области видимости и другие конструкции. Интерпретация в виртуальной машине байт-кода или JIT-компиляция из байт-кода значительно быстрее, чем из исходного кода.

По форме байт-код похож на машинный код, но предназначен для исполнения не реальным процессором, а виртуальной машиной. В качестве виртуальной машины выступает интерпретатор соответствующего языка программирования (иногда дополненный JIT- или AOT-компилятором).

Байт-код называется так, потому что длина каждого кода операции традиционно составляет один байт, однако в PHP длина кода операции не равна одному байту, поэтому стоит говорить о виртуальных инструкциях. После кода инструкции следуют различные параметры, например, номер регистра или адрес в памяти. 

Преимущество байт-кода в большей эффективности и портируемости. То же самое преимущество дают непосредственно интерпретируемые языки, однако, поскольку байт-код обычно менее абстрактен и более компактен, чем исходный код, эффективность интерпретации байт-кода обычно выше, чем чистая интерпретация исходного кода

## Библиотека SPL

### Структуры SPL

#### SplDoublyLinkedList

Двусвязный список (DLL) — это список узлов, связанных в обоих направлениях друг между другом. Каждый узел такого списка хранит ссылку на предыдущий и на следующий за ним узел.  Как известно, есть два принципа извлечения значения из списка – FIFO (First In First Out – первый зашел, первый ушел) и LIFO (Last In First Out – последний зашел, первый ушел). С помощью SplDoublyLinkedList можно извлекать значения по любому из этих принципов. Следовательно, с его помощью можно легко организовать стек или очередь.

#### SplQueue

Данный класс является наследником SplDoublyLinkedList и реализует очередь. Для этой структуры флаг итератора (метод setIteratorMode) установлен в значение IT_MODE_FIFO – First In First Out – первым пришёл, первым ушёл. 

$queue = **new** SplQueue();

 $queue->setIteratorMode(SplQueue::**IT****_****MODE****_****DELETE**);

 $queue->enqueue(**'****one****'**);
 $queue->enqueue(**'****two****'**);
 $queue->enqueue(**'****qwerty****'**);

 $queue->dequeue();
 $queue->dequeue();

 **echo** $queue->top(); *//* *qwerty*

#### SplStack 

Данный класс является наследником SplDoublyLinkedList и реализует стек. Для этой структуры флаг итератора (метод setIteratorMode) установлен в значение IT_MODE_LIFO – Last In First Out – последним пришёл, первым ушёл. По производительности в PHP5 эта конструкция на одном уровне с использование массивов и функций array_pop и array_push.

$stack = **new** SplStack();

 *// добавляем элемент в стек* $stack->push(**'1'**);
 $stack->push(**'2'**);
 $stack->push(**'3'**);

 **echo** $stack->count(); *// 3* **echo** $stack->top(); *// 3* **echo** $stack->bottom(); *// 1* **echo** $stack->serialize(); *// i:6;:s:1:"1";:s:1:"2";:s:1:"3";  // извлекаем элементы из стека* **echo** $stack->pop(); *// 3* **echo** $stack->pop(); *// 2* **echo** $stack->pop(); *// 1*

#### `SplHeap```

Куча, представленная в виде бинарного дерева, каждый узел которого имеет не более двух дочерних узлов. Это абстрактный класс, требующий расширения с определением метода compare(), позволяющего выполнять сортировку в реальном времени при вставке новых узлов в дерево. Каждый узел больше или равен своим потомкам, метод compare() используется для сравнения и является общим для всей кучи. 

/**

 * A class that extends SplHeap
   */
   class MySplHeap extends SplHeap
   {
       /**
   * Реализация абстрактного метода compare для сравнения
     значений
   * элементов и сортировки по порядку
     /
         public function compare($value1, $value2)
         {
             return -($value1 <=>
     $value2);
         }
     }

# Пример использования

$heap = new MySplHeap();
$heap->insert(15);
$heap->insert(20);
$heap->insert(11);
$heap->insert(12);

foreach($heap as $value) {
    echo $value . '... '; # 11... 12... 15... 20
}

#### `SplMaxHeap```

Наследуется от SplHeap. SplMaxHeap реализует метод compare() таким образом, чтобы дерево было отсортировано в порядке убывания значений узлов.

$heap = **new** SplMaxHeap();
 $heap->insert(**'111'**);
 $heap->insert(**'666'**);
 $heap->insert(**'777'**);

 **echo** $heap->extract(); *// 777* **echo** $heap->extract(); *// 666* **echo** $heap->extract(); *// 111*

#### `SplM``in``Heap```

Наследуется от SplHeap. SplMinHeap реализует метод compare() таким образом, чтобы дерево было отсортировано в порядке возрастания значений узлов.

$heap = **new** SplMinHeap();
 $heap->insert(**'111'**);
 $heap->insert(**'666'**);
 $heap->insert(**'777'**);

 **echo** $heap->extract(); *// 111* **echo** $heap->extract(); *// 666* **echo** $heap->extract(); *// 777*

#### SplPriorityQueue

Очередь с приоритетами. Для каждого элемента можно задать его приоритет. Сортировка производится в зависимости от приоритета.

$queue = **new** SplPriorityQueue();
 *# получаем только значения элементов* $queue->setExtractFlags(SplPriorityQueue::**EXTR****_****DATA**);

 $queue->insert(**'****Q****'**, 1);
 $queue->insert(**'****W****'**, 2);
 $queue->insert(**'****E****'**, 3);
 $queue->insert(**'****R****'**, 4);
 $queue->insert(**'****T****'**, 5);
 $queue->insert(**'****Y****'**, 6);

 **foreach**($queue **as** $value)
 {
     **echo** $value . **'. '**; *#* *Y**.* *T**.* *R**.* *E**.* *W**.* *Q**.* }

 

#### `SplFixedArray```

Массив с фиксированным количеством элементов, ключами выступают только целые числа.  Данные хранятся в непрерывной области памяти и доступ к элементу осуществляется по индексу со смещением, а обычные массивы реализованы в виде упорядоченных хэш-таблиц. Данный вид массива работает быстрее, чем обычные массивы, но существуют ограничения:

·      в качестве ключей могут быть только целые числа > 0

·      длина может быть изменена, но это затратная операция

По тестам скорость работы выше на 20-50% чем при работе с обычными массивами. Однако если размер SplFixedArray меняется, то скорость падает, до скорости обычных массивов.

*// Инициализация массива фиксированной длиной* $array = **new** SplFixedArray(5);

 $array[1] = 2;
 $array[4] = **"****foo****"**;

 *var**_dump*($array[0]); *//* *NULL* *var**_dump*($array[1]); *//* *int**(2)  var**_dump*($array[**"4"**]); *//* *string**(3) "**foo**"  // Увеличение размера массива до 10* $array->setSize(10);

 $array[9] = **"****asdf****"**;

#### SplObjectStorage

Хранилище объектов, предоставляет интерфейс для сопоставления объектов к данным, либо может быть использовано в качестве контейнера для множества объектов. Позволяет использовать объект в качестве ключа ассоциативного массива и связать его с некоторыми данными. 

*// Применение SplObjectStorage как хранилища объектов* $s = **new** SplObjectStorage();

 $o1 = **new** StdClass;
 $o2 = **new** StdClass;
 $o3 = **new** StdClass;

 $s->attach($o1);
 $s->attach($o2);

 *var_dump*($s->contains($o1)); *# bool(true) var_dump*($s->contains($o2)); *# bool(true) var_dump*($s->contains($o3)); *# bool(false)*  $s->detach($o2);

 *var_dump*($s->contains($o1)); *# bool(true) var_dump*($s->contains($o2)); *# bool(false) var_dump*($s->contains($o3)); *# bool(false)*

 

*// Применение SplObjectStorage для связи ключа-объекта с данными* $s = **new** SplObjectStorage();

 $o1 = **new** StdClass;
 $o2 = **new** StdClass;
 $o3 = **new** StdClass;

 $s[$o1] = **"данные для объекта 1"**;
 $s[$o2] = **array**(1,2,3);

 **if** (**isset**($s[$o2])) {
     *var_dump*($s[$o2]); *# array(3) {1,2,3)* }

 

## Безопасность

### Хэширование паролей

Ранее для хеширования паролей использовалась функция crypt()

**string** *crypt* ( **string** $str [, **string** $salt ] )

Однако функция требует указание соли в параметре $salt для надежного хеширования и эта соль обязательно должна быть динамической. Статическая соль не имеет смысла, т.к. известна заранее для составления радужной таблицы.

Рекомендуется использовать позже добавленное (PHP5.5) API хеширования паролей. Основные функции:

·      создание хеша для пароль

**string** *password_hash* ( **string** $password , **int** $algo [, **array** $options ] )

·      проверяет, соответствует ли пароль хешу

**bool** password_verify ( **string** $password , **string** $hash )

Функция password_hash() использует сложный хеш, генерирует сложную соль и применяет правильно количество раундов хеширования автоматически. password_hash() является простой оберткой над crypt() и совместима с существующими хешами паролей. Поэтому приветствуется использование password_hash(). По умолчанию применяется алгоритм bcrypt. 

Использованный алгоритм, стоимость и соль будут возвращены как часть хеша. Таким образом, информация необходимая для проверки хеша будет в него включена. Это позволит функции password_verify() проверять хеш без необходимости отдельного хранения информации о соли и алгоритме.  Формат возвращаемого значения функциями crypt() и password_hash() следующий:

   

### Контроль входных данных

Необходим, если данныесодержимое получено из неизвестных или ненадежных источников, таких, как пользовательский ввод. Например, такие данные можно получить из HTML-форм.

#### Функции ctype_*

Функции ctype_* позволяют проверить принадлежность символа или строки определенному классу символов. Поддерживаются только однобайтные ASCII-символы с кодами в диапазоне 0-255 (т.е. можно использовать с кодировкой Win1251, но нельзя с UTF8). Учитывает текущие региональные установки, управление которыми возможно через setlocale().

Если аргументом выступает строка, то функции будут проверять каждый символ в этой строке и вернут TRUE только если каждый символ удовлетворяет требуемому условию.

Работают быстрее регулярных выражений и функций str_* и is_*, т.к.  использует родную библиотеку C и сраниваниют коды символов.

Примеры функций:

·      bool ctype_alnum ( string $text ) — Проверяет наличие буквенно-цифровых символов

·      bool ctype_alpha ( string $text ) — Проверяет наличие буквенных символов

·      bool ctype_lower ( string $text ) — Проверяет наличие символов в нижнем регистре

#### Фильтрация через filter_var

Существует два основных типа фильтрации: 

·      *Проверка* используется для определения соответствия данных определённым критериям. Например, применение FILTER_VALIDATE_EMAIL позволяет проверить, являются ли введённые данные адресом email, однако, сами данные при этом останутся нетронутыми.

·      *Очистка* используется для извлечения из данных нежелательных конструкций. Например, применение FILTER_SANITIZE_EMAIL удалит все символы, которые не должен содержать email-адрес. То есть, проверки данных не происходит.

Кроме того, можно использовать различные флаги, как для проверки, так и для очистки, для более тонкой настройки согласно вашим нуждам. Например, передача флага FILTER_FLAG_SCHEME_REQUIRED при фильтрации URL установит необходимым условием наличие протокола (например, http:// в http://example.org/foo).

Примеры фильтров проверки

| FILTER_VALIDATE_BOOLEAN | Возвращает TRUE для значений "1", "true",   "on" и "yes". Иначе возвращает FALSE.   Если установлен флаг FILTER_NULL_ON_FAILURE, то FALSE возвращается только для значений "0",   "false", "off", "no" и "", а NULL будет возвращен для всех небулевых   значений. |
| ----------------------- | ------------------------------------------------------------ |
| FILTER_VALIDATE_DOMAIN  | Проверяет домен   на корректность                            |
| FILTER_VALIDATE_EMAIL   | Проверяет email на корректность                              |
| FILTER_VALIDATE_FLOAT   | Проверяет, что   значение является корректным числом с плавающей точкой. |
| FILTER_VALIDATE_INT     | Проверяет, что   значение является корректным целым числом, и, при необходимости, входит в   определенный диапазон. |
| FILTER_VALIDATE_IP      | Проверяет, что   значение является корректным IP-адресом     |
| FILTER_VALIDATE_URL     | Проверяет, что   значение является корректным URL            |

Примеры фильтров очистки

| FILTER_SANITIZE_EMAIL        | Удаляет все   символы, кроме допустимых в email   (буквы, цифры, @...) |
| ---------------------------- | ------------------------------------------------------------ |
| FILTER_SANITIZE_NUMBER_FLOAT | Удаляет все   символы, кроме цифр, +–.eE.                    |
| FILTER_SANITIZE_NUMBER_INT   | Удаляет все   символы, кроме цифр, +–                        |
| FILTER_SANITIZE_URL          | Удаляет все   символы, кроме допустимых в URL                |

Примеры флагов:

| FILTER_FLAG_ALLOW_SCIENTIFIC | Разрешает   наличие e и E для научных   нотаций вещественных чисел |
| ---------------------------- | ------------------------------------------------------------ |
| FILTER_NULL_ON_FAILURE       | Возвращает NULL, а не FALSE для   неопознанных булевых значений |
| FILTER_FLAG_SCHEME_REQUIRED  | Требует, чтобы URL содержал часть со   схемой                |
| FILTER_FLAG_HOST_REQUIRED    | Требует,   чтобы URL содержал часть с хостом                 |
| FILTER_FLAG_ALLOW_OCTAL      | Трактует ввод, начинающийся с   нуля (0) как восьмеричное число. |

Функция filter_var():

Применяет фильтр к переменной

**mixed** *filter_var* ( **mixed** $variable [, **int** $filter = **FILTER_DEFAULT** [, **mixed** $options ]] )

$variable – переменная

$filter – применяемый фильтр

$options – ассоциативный массив параметров либо логическая дизъюнкция (операция ИЛИ) флагов. Если фильтр принимает параметры, флаги могут быть указаны в элементе массива "flags".

Возвращаемое значение – отфильтрованные данные или FALSE, если фильтрация завершилась неудачей.

Пример использования:

$options = **array**(
     **'****options****'** => **array**(
         **'****default****'** => 3,   # возвращается, если фильтрация неудачна
         **'****min****_****range****'** => 0  # минимально допустимое значение
     ),
     **'****flags****'** => **FILTER****_****FLAG****_****ALLOW****_****OCTAL**, # разрешить восьмиричные числа
 );

 var_dump(filter_var(**'-1'**, **FILTER****_****VALIDATE****_****INT**, $options));  # int(3)
 var_dump(filter_var(**'010'**, **FILTER****_****VALIDATE****_****INT**, $options)); # int(8)

#### Обработка текста

При обработке текста, полученного от пользователя, необходимо выбрать два вариант:

·      Текст не рассматривает, как HTML, поэтому можно просто экранировать опасные символы и вывести его в виде обычного текста.

·      Текст рассматривает как HTML.

##### Текст не рассматривается как HTML

 

##### Текст рассматривается как HTML

Лучше всего воспользоваться библиотекой HtmlPurifier.

#### Другие варианты

·      класс DateTime

·       функции is_*

·      приведение типа

·      регулярные выражения.

### SQL-инъекции

Способы защиты:

Экранирование специальных символов

В расширении mysqli две эквивалентные функции:

**string** mysqli::escape_string ( **string** $escapestr )

 

**string** mysqli::real_escape_string ( **string** $escapestr )

 

В расширении PDO используется функция quote(). Эта функция заключает строку в кавычки (если требуется) и экранирует специальные символы:

**string** PDO::*quote* ( **string** $string )

 

Параметризованные запросы (заранее подготовленные выражения)

Параметры в подготовленном выражении не нуждаются в экранировании, так как никогда не подставляются непосредственно в строку запроса.

Поддерживается в расширениях:

·       Mysqli (подробнее Привязывание переменных к параметрам запроса)

·      PDO

# Версии 

## 5.3

Добавлена поддержка пространств имен.

Добавлена поддержка позднего статического связывания.

**static**::who();

Добавлена поддержка нативных замыканий (closures) (Lambda/Anonymous функции).

Появились два магических метода: __callStatic() и __invoke().

Появилась поддержка синтаксиса Nowdoc, подобный Heredoc, но с одинарными кавычками.

Heredoc теперь может быть объявлен используя двойные кавычки, дополняющие синтаксис Nowdoc.

У тернарного оператора есть теперь сокращенный вид: *?:*.

Стал возможен динамический доступ к статическим методам:

`$``a ``=`` ``"``C``"``;`
 `echo ``$``a``::``$``foo``;`
 [Исключения](http://php.net/manual/ru/language.exceptions.php) теперь могут быть вложенными:

} catch (Exception $e) {
   /* Для передачи $e используется третий параметр. */
   throw new RuntimeException("Rethrowing", 911, $e);

Добавлен [сборщик мусора](http://php.net/manual/ru/features.gc.php) для циклических ссылок. Он включен по умолчанию.

method()->var — получение объекта из метода/функции

$object->method()->method()->method();

const — ключевое слово для создания констант вне классов

define('SHORTINIT', 'true');

const SHORTINIT = 'true';

 

 

## 5.4

Добавлена поддержка [трейтов](http://php.net/manual/ru/language.oop5.traits.php).

Добавлен короткий синтаксис объявления массивов, *$a = [1, 2, 3, 4]*

Оператор * теперь доступен всегда, несмотря на значение php.ini опции [short_open_tag](http://php.net/manual/ru/ini.core.php#ini.short-open-tag).

возможность получения доступа к члену класса при создании экземпляра. *(new Foo)->bar()*.

Тип callable

$foo = func()[0]; — быстрое получение элемента массива

динамичное указание метода

$x = "f";

 A::{ $x .'oo' }();

 

## 5.5

Добавлены [Генераторы](http://php.net/manual/ru/language.generators.php)[ ](http://php.net/manual/ru/migration55.new-features.php#migration55.new-features.generators)

Добавлено ключевое слово [*finally*](http://php.net/manual/ru/language.exceptions.php#language.exceptions.finally)[ ](http://php.net/manual/ru/migration55.new-features.php#migration55.new-features.finally)

[*foreach*](http://php.net/manual/ru/control-structures.foreach.php) теперь поддерживает [list()](http://php.net/manual/ru/function.list.php)[ ](http://php.net/manual/ru/migration55.new-features.php#migration55.new-features.foreach-list)

$array = [
   [1, 2],
 ];

 foreach ($array as list($a, $b)) {

[empty()](http://php.net/manual/ru/function.empty.php) поддерживает произвольные выражения (empty – не функция, а конструкция)

function always_false() {

if (empty(always_false())) {

Литералы [array](http://php.net/manual/ru/language.types.array.php) и [string](http://php.net/manual/ru/language.types.string.php) разыменовываются[ ¶](http://php.net/manual/ru/migration55.new-features.php#migration55.new-features.const-dereferencing)

echo [1, 2, 3][0];

echo 'PHP'[0];

**echo** 'abcdefghijk'{ rand(0,10) }; // получим одну из букв: 'abcdefghijk'

Полностью определенное имя класса можно получить ClassName::class

API для хэширования паролей

password_hash() — используется для хэширования пароля

password_verify() — используется для проверки пароля на соответствие хэшу.

password_needs_rehash – соответствие хеша нужному алгоритму и опциям, password_get_info – получение параметров хеша

## 5.6

Константные выражения

Стало возможно представить скалярное выражение, включающее цифровой и строковые литералы и/или константы, в то время где ранее ожидалось статическое значение, например, в объявлениях констант или значениях аргументов функций по-умолчанию.

const ONE = 1;
 const TWO = ONE * 2;

const ONE = 1;
 const TWO = ONE * 2;

 class C {
   const THREE = TWO + 1;
   const ONE_THIRD = ONE / self::THREE;
   const SENTENCE = 'The value of THREE is '.self::THREE;

   public function f($a = ONE + self::THREE) {

const ARR = ['a', 'b'];

Функции с переменным количеством аргументов используя синтаксис *...*

function f($req, $opt = null, ...$params) 

Массивы и объекты Traversable могут быть развернуты в аргументах функции с помощью *...*[ ¶](http://php.net/manual/ru/migration56.new-features.php#migration56.new-features.splat)

echo add(1, ...$array);

Возведение в степень с помощью **, ассоциативность правая

echo 2 ** 2 ** 3; // (2 ** (2 ** 3))=256

Импорт функций и констант в дополнение к классам

namespace {
   use const Name\Space\FOO;
   use function Name\Space\f;

*Магический метод __debugInfo()*[ для изменения вывода var_dump¶](http://php.net/manual/ru/migration56.new-features.php#migration56.new-features.debuginfo)

 

## 7.0

- Многие фатальные и поправимые фатальные ошибки были переделаны в исключения в PHP 7. Эти исключения наследуют класс `Error`, который, в свою очередь, реализует интерфейс `Throwable`. 

- Непрямой доступ к переменным, свойствам и методам теперь раскрывается строго слева-направо. [Подробнее](#Порядок обработки непрямого доступа).

- Изменения в `foreach` (подробнее [1](#foreach)):

  - `foreach` больше не изменяет внутренний указатель массива. .
  - `foreach`  *by value*. Изменения, внесенные в массив внутри тела цикла, происходят не в исходном массиве, а в копии массива, т.е. не затронут перебираемые значения. Подробнее [2](#array-zval)
  - `foreach`  *by reference*. Изменения, внесенные в массив внутри тела цикла, происходят в исходном массиве, т.е. затронут перебираемые значения. Причем изменения отслеживаются в процессе итераций. 

- Добавлен *TypeHinting* для скалярных типов (для аргументов и возвращаемых значений). Подробнее [1](#TypeHinting)

- Оператор *null coalescing* `??` ([1](#null-coalescing))

- Spaceship operator `<=>` ([1](#spaceship-operator))

- Анонимные классы ([1](#анонимные-классы))

- Функция `Closure::call()`, по аналогии с *javascript* привязка `Closure` к нужному объекту ([1](#класс-сlosure)) 

- Группировка классов, функций и констант в одном операторе `use` ([1](#импортирование-и-создание-alias-а)):

  ```php
  use namespacename\{ClassA, ClassB, ClassC as C};
  ```

- Возможности *generator*'ов ([1](#generator))

  - добавлен метод `Generator::getReturn()`, чтобы получить значение, возвращаемое генератором через `return` после завершения генератора.
  - Делегация генератора `yield from`

- Добавлен оператор целочисленного деления `intdiv(10,3)=3` ([1](#int))

## 7.1

- Обнуляемые типы (*nullable types*) ([1](#typehinting))

- Тип возвращаемого значения `void`. ([1](#void))

- Конструкции `list` и `[]` ([1](#конструкции-list-и)):

  - Добавлен короткий синтаксис `[]` для присвоения списку переменных значений за одну операцию, как альтернатива конструкции `list()` 
  - Поддержка ключей в `list()` и коротком синтаксисе `[]`.

- Модификаторы видимости (`public`, `protected`, `private`) для *constant* класса ([1](#константы-const))

- тип `iterable` ([1](#iterable))

- Обработка нескольких исключений в одном блоке `catch`:

  ```php
  try {
      ...
  } catch (FirstException | SecondException $e) {
      ...
  }
  ```

- Поддержка отрицательных смещений для строк:

  - при индексации через `[] ` ([1](#доступ-к-символу)):

    ```php
    "abcdef"[-2]
    $string[-1]
    ```

  - в строковых функциях:

    ```php
    strpos("aabbcc", "b", -3)
    ```

- Добавлен метод `Closure::fromCallable()`  для преобразования `callable` → `Closure` ([1](#класс-closure))

## 7.2

- добавлен тип `object` ([1](#typehinting))
- добавлены возможности для *LSP* ([1](#lsp-в-php)):
  - при наследовании `abstract` классов с `abstract` методами стало возможно использовать методы с <u>совместимыми</u> сигнатурами 
  - `B` опускает (не указывает) тип параметра, тогда как в `A` тип параметра указан (предусловия могут быть ослаблены в подклассах, PHP7.2):
- при преобразовании `array` → `object` и `object` → `array` , корректно обработаются *key*'s и *property*'s с типом `int` ([1](#преобразование-других-типов-в-object)) 

- Разрешена завершающая запятая в списке сгруппированных классов, функций и констант в `use` (как в списке элементов `array`) ([1](#импортирование-и-создание-alias-а))


## 7.3

- Ослаблены требования к синтаксису строк *Heredoc* и *Nowdoc*, чтобы добавить отступы для улучшения читабельности кода ([1](#heredoc), [2](#nowdoc))
- Разрешено ставить запятую `,` после последнего аргумента при вызове функции (метода) ([1](#аргументы-функции))
- Поддерживается присвоение по ссылке в конструкциях `list` и `[]` ([1](#конструкции-list-и))
- Добавлена функция  `is_countable()`, которая проверяет возможность использования аргумента  с функцией `count()` ([1](#countable)).

## 7.4

- введены *typed property*'s (типизированные свойства) – определение *property* может включать *typehint*, кроме типов `void` и `callable `([1](#property)). 
- введены *arrow function*'s (стрелочные функции), также называются *short closure*'s (короткие замыкания) – сокращенная запись для *anonymous function*'s с неявной привязкой *parent scope by value* ([1](#arrow-function)).
- *Null Coalescing Assignment Operator* `??=` (присваивающий оператор объединения с *null*) ([1]())
- *unpacking* `iterable` внутри  `array` с использованием многоточия `...` (*spread operator*) ([1](#unpacking-iterable-внутри-array))
- *Foreign Function Interface* (FFI, интерфейс внешних функций) – класс `FFI` с несколькими статическими методами, который позволяет передавать на исполнение код на языке C, прямо в виде строки из PHP-кода.
- *Preloading* (предварительная загрузка) – возможность загружать явно указанные PHP-файлы в память при запуске и использовать их в исходном виде для всех последующих запросов. Если предварительно загруженные файлы изменяются, сервер должен быть перезапущен.
- добавлены `__serialize()` и `__unserialize()` *magic method*'ы ([1](#serialize-и-unserialize`))
- понижен приоритет оператора конкатенации `.` ([1](#приоритет-и-ассоциативность-оператора))
- добавлен класс `WeakReference` – для реализации слабых ссылок, который позволяет программисту получить такую ссылку на объект `$object`  , которая допускает его уничтожение сборщиком мусора ([1](#`weakreference`)).
- добавлена возможность использовать в числовых литералах (*numeric literal*) символ подчеркивания `_` для визуального разделения групп цифр ([1](#)). 
- вложенная полная форма тернарного оператора может использоваться только с круглыми скобками `()`, явно указывающими приоритет ([1](#тернарный-оператор))

- при попытке использовать не `array` переменные, как `array` выбрасывается `Notice` :

  ```php
  false['key']; # Notice: Trying to access array offset on value of type bool
  ```

  