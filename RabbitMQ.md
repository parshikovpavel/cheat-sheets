http://ajaxblog.ru/php/rabbitmq-tutorial/

http://php-amqplib.github.io/php-amqplib/namespaces/PhpAmqpLib.html

https://www.rabbitmq.com/tutorials/tutorial-one-php.html

# Способы организации очередей

- RabbitMQ
- таблица в MySQL



# Usecase's

- выполнение сложных ресурсоемких задач, которые не могут быть умещены в коротком временном интервале HTTP запроса, в асинхронном режиме
- слабое зацепление между *producer* и *consumer*
- возможность распараллеливания обработки задач, путем подключения нескольких *consumer*'ов.

Примеры:

- Копирование файлов с основного *storage* в резервный *storage* в фоне и асинхронно

 

# Преимущества

-  persistence, в случае некорректного завершения работы сервера, данные в очереди восстанавливаются, обработка продолжается с того же места.
- 

# Установка

Установка RabbitMQ:

```bash
brew install rabbitmq
brew services start rabbitmq
```

Наиболее популярный пакет для работы с RabbitMQ из PHP – `php-amqplib` ([1](https://github.com/php-amqplib/php-amqplib)). Установка:

```bash
composer require php-amqplib/php-amqplib
```



# Базовые понятия

RabbitMQ – *message broker* (брокер сообщений)

RabbitMQ использует протокол AMQP.

RabbitMQ принимает, хранит и пересылает двоичные блоки данных – *message*'s (*сообщения*). Содержимое *message* – *binary-safe*, массив байт.

*Producer* (продюсер) – программа, которая посылает *message*'s.

![producer](https://parshikovpavel.github.io/img/rabbitmq/producer.png)

*Queue* (очередь) – буфер для хранения *message*'s. Несколько *producer*'ов могут отправлять сообщения в одну *queue* , несколько *consumer*'ов могут получать сообщения из одной *queue*. *Queue* ограничена только размерами памяти и диска.

![queue](https://parshikovpavel.github.io/img/rabbitmq/queue.png)

*Consumer* (консьюмер) – программа, которая принимает *message*'s из *queue*.

![consumer](https://parshikovpavel.github.io/img/rabbitmq/consumer.png?1)

Чаще всего *producer*, *message broker* и *consumer* расположены на разных хостах.

*Connection* – абстрагирует соединение через сокет.

*Channel* (канал) – содержит большую часть API для отправки *message*'s. (???)

*Exchange* — пункт роутинга сообщений (здесь мы можем указать, куда какое сообщение должно пойти);

# `rabbitmqctl`

Инструмент для управления *nod*'ами RabbitMQ.

Запуск:

```bash
/usr/local/opt/rabbitmq/sbin/rabbitmqctl
```



## `list_queues` 

Выводит Queue's и их свойства.



# Один *producer* – один *consumer*

![consumer](https://parshikovpavel.github.io/img/rabbitmq/one.png)



<u>Код *producer*'а:</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Объявление Queue
$channel->queue_declare('hello', false, false, false, false);

# Создание Message
$msg = new AMQPMessage('Hello World!');

# Опубликовать Message
$channel->basic_publish($msg, '', 'hello');

# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```

<u>Код *consumer*'а</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Извлечь Queue, в которую публикует Producer (с тем же именем)
$channel->queue_declare('hello', false, false, false, false);

# Запустить Consumer, сообщить серверу, чтобы он доставлял Consumer'у *Message's из Queue.
$channel->basic_consume('hello', '', false, true, false, false,
    function ($msg) { # callback для обработки message
        echo 'Received: ', $msg->body, "\n";
    }
);

# Consumer в бесконечном цикле проверяет, есть ои подключенные consumer'ы.
while ($channel->is_consuming()) {
    # Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику.
    $channel->wait();
}


# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```







# `PhpAmqpLib`

http://php-amqplib.github.io/php-amqplib/

## `Channel`

### `AMQPChannel`

#### `basic_consume()`

Запустить *Consumer*, сообщить серверу, чтобы он доставлял  *Consumer*'у *Message*'s из *Queue*. 

```php
basic_consume(string  $queue = '',string  $consumer_tag = '',boolean  $no_local = false,boolean  $no_ack = false,boolean  $exclusive = false,boolean  $nowait = false,callable|null  $callback = null,...): mixed|string
```

- `$callable`, который будет вызван при получении *Message*:

  ```php
  function ($msg) {
  	...
  }
  ```

  



#### `basic_publish()`

Опубликовать *message*.

```php
basic_publish(\PhpAmqpLib\Message\AMQPMessage  $msg, string  $exchange = '',string  $routing_key = '',boolean  $mandatory = false,boolean  $immediate = false,integer|null  $ticket = null)
```

#### `close()`

Закрыть *channel*.

```
close(...): mixed
```



#### `is_consuming()`

Для *Channel* есть установленные *Consumer*'ы.

```php
is_consuming(): boolean
```

#### `queue_declare()`

Извлечь очередь с указанным именем `$queue` или создать, если она еще не существует.

```php
queue_declare(string  $queue = '',boolean  $passive = false, boolean  $durable = false,boolean  $exclusive = false,boolean  $auto_delete = true,boolean  $nowait = false, ... )
```

#### `wait()`

Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику. 

```
wait(...): mixed
```

#### 



## `Connection`

### `AbstractConnection`

#### `channel()`

Получить *Channel* с указанным `$channel_id` или создать *Channel*, если он еще не существует (наверно с таким ` $channel_id`)

```php
channel(integer  $channel_id = null): \PhpAmqpLib\Channel\AMQPChannel
```



#### `close()`

Закрыть *Connection*

```php
close(...): mixed|null
```





### `AMQPStreamConnection`

#### `__construct()`

```php
__construct(string  $host,string  $port,string  $user,string  $password, ...)
```



## `Message`

### `AMQPMessage`

#### `__construct()`

```php
__construct(string  $body = '', ...)
```

- `$body` – тело сообщения









https://zen.yandex.ru/media/id/5de8a5395d636200b075e410/amqp-na-primere-rabbitmq-kak-je-gotovit-krolika-5e00562d1e8e3f00b0e56b24

1. 

![Слайд № 10](https://avatars.mds.yandex.net/get-zen_doc/1880127/pub_5e00562d1e8e3f00b0e56b24_5e0058c2bb892c00b11f76d7/scale_1200)

Слайд № 10

Producer публикует сообщения в брокер, брокер хранит это сообщение в очереди (и понимает, в какой из очередей его надо хранить), затем доставляет его исполнителю. Либо исполнитель подписывается на сообщения и, как только они появляются, пытается их исполнить. Брокер также может возвращать сообщения в очередь, чтобы они оставались там при необходимости.

Самый банальный пример такой модели — создание PDF.

![Слайд № 11](https://avatars.mds.yandex.net/get-zen_doc/1937051/pub_5e00562d1e8e3f00b0e56b24_5e0058e134808200b67f30b1/scale_1200)

Слайд № 11

Почему создание PDF и подобных задач имеет смысл закинуть в очередь? Обычно они занимают много времени, и тратить его, пока наш пользователь находится между моментом совершения заказа и моментом отправки файла, не хочется. В большинстве случаев разработчики пишут так: «Спасибо за ваш запрос, мы создадим PDF и отправим его вам на почту». Если проект небольшой, то логика при этом обычно происходит в MySQL-таблицах. Но как только встаёт вопрос масштабирования, MySQL даёт сбой — возможны блокировки, отсутствие управления очередью, медленная (по сравнению с memory-based) скорость обработки. Реляционная база данных хороша, но лучше хранить сообщения в хранилище побыстрее и более предназначенном для этого. Мы можем записать этот запрос в очередь и уже из очереди выполнять его и отправлять пользователю.

**Сообщение — это не интерпретируемая брокером единица сущности. Это может быть как просто строка, так и объект в виде JSON или любая структура, представленная в виде строки.**

Неважно, что мы туда запишем; мы можем указать тип сообщения (например application/JSON), и тогда при обработке будет легко узнать, что закладывалось в начале. Сообщение не интерпретируется, оно просто хранится.

Затем оно попадает в exchange, в точку роутинга. Задача точки роутинга — определить, в какую из очередей должно попасть сообщение.

Вместе с сообщением мы можем прислать какой-то ключ. По ключу мы можем понять, в какую из очередей (одну или несколько) должно попасть сообщение.

Соответственно, есть несколько видов точки роутинга, видов работы:

1. простейший вариант — *fanout*, когда сообщение попадает во все доступные очереди;
2. *direct* — полное совпадение ключа. Мы можем создать очередь для одного ключа, очередь для другого; у очереди может быть несколько ключей;
3. *topic* — ключ удовлетворяет маске (#*), где * — любое непустое слово (одно), а # — то же самое, что и *, только здесь допустимо и пустое слово;
4. headers — мы имеем возможность указать какой-то тип прямо в *message* и роутиться по нему (используется, когда нет отдельного ключа).

![Слайд № 12](https://avatars.mds.yandex.net/get-zen_doc/1616946/pub_5e00562d1e8e3f00b0e56b24_5e00592bec575b00b17ada59/scale_1200)

![Слайд № 14](https://avatars.mds.yandex.net/get-zen_doc/1591747/pub_5e00562d1e8e3f00b0e56b24_5e0059d6b477bf00af3fd8d9/scale_1200)

# Возможности

### **1. Durable**

Durable — возможность сохранения состояния при перезагрузке сервера. Например, сервер «уронили» (или он «упал» сам), а очередь нужно не потерять. Для скорости работы очередь хранится в RAM (random-access memory), поэтому, чтобы обеспечить её персистентное состояние, мы должны дополнительно сохранять очередь куда-то на диск. Тут логика работы аналогична любому RAM storage типа Redis и т. п. Мы просто делаем дамп, храним его на диске, в случае «падения» поднимаем дамп с диска — и всё возвращается на круги своя (и никакие сообщения мы не потеряли, кроме периода даунтайма).

Есть несколько режимов создания дампов. Например, в версии 3.9 есть lazyload, который делает полный дамп при каждом запросе, но он значительно сажает производительность. Можно поступить проще: «подрубиться» к RabbitMQ через Redis и использовать хранилище Redis как основное.

Кроме того, нужно логировать, создавать отдельную очередь, которая бы писала всеми любимую реляционную базу данных. Best practice для high-load-проектов, когда мы держим только кеш в состоянии памяти (все новые заказы например). Одно сообщение можно отправить в несколько очередей, и одна из очередей будет использоваться для связи с реляционной базой данных и для постоянного хранения в ней — так же, как у тебя, наверно, сделано и везде с Elastic (или MySQL, или PostgreSQL, или чем-нибудь другим, что у тебя используется на backend'е). В случае с Elastic он используется как кеш и связывается с постоянным хранилищем. В случае «смерти» Elastic'а всё будет нормально, мы не потеряем данные, а вот в случае «смерти» базы данных нормально уже не будет.

### **2. TTL & expiration**

В time to live мы можем указать каждому сообщению или всем сообщениям в очереди (очереди целиком), сколько они будут жить. Например, нам поступает заказ. Мы понимаем, что через 60 минут он уже станет неактуальным (на примере биржи — через час уже значительно изменятся ставки; на примере шаурмы — ни один клиент не будет ждать шаурму час), и мы можем задать TTL, чтобы каждое сообщение, которое пролежит больше 60 минут, исчезало из очереди.

### **3. ACK — acknowledge**

Сообщения могут быть нескольких видов, и самые популярные из них два:

1. сообщение, которое нужно сразу удалить из очереди, как только оно было взято, не дожидаясь ответа от того, кто его забрал (это и есть ACK);
2. сообщение, которое не нужно удалять из очереди, пока не получен нужный ответ. Это сообщение мы помечаем и блокируем, чтобы другие не взяли его. Если нам не вернётся ответ, оно останется у нас, и другие исполнители смогут взять его.

**Кейс: актуальные варианты использования ACK.**

Например, сайт связан с каким-то сторонним сервисом, есть очередь из оплат или трек-номеров посылок. Мы берём одно сообщение, отправляем его в сторонний сервис, а он оказывается (внезапно) под высокой нагрузкой и недоступен. Если бы у нас не было блокировки, это сообщение исчезло бы из очереди, и мы бы потеряли клиента. Чтобы этого избежать, можно вернуть ответ «не получилось» или разделить таймаут по времени таким образом, чтобы, если ответ от поставщика данных задержался более чем на 15 секунд, сообщение возвращалось в очередь.

### **4. Dead lettering**

Dead lettering — когда наше сообщение вернулось с ошибкой (блек-джеком) в очередь и нам нужно обработать его не сразу, а с задержкой 5–10 секунд. Такое часто бывает, когда провайдер данных не доступен (т. е. провайдер возвращает нам ошибку, скажем, 404, 504 или что-то подобное). В этом нет ничего страшного, мы возвращаем сообщение в очередь и при возврате можем указать, через какое время этот элемент будет доступен для повторного просмотра.

У нас есть exchanges разных типов. Ниже представлены примеры, в каких случаях они могут быть использованы.

![Слайд № 15](https://avatars.mds.yandex.net/get-zen_doc/1708012/pub_5e00562d1e8e3f00b0e56b24_5e0059e6e6cb9b00b1819590/scale_1200)

Допустим, у нас есть разные routing keys, которые состоят из нескольких ключей, и тогда нам будут полезны разные вариации exchange. Если у нас указаны несколько ключей, например europe.weather, то это сообщение нужно поместить и в europe, и в weather. Если usa.weather — и в usa, и в weather. Таким образом, мы можем разроутить все сообщения сразу в несколько очередей.





-------



дефолтные значения. Если достаточно дефолтного значения любого из этих параметров, то его можно опустить

 

Используя коннект можно получить объект для канала

 

На основе полученного канала создаем обменник

 

и, собственно, саму очередь

 

Когда обменник и очередь готовы, их можно связать по ключу

 

Объявлять очередь и связывать ее с обменником можно как на продюсере, так и на консьюмере

 

озможно следует объявить и там и там. При этом имена очередей должны совпадать. Если имена очередей совпадают, то количество объявлений не имеет значения.

 

сообщение не может быть опубликовано напрямую в очередь, оно должно проходить через обменник. Собственно посредством обменника оно и публикуется $result = $exchange->publish(json_encode(“Hello world!”), “foo_key”);

 После того как сообщение отослано, коннект можно разорвать.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:07](https://vk.com/im?sel=2733257&msgid=75237)

 

Получатель также должен выполнить ту же последовательность – приконнектиться к серверу сообщений; – создать канал; – объявить обменник; – объявить очередь; – связать очередь с обменником по ключу Последние два действия, как упоминалось выше, не обязательны. Теперь можно начать прослушивать очередь

 

ARMQ_AUTOACK

 

в случае неудачной обработки сообщения, вернуть повторно его в очередь нельзя.

 

Распределенные очереди

23 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:37](https://vk.com/im?sel=2733257&msgid=75243)

 

о обработать видео файл, чтобы получить на выходе три сконвертированных файла в различные форматы, информацию о метаданных и создать иконки для этого видеофайла. Т.е. получаем 5 задач

 

все эти задачи являются независимыми друг от друга. Таким образом, можно выполнять их одновременно,

 

при объявлении обменника необходимо установить ему тип AMQP_EX_TYPE_FANOUT. Тогда все сообщения, посылаемые в указанный обменник, независимо от имени очереди и ключа роутера, будут прослушиваться всеми запущенными копиями консьюмера. Т.е. каждое следующее сообщение будет отсылаться на следующий свободный консьюмер

 

round-robin dispathing.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:01](https://vk.com/im?sel=2733257&msgid=75259)

 

е оповещение было отключено путем передачи параметра AMQP_AUTOACK в метод get(). В этом случае сообщения удаляются из памяти сразу после выполнения метода get и в случае ошибки, случившейся во время обработки, не вернутся в очередь. Чтобы избежать этого, не будем передавать константу AMQP_AUTOACK в метод get. Вместо этого по завершению обработки вызовем метод ack(), который уведомит брокер о том, что сообщение успешно обработано и его можно удалить из памяти. В противном случае RabbitMQ понимает, что сообщение не обратботано и перенаправляет его другому свободному консьюмеру. О

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:11](https://vk.com/im?sel=2733257&msgid=75260)

 

Перенаправленные сообщения не будут обрабатываться до того пока консьюмер не отконнектится и приконнектится заново к брокеру. Если необходимо заново обработать сообщение в рамках того же коннекта к серверу сообщений, то необходимо вызвать метод nack() с флагом AMQP_REQUEUE, который поставит неудачно обработанную задачу обратно в очередь и уведомит брокер о том, что эта задача должна быть вновь обработана.

 

Распростаненная ошибка – при включенном оповещении не подтверждать корректно обработанные задачи(сообщения). В этом случае при каждом новом коннекте, все уже обработанные задачи будут поступать заново на обработку.

 

Отследить такую ситуацию можно путем использования нативного инструмента сервера сообщений rabbitmqctl

 

ь, очередь должна быть создана с флагом AMQP_DURABLE.

 

Установка флага AMQP_DURABLE не гарантирует стопроцентную сохранность сообщений в очереди

 

существует мертвая зона после получения соощения, когда оно уже в памяти, но еще не сохранено на диске. В этот момент, в случае не предвиденной ситуации, оно может быть утеряно из памяти.

 

если необходимо добиться высоких гарантий получения сообщения, то следует использовать транзакции.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:40](https://vk.com/im?sel=2733257&msgid=75359)

 

отсылать все сообщения из очереди на все консьюмеры. Такой шаблон известен как “публичная рассылка”(publish subscribe). Такое поведение может быть полезно, к примеру, при создании логирования с одновременным выводом сообщения в терминал. Т.е. один консьюмер получает сообщение и сохраняет его на диска, в то время как другой выводит это сообщение на экране.

 

а обменнике(exchanger). На самом деле продюсер никогда не отправляет сообщения непосредственно в очередь. Он размещает их в обменнике.

 

получает сообщения от продюсера и отправляет(публикует) их в очередь.

 

отправляет сообщение во все очереди с четко заданным именем на все консьюмеры, обрабатывающими эту очередь(direct)отправляет сообщение во все очереди и распределяет сообщение между консьюмерами, обрабатывающими очередь с одинаковым именем(fanout)отправляет сообщение во все очереди с именем, удовлетворяющим шаблону(topic)отклоняет сообщение

25 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:46](https://vk.com/im?sel=2733257&msgid=75419)

 

. Консьюмер же, в свою очередь, создает анонимную очередь, в которую принимает сообщения продюсера. При таком подходе каждый консьюмер будет принимать все сообщения продюсера.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:30](https://vk.com/im?sel=2733257&msgid=75423)

 

Если при объявлении очереди не устанавливать ей имя, то RabbitMQ сам задаст рандомное имя очереди. Для возможности автоматического удаления очереди, при ее создании нужно задать флаги AMQP_IFUNUSED, AMQP_AUTODELETE.

 

. Теперь нужно сказать обменнику, что он должен публиковать сообщения имеено в эту очередь. Это отношение называется связыванием (binding)

 

десь второй параметр – ключ, по которому связывается обменник и очередь. В данном случае он может быть любой строкой, поскольку его значение игнорируется в случае, если обменник имеет тип fanout.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:43](https://vk.com/im?sel=2733257&msgid=75426)

 

отсылать сообщения в четко определенные очереди. Такая возможность может понадобиться, к примеру, если мы не хотим сохранять все сообщения на диске, а только критический. В то время как на экран будут выводиться все сообщения.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:31](https://vk.com/im?sel=2733257&msgid=75430)

 

ь. В методе bind() имеется второй параметр – ключ(routingKey), по которому связывается обменник и очередь.

 

ключ напрямую зависит от типа обменника

 

– direct, который отправляет сообщения только тем очередям, routingKey которых совпадает с routingKey сообщения.

 

обменник X с типом direct, который связан с очередью Q1 по ключу failure, и с очередью Q2 по ключам notice и warning.

 

Сообщения, ключи которые не совпадают с выше указанными, будут игнорироваться всеми очередями.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:58](https://vk.com/im?sel=2733257&msgid=75435)

 

не возможно несколько очередей связать с обменником по одному и тому же ключу

26 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:49](https://vk.com/im?sel=2733257&msgid=75466)

 

В таком случае сообщения с ключем notice будут отсылаться на обе очереди, т.е. получаем поведение аналогичное обменнику с типом fanout.

 

Для отправки сообщений способом точка-точка обменник должен быть создан с типом direct, который сооветствует константе AMQP_EX_TYPE_DIRECT.

 

После чего возможна публикация сообщений по ключу

27 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [11:44](https://vk.com/im?sel=2733257&msgid=75555)

 

разделить обработаку логирования основываясь не только на важности сообщений, но и по устройствам, вызвавшим эту ошибку

 

AMQP_EX_TYPE_TOPIC. Ключи routingKey составляются из слова, следующих через точку, например, “logs.devices.kernel.notice”, “logs.devices.cron”. Максимальная длина такого ключа может составлять 255 символов. Логика доставки сообщений по ключу схожа с логикой для обменников с типом direct – сообщения с определенным ключем будут доставлены в очереди с соответствующим ключем.

28 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:55](https://vk.com/im?sel=2733257&msgid=75559)

 

. Ключи, используемые для связи по шаблону, могут содержать два специальных символа:

 \* , соответствует строго одному слову;# , соответствует любому количеству слов, в том числе и отсутствию слов;

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:33](https://vk.com/im?sel=2733257&msgid=75579)

 

Обменник с типом topic может повторять поведение обменника с типом fanout, если с ним связать очередь по ключу “#”. Если в ключе не испльзовать специальных символов, то такой обменник будет соответствовать обменнику с типом direct.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:40](https://vk.com/im?sel=2733257&msgid=75580)

 

о если нам нужно получить результат от обработчика очереди. Такой подход известен как вызов удаленных процедур или RPC(remote procedure call). В

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [23:10](https://vk.com/im?sel=2733257&msgid=75588)

 

Для обработки ответа сервера, необходимо создать callback очередь. Чтобы узнать какая callback очередь ожидает ответа, мы должны в запросе послать ее имя. Для этого на продюсере создается анонимная очередь и ее имя добавляется в параметры запроса

 

callback очередь создается с флагом AMQP_EXCLUSIVE, что означает, что только один консьюмер может слушать эту очередь.

29 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [1:11](https://vk.com/im?sel=2733257&msgid=75590)

 

В методе, представленном выше, мы предполагаем создавать callback очередь для каждого RPC запроса. Поскольку нельзя однозначно по имени очереди определить какому запросу принадлежит ответ, в запрос также добавляется параметр correlationId, который имеет уникальное значение для каждого запроса. Позже, когда мы получим ответ, мы сможем сравнить его correlationId со значением, переданным вместе с запросом.



http://jstructure.com/post/re-execution-of-tasks-in-rabbitmq/

Во время выполнения задач, которые приходят подписчику из очереди в виде сообщения, возможны случаи сбоев и ошибок. При этом бывает, что задачу нужно попробовать выполнить некоторое количество раз, прежде чем удалить ее из очереди.

## Решение 1. Возврат сообщения в очередь.

При возникновении ошибки на стороне подписчика можно отклонить сообщение (*reject* или *nack* с параметром `requeue=true`), оставив сообщение в очереди. Если очередь объявлена с параметром `no_ack=false` и подписчик не выполняет *ack*, сообщение также возвращается в очередь. При возврате сообщения в очередь ему автоматически добавляется заголовок `redelivered=true`. Количество возвратов при этом нельзя зафиксировать. По наличию этого заголовка можно понять только то, что сообщение уже обрабатывалось и по каким-то причинам возвратилось в очередь. Таким образом, вариантов лимитирования количества попыток обработки сообщений немного — либо 1 раз, либо 2 раза, либо возвращать сообщение в очередь до тех пор, пока оно не обработается без ошибки. Возможность появления дублей и потери сообщений в данном решении отсутствуют.



## Решение 4. Использование Dead Letter Exchanges.

**RabbitMQ**, начиная с версии [2.8.0](https://www.rabbitmq.com/release-notes/README-2.8.0.txt), предоставляет функционал перенаправления сообщения из очереди в другую точку доступа (*exchange*), называемую *[Dead letter exchange](https://www.rabbitmq.com/dlx.html) (DLX)*. Этот функционал выходит за рамки протокола [AMQP](https://www.amqp.org/). Ниже перечислены случаи, при которых это возможно.

- Отклонение сообщения (*reject* или *nack*) с параметром `requeue=false`.
- Истечение *TTL* сообщения.
- Достижение лимита очереди.

*DLX* можно задать на стороне клиента для любой очереди, задав соответствующий аргумент `x-dead-letter-exchange` при объявлении очереди. Также это можно сделать и на стороне сервера.

Стоит отметить, что при публикации сообщения в другую очередь, сообщение не удаляется до тех пор, пока *dead-letter* очереди не подтвердят получение сообщений. Таким образом, непредвиденное выключение брокера во время сбоя может привести к **дублированию сообщения**. То есть *dead-letter* очередь получит сообщение, а подтверждение получения отправить не успеет, поэтому в первичной очереди сообщение останется.

Используя функционал *DLX*, можно реализовать повторную обработку сообщений. Пример показан в статье «[RabbitMQ delay retry/schedule with Dead Letter Exchange](https://medium.com/@kiennguyen88/rabbitmq-delay-retry-schedule-with-dead-letter-exchange-31fb25a440fc)». Ниже приводится немного измененная реализация.

Необходимо:

- создать две точки доступа: *WorkExchange* и *RetryExchange*;
- создать очередь *WorkQueue* с параметрами `x-dead-letter-exchange=RetryExchange` и связать ее c *WorkExchange*;
- создать очередь *RetryQueue* с параметрами `x-dead-letter-exchange=WorkExchange` и `x-message-ttl=300000`, и связать ее c *RetryExchange*.

Исходное сообщение попадает в очередь *WorkQueue*. Подписчик забирает сообщение и в случае сбоя выполняет *reject* (или *nack*) с параметром `requeue=false`. После этого сообщение попадает в очередь *RetryQueue*, откуда, спустя 300000 мс, отправляется, минуя точку доступа *WorkExchange*, обратно в очередь *WorkQueue*.



https://habr.com/ru/post/235505/

Иногда нужно выполнить какую-либо задачу не «вот-прям-сию-секунду», а спустя некоторое время.

Например, у нас есть скрипт, который время от времени обращается к какому-нибудь API, и, если ответ не изменился, «зысыпает» на некоторое время, потом «просыпается» и снова проверяет.

Или, к примеру, мы сохранили временный файл и нам нужно завести таймер, чтобы удалить файл по истечении указанного времени.

В подобных случаях нам нужен механизм, позволяющий создать в RabbitMQ отложенное сообщение (если, конечно, мы хотим делать это средствами RabbitMQ).

К сожалению, в самом RabbitMQ нет готового механизма для публикации отложенных сообщений. Сообщения, публикуемые отправителями в RabbitMQ, доставляются получателям мгновенно. Конечно, получатель может быть не подключен к RabbitMQ, в этом случае сообщение будет доставлено после подключения, но если получатель подключен — доставка сообщения производится сразу.

Нельзя просто так опубликовать сообщение и сказать ему: «Полежи пока незаметно в уголочке, а через 10 минут вылезай и доставляйся получателю».

Поэтому возникает задача — как, с помощью RabbitMQ, организовать отложенные сообщения?



#### Решение


Для этого придется сделать обходной маневр. Ключевая идея такая — если сообщение, отправленное в очередь, немедленно доставляется слушающему эту очередь получателю, значит, нужно отправить это сообщение в другую очередь!

В общем и целом схема работы будет такая:

![image](https://habrastorage.org/getpro/habr/post_images/7d5/483/fd3/7d5483fd3a8e6cfeadafe576c6bf67fb.jpg)



1. Создаем обменник, в который будут отправляться отложенные сообщения
2. Создаем очередь, в которой будут храниться отложенные сообщения
3. Делаем переплет между очередью и обменником
4. Настраиваем очередь так, чтобы сообщения, полежав в ней некоторое заданное время, отправлялись в обычный обменник, для немедленной доставки получателю

https://habr.com/ru/post/235983/

Устаревшее сообщение будет висеть в очереди, пока не придет его очередь (каламбур, ага).

В тот момент, когда его очередь, наконец, придет, произойдет одно из двух:



1. Если для очереди не установлен параметр «x-dead-letter-exchange», то сообщение будет просто удалено, без доставки кому-либо
2. Если же параметр «x-dead-letter-exchange» установлен, то сообщение будет переложено в указанный обменник