http://ajaxblog.ru/php/rabbitmq-tutorial/

http://php-amqplib.github.io/php-amqplib/namespaces/PhpAmqpLib.html

https://www.rabbitmq.com/tutorials/tutorial-one-php.html

# Способы организации очередей

- RabbitMQ
- таблица в MySQL



# Usecase's

- выполнение сложных ресурсоемких задач, которые не могут быть умещены в коротком временном интервале HTTP запроса, в асинхронном режиме
- слабое зацепление между *producer* и *consumer*
- возможность распараллеливания обработки задач, путем подключения нескольких *consumer*'ов.

Примеры:

- Копирование файлов с основного *storage* в резервный *storage* в фоне и асинхронно

 

# Преимущества

-  persistence, в случае некорректного завершения работы сервера, данные в очереди восстанавливаются, обработка продолжается с того же места.
- 

# Установка

Установка RabbitMQ:

```bash
brew install rabbitmq
brew services start rabbitmq
```

Наиболее популярный пакет для работы с RabbitMQ из PHP – `php-amqplib` ([1](https://github.com/php-amqplib/php-amqplib)). Установка:

```bash
composer require php-amqplib/php-amqplib
```



# Базовые понятия

RabbitMQ – *message broker* (брокер сообщений)

RabbitMQ использует протокол AMQP.

RabbitMQ принимает, хранит и пересылает двоичные блоки данных – *message*'s (*сообщения*). Содержимое *message* – *binary-safe*, массив байт.

*Producer* (продюсер) – программа, которая посылает *message*'s.

![producer](https://parshikovpavel.github.io/img/rabbitmq/producer.png)

*Queue* (очередь) – буфер для хранения *message*'s. Несколько *producer*'ов могут отправлять сообщения в одну *queue* , несколько *consumer*'ов могут получать сообщения из одной *queue*. *Queue* ограничена только размерами памяти и диска.

![queue](https://parshikovpavel.github.io/img/rabbitmq/queue.png)

*Consumer* (консьюмер) – программа, которая принимает *message*'s из *queue*.

![consumer](https://parshikovpavel.github.io/img/rabbitmq/consumer.png?1)

Чаще всего *producer*, *message broker* и *consumer* расположены на разных хостах.

*Connection* – абстрагирует соединение через сокет.

*Channel* (канал) – содержит большую часть API для отправки *message*'s. (???)

# `rabbitmqctl`

Инструмент для управления *nod*'ами RabbitMQ.

Запуск:

```bash
/usr/local/opt/rabbitmq/sbin/rabbitmqctl
```



## `list_queues` 

Выводит Queue's и их свойства.



# Один *producer* – один *consumer*

![consumer](https://parshikovpavel.github.io/img/rabbitmq/one.png)



<u>Код *producer*'а:</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Объявление Queue
$channel->queue_declare('hello', false, false, false, false);

# Создание Message
$msg = new AMQPMessage('Hello World!');

# Опубликовать Message
$channel->basic_publish($msg, '', 'hello');

# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```

<u>Код *consumer*'а</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Извлечь Queue, в которую публикует Producer (с тем же именем)
$channel->queue_declare('hello', false, false, false, false);

# Запустить Consumer, сообщить серверу, чтобы он доставлял Consumer'у *Message's из Queue.
$channel->basic_consume('hello', '', false, true, false, false,
    function ($msg) { # callback для обработки message
        echo 'Received: ', $msg->body, "\n";
    }
);

# Consumer в бесконечном цикле проверяет, есть ои подключенные consumer'ы.
while ($channel->is_consuming()) {
    # Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику.
    $channel->wait();
}


# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```







# `PhpAmqpLib`

http://php-amqplib.github.io/php-amqplib/

## `Channel`

### `AMQPChannel`

#### `basic_consume()`

Запустить *Consumer*, сообщить серверу, чтобы он доставлял  *Consumer*'у *Message*'s из *Queue*. 

```php
basic_consume(string  $queue = '',string  $consumer_tag = '',boolean  $no_local = false,boolean  $no_ack = false,boolean  $exclusive = false,boolean  $nowait = false,callable|null  $callback = null,...): mixed|string
```

- `$callable`, который будет вызван при получении *Message*:

  ```php
  function ($msg) {
  	...
  }
  ```

  



#### `basic_publish()`

Опубликовать *message*.

```php
basic_publish(\PhpAmqpLib\Message\AMQPMessage  $msg, string  $exchange = '',string  $routing_key = '',boolean  $mandatory = false,boolean  $immediate = false,integer|null  $ticket = null)
```

#### `close()`

Закрыть *channel*.

```
close(...): mixed
```



#### `is_consuming()`

Для *Channel* есть установленные *Consumer*'ы.

```php
is_consuming(): boolean
```

#### `queue_declare()`

Извлечь очередь с указанным именем `$queue` или создать, если она еще не существует.

```php
queue_declare(string  $queue = '',boolean  $passive = false, boolean  $durable = false,boolean  $exclusive = false,boolean  $auto_delete = true,boolean  $nowait = false, ... )
```

#### `wait()`

Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику. 

```
wait(...): mixed
```

#### 



## `Connection`

### `AbstractConnection`

#### `channel()`

Получить *Channel* с указанным `$channel_id` или создать *Channel*, если он еще не существует (наверно с таким ` $channel_id`)

```php
channel(integer  $channel_id = null): \PhpAmqpLib\Channel\AMQPChannel
```



#### `close()`

Закрыть *Connection*

```php
close(...): mixed|null
```





### `AMQPStreamConnection`

#### `__construct()`

```php
__construct(string  $host,string  $port,string  $user,string  $password, ...)
```



## `Message`

### `AMQPMessage`

#### `__construct()`

```php
__construct(string  $body = '', ...)
```

- `$body` – тело сообщения





дефолтные значения. Если достаточно дефолтного значения любого из этих параметров, то его можно опустить

 

Используя коннект можно получить объект для канала

 

На основе полученного канала создаем обменник

 

и, собственно, саму очередь

 

Когда обменник и очередь готовы, их можно связать по ключу

 

Объявлять очередь и связывать ее с обменником можно как на продюсере, так и на консьюмере

 

озможно следует объявить и там и там. При этом имена очередей должны совпадать. Если имена очередей совпадают, то количество объявлений не имеет значения.

 

сообщение не может быть опубликовано напрямую в очередь, оно должно проходить через обменник. Собственно посредством обменника оно и публикуется $result = $exchange->publish(json_encode(“Hello world!”), “foo_key”);

 После того как сообщение отослано, коннект можно разорвать.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:07](https://vk.com/im?sel=2733257&msgid=75237)

 

Получатель также должен выполнить ту же последовательность – приконнектиться к серверу сообщений; – создать канал; – объявить обменник; – объявить очередь; – связать очередь с обменником по ключу Последние два действия, как упоминалось выше, не обязательны. Теперь можно начать прослушивать очередь

 

ARMQ_AUTOACK

 

в случае неудачной обработки сообщения, вернуть повторно его в очередь нельзя.

 

Распределенные очереди

23 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:37](https://vk.com/im?sel=2733257&msgid=75243)

 

о обработать видео файл, чтобы получить на выходе три сконвертированных файла в различные форматы, информацию о метаданных и создать иконки для этого видеофайла. Т.е. получаем 5 задач

 

все эти задачи являются независимыми друг от друга. Таким образом, можно выполнять их одновременно,

 

при объявлении обменника необходимо установить ему тип AMQP_EX_TYPE_FANOUT. Тогда все сообщения, посылаемые в указанный обменник, независимо от имени очереди и ключа роутера, будут прослушиваться всеми запущенными копиями консьюмера. Т.е. каждое следующее сообщение будет отсылаться на следующий свободный консьюмер

 

round-robin dispathing.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:01](https://vk.com/im?sel=2733257&msgid=75259)

 

е оповещение было отключено путем передачи параметра AMQP_AUTOACK в метод get(). В этом случае сообщения удаляются из памяти сразу после выполнения метода get и в случае ошибки, случившейся во время обработки, не вернутся в очередь. Чтобы избежать этого, не будем передавать константу AMQP_AUTOACK в метод get. Вместо этого по завершению обработки вызовем метод ack(), который уведомит брокер о том, что сообщение успешно обработано и его можно удалить из памяти. В противном случае RabbitMQ понимает, что сообщение не обратботано и перенаправляет его другому свободному консьюмеру. О

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:11](https://vk.com/im?sel=2733257&msgid=75260)

 

Перенаправленные сообщения не будут обрабатываться до того пока консьюмер не отконнектится и приконнектится заново к брокеру. Если необходимо заново обработать сообщение в рамках того же коннекта к серверу сообщений, то необходимо вызвать метод nack() с флагом AMQP_REQUEUE, который поставит неудачно обработанную задачу обратно в очередь и уведомит брокер о том, что эта задача должна быть вновь обработана.

 

Распростаненная ошибка – при включенном оповещении не подтверждать корректно обработанные задачи(сообщения). В этом случае при каждом новом коннекте, все уже обработанные задачи будут поступать заново на обработку.

 

Отследить такую ситуацию можно путем использования нативного инструмента сервера сообщений rabbitmqctl

 

ь, очередь должна быть создана с флагом AMQP_DURABLE.

 

Установка флага AMQP_DURABLE не гарантирует стопроцентную сохранность сообщений в очереди

 

существует мертвая зона после получения соощения, когда оно уже в памяти, но еще не сохранено на диске. В этот момент, в случае не предвиденной ситуации, оно может быть утеряно из памяти.

 

если необходимо добиться высоких гарантий получения сообщения, то следует использовать транзакции.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:40](https://vk.com/im?sel=2733257&msgid=75359)

 

отсылать все сообщения из очереди на все консьюмеры. Такой шаблон известен как “публичная рассылка”(publish subscribe). Такое поведение может быть полезно, к примеру, при создании логирования с одновременным выводом сообщения в терминал. Т.е. один консьюмер получает сообщение и сохраняет его на диска, в то время как другой выводит это сообщение на экране.

 

а обменнике(exchanger). На самом деле продюсер никогда не отправляет сообщения непосредственно в очередь. Он размещает их в обменнике.

 

получает сообщения от продюсера и отправляет(публикует) их в очередь.

 

отправляет сообщение во все очереди с четко заданным именем на все консьюмеры, обрабатывающими эту очередь(direct)отправляет сообщение во все очереди и распределяет сообщение между консьюмерами, обрабатывающими очередь с одинаковым именем(fanout)отправляет сообщение во все очереди с именем, удовлетворяющим шаблону(topic)отклоняет сообщение

25 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:46](https://vk.com/im?sel=2733257&msgid=75419)

 

. Консьюмер же, в свою очередь, создает анонимную очередь, в которую принимает сообщения продюсера. При таком подходе каждый консьюмер будет принимать все сообщения продюсера.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:30](https://vk.com/im?sel=2733257&msgid=75423)

 

Если при объявлении очереди не устанавливать ей имя, то RabbitMQ сам задаст рандомное имя очереди. Для возможности автоматического удаления очереди, при ее создании нужно задать флаги AMQP_IFUNUSED, AMQP_AUTODELETE.

 

. Теперь нужно сказать обменнику, что он должен публиковать сообщения имеено в эту очередь. Это отношение называется связыванием (binding)

 

десь второй параметр – ключ, по которому связывается обменник и очередь. В данном случае он может быть любой строкой, поскольку его значение игнорируется в случае, если обменник имеет тип fanout.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:43](https://vk.com/im?sel=2733257&msgid=75426)

 

отсылать сообщения в четко определенные очереди. Такая возможность может понадобиться, к примеру, если мы не хотим сохранять все сообщения на диске, а только критический. В то время как на экран будут выводиться все сообщения.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:31](https://vk.com/im?sel=2733257&msgid=75430)

 

ь. В методе bind() имеется второй параметр – ключ(routingKey), по которому связывается обменник и очередь.

 

ключ напрямую зависит от типа обменника

 

– direct, который отправляет сообщения только тем очередям, routingKey которых совпадает с routingKey сообщения.

 

обменник X с типом direct, который связан с очередью Q1 по ключу failure, и с очередью Q2 по ключам notice и warning.

 

Сообщения, ключи которые не совпадают с выше указанными, будут игнорироваться всеми очередями.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:58](https://vk.com/im?sel=2733257&msgid=75435)

 

не возможно несколько очередей связать с обменником по одному и тому же ключу

26 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:49](https://vk.com/im?sel=2733257&msgid=75466)

 

В таком случае сообщения с ключем notice будут отсылаться на обе очереди, т.е. получаем поведение аналогичное обменнику с типом fanout.

 

Для отправки сообщений способом точка-точка обменник должен быть создан с типом direct, который сооветствует константе AMQP_EX_TYPE_DIRECT.

 

После чего возможна публикация сообщений по ключу

27 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [11:44](https://vk.com/im?sel=2733257&msgid=75555)

 

разделить обработаку логирования основываясь не только на важности сообщений, но и по устройствам, вызвавшим эту ошибку

 

AMQP_EX_TYPE_TOPIC. Ключи routingKey составляются из слова, следующих через точку, например, “logs.devices.kernel.notice”, “logs.devices.cron”. Максимальная длина такого ключа может составлять 255 символов. Логика доставки сообщений по ключу схожа с логикой для обменников с типом direct – сообщения с определенным ключем будут доставлены в очереди с соответствующим ключем.

28 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:55](https://vk.com/im?sel=2733257&msgid=75559)

 

. Ключи, используемые для связи по шаблону, могут содержать два специальных символа:

 \* , соответствует строго одному слову;# , соответствует любому количеству слов, в том числе и отсутствию слов;

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:33](https://vk.com/im?sel=2733257&msgid=75579)

 

Обменник с типом topic может повторять поведение обменника с типом fanout, если с ним связать очередь по ключу “#”. Если в ключе не испльзовать специальных символов, то такой обменник будет соответствовать обменнику с типом direct.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:40](https://vk.com/im?sel=2733257&msgid=75580)

 

о если нам нужно получить результат от обработчика очереди. Такой подход известен как вызов удаленных процедур или RPC(remote procedure call). В

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [23:10](https://vk.com/im?sel=2733257&msgid=75588)

 

Для обработки ответа сервера, необходимо создать callback очередь. Чтобы узнать какая callback очередь ожидает ответа, мы должны в запросе послать ее имя. Для этого на продюсере создается анонимная очередь и ее имя добавляется в параметры запроса

 

callback очередь создается с флагом AMQP_EXCLUSIVE, что означает, что только один консьюмер может слушать эту очередь.

29 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [1:11](https://vk.com/im?sel=2733257&msgid=75590)

 

В методе, представленном выше, мы предполагаем создавать callback очередь для каждого RPC запроса. Поскольку нельзя однозначно по имени очереди определить какому запросу принадлежит ответ, в запрос также добавляется параметр correlationId, который имеет уникальное значение для каждого запроса. Позже, когда мы получим ответ, мы сможем сравнить его correlationId со значением, переданным вместе с запросом.