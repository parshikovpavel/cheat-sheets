http://ajaxblog.ru/php/rabbitmq-tutorial/

http://php-amqplib.github.io/php-amqplib/namespaces/PhpAmqpLib.html

https://www.rabbitmq.com/tutorials/tutorial-one-php.html

# Способы организации очередей

- RabbitMQ
- таблица в MySQL



# Usecase's

- выполнение сложных ресурсоемких задач, которые не могут быть умещены в коротком временном интервале HTTP запроса, в асинхронном режиме
- слабое зацепление между *producer* и *consumer*
- возможность распараллеливания обработки задач, путем подключения нескольких *consumer*'ов.

Примеры:

- Копирование файлов с основного *storage* в резервный *storage* в фоне и асинхронно

 

# Преимущества

-  persistence, в случае некорректного завершения работы сервера, данные в очереди восстанавливаются, обработка продолжается с того же места.
- 

# Установка

Установка RabbitMQ:

```bash
brew install rabbitmq
brew services start rabbitmq
```

Наиболее популярный пакет для работы с RabbitMQ из PHP – `php-amqplib` ([1](https://github.com/php-amqplib/php-amqplib)). Установка:

```bash
composer require php-amqplib/php-amqplib
```



# Базовые понятия

RabbitMQ – *message broker* (брокер сообщений)

RabbitMQ использует протокол AMQP.

RabbitMQ принимает, хранит и пересылает двоичные блоки данных – *message*'s (*сообщения*). Содержимое *message* – *binary-safe*, массив байт.

*Producer* (продюсер) – программа, которая посылает *message*'s.

![producer](https://parshikovpavel.github.io/img/rabbitmq/producer.png)

*Queue* (очередь) – буфер для хранения *message*'s. Несколько *producer*'ов могут отправлять сообщения в одну *queue* , несколько *consumer*'ов могут получать сообщения из одной *queue*. *Queue* ограничена только размерами памяти и диска.

![queue](https://parshikovpavel.github.io/img/rabbitmq/queue.png)

*Consumer* (консьюмер) – программа, которая принимает *message*'s из *queue*.

![consumer](https://parshikovpavel.github.io/img/rabbitmq/consumer.png?1)

Чаще всего *producer*, *message broker* и *consumer* расположены на разных хостах.

*Connection* – абстрагирует соединение через сокет.

*Channel* (канал) – содержит большую часть API для отправки *message*'s. (???)

# `rabbitmqctl`

Инструмент для управления *nod*'ами RabbitMQ.

Запуск:

```bash
/usr/local/opt/rabbitmq/sbin/rabbitmqctl
```



## `list_queues` 

Выводит Queue's и их свойства.



# Один *producer* – один *consumer*

![consumer](https://parshikovpavel.github.io/img/rabbitmq/one.png)



<u>Код *producer*'а:</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Объявление Queue
$channel->queue_declare('hello', false, false, false, false);

# Создание Message
$msg = new AMQPMessage('Hello World!');

# Опубликовать Message
$channel->basic_publish($msg, '', 'hello');

# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```

<u>Код *consumer*'а</u>

```php
require_once __DIR__ . '/../vendor/autoload.php';

use PhpAmqpLib\Connection\AMQPStreamConnection;
use PhpAmqpLib\Message\AMQPMessage;

#  Создание Connection к серверу
$connection = new AMQPStreamConnection('localhost', 5672, 'guest', 'guest');

# Создать объект Channel
$channel = $connection->channel();

# Извлечь Queue, в которую публикует Producer (с тем же именем)
$channel->queue_declare('hello', false, false, false, false);

# Запустить Consumer, сообщить серверу, чтобы он доставлял Consumer'у *Message's из Queue.
$channel->basic_consume('hello', '', false, true, false, false,
    function ($msg) { # callback для обработки message
        echo 'Received: ', $msg->body, "\n";
    }
);

# Consumer в бесконечном цикле проверяет, есть ои подключенные consumer'ы.
while ($channel->is_consuming()) {
    # Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику.
    $channel->wait();
}


# Закрыть Channel
$channel->close();

# Закрыть Connection
$connection->close();
```







# `PhpAmqpLib`

http://php-amqplib.github.io/php-amqplib/

## `Channel`

### `AMQPChannel`

#### `basic_consume()`

Запустить *Consumer*, сообщить серверу, чтобы он доставлял  *Consumer*'у *Message*'s из *Queue*. 

```php
basic_consume(string  $queue = '',string  $consumer_tag = '',boolean  $no_local = false,boolean  $no_ack = false,boolean  $exclusive = false,boolean  $nowait = false,callable|null  $callback = null,...): mixed|string
```

- `$callable`, который будет вызван при получении *Message*:

  ```php
  function ($msg) {
  	...
  }
  ```

  



#### `basic_publish()`

Опубликовать *message*.

```php
basic_publish(\PhpAmqpLib\Message\AMQPMessage  $msg, string  $exchange = '',string  $routing_key = '',boolean  $mandatory = false,boolean  $immediate = false,integer|null  $ticket = null)
```

#### `close()`

Закрыть *channel*.

```
close(...): mixed
```



#### `is_consuming()`

Для *Channel* есть установленные *Consumer*'ы.

```php
is_consuming(): boolean
```

#### `queue_declare()`

Извлечь очередь с указанным именем `$queue` или создать, если она еще не существует.

```php
queue_declare(string  $queue = '',boolean  $passive = false, boolean  $durable = false,boolean  $exclusive = false,boolean  $auto_delete = true,boolean  $nowait = false, ... )
```

#### `wait()`

Ожидать срабатывания некоторых событий и диспетчеровать их к обработчику. 

```
wait(...): mixed
```

#### 



## `Connection`

### `AbstractConnection`

#### `channel()`

Получить *Channel* с указанным `$channel_id` или создать *Channel*, если он еще не существует (наверно с таким ` $channel_id`)

```php
channel(integer  $channel_id = null): \PhpAmqpLib\Channel\AMQPChannel
```



#### `close()`

Закрыть *Connection*

```php
close(...): mixed|null
```





### `AMQPStreamConnection`

#### `__construct()`

```php
__construct(string  $host,string  $port,string  $user,string  $password, ...)
```



## `Message`

### `AMQPMessage`

#### `__construct()`

```php
__construct(string  $body = '', ...)
```

- `$body` – тело сообщения









https://zen.yandex.ru/media/id/5de8a5395d636200b075e410/amqp-na-primere-rabbitmq-kak-je-gotovit-krolika-5e00562d1e8e3f00b0e56b24

В AMQP есть несколько дефолтных сущностей, с которыми и происходит работа:

1. producer — отправитель сообщения;
2. message — само сообщение;
3. exchange — пункт роутинга сообщений (здесь мы можем указать, куда какое сообщение должно пойти);
4. queue — сама очередь из сообщений;
5. consumer — исполнитель, который из этой очереди что-то заберёт и что-то сделает.

Если смотреть принципиально (сверху), то AMQP-протокол вообще и RabbitMQ в частности представляют собой следующую модель.

![Слайд № 10](https://avatars.mds.yandex.net/get-zen_doc/1880127/pub_5e00562d1e8e3f00b0e56b24_5e0058c2bb892c00b11f76d7/scale_1200)

Слайд № 10

Producer публикует сообщения в брокер, брокер хранит это сообщение в очереди (и понимает, в какой из очередей его надо хранить), затем доставляет его исполнителю. Либо исполнитель подписывается на сообщения и, как только они появляются, пытается их исполнить. Брокер также может возвращать сообщения в очередь, чтобы они оставались там при необходимости.

Самый банальный пример такой модели — создание PDF.

![Слайд № 11](https://avatars.mds.yandex.net/get-zen_doc/1937051/pub_5e00562d1e8e3f00b0e56b24_5e0058e134808200b67f30b1/scale_1200)

Слайд № 11

Почему создание PDF и подобных задач имеет смысл закинуть в очередь? Обычно они занимают много времени, и тратить его, пока наш пользователь находится между моментом совершения заказа и моментом отправки файла, не хочется. В большинстве случаев разработчики пишут так: «Спасибо за ваш запрос, мы создадим PDF и отправим его вам на почту». Если проект небольшой, то логика при этом обычно происходит в MySQL-таблицах. Но как только встаёт вопрос масштабирования, MySQL даёт сбой — возможны блокировки, отсутствие управления очередью, медленная (по сравнению с memory-based) скорость обработки. Реляционная база данных хороша, но лучше хранить сообщения в хранилище побыстрее и более предназначенном для этого. Мы можем записать этот запрос в очередь и уже из очереди выполнять его и отправлять пользователю.

**Сообщение — это не интерпретируемая брокером единица сущности. Это может быть как просто строка, так и объект в виде JSON или любая структура, представленная в виде строки.**

Неважно, что мы туда запишем; мы можем указать тип сообщения (например application/JSON), и тогда при обработке будет легко узнать, что закладывалось в начале. Сообщение не интерпретируется, оно просто хранится.

Затем оно попадает в exchange, в точку роутинга. Задача точки роутинга — определить, в какую из очередей должно попасть сообщение.

Вместе с сообщением мы можем прислать какой-то ключ. По ключу мы можем понять, в какую из очередей (одну или несколько) должно попасть сообщение.

Соответственно, есть несколько видов точки роутинга, видов работы:

1. простейший вариант — fanout, когда сообщение попадает во все доступные очереди;
2. direct — полное совпадение ключа. Мы можем создать очередь для одного ключа, очередь для другого; у очереди может быть несколько ключей — всё как в обычном STP-роутинге;
3. topic — ключ удовлетворяет маске (#*), где * — любое непустое слово (одно), а # — то же самое, что и *, только здесь допустимо и пустое слово;
4. headers — мы имеем возможность указать какой-то тип прямо в message и роутиться по нему (используется, когда нет отдельного ключа).

![Слайд № 12](https://avatars.mds.yandex.net/get-zen_doc/1616946/pub_5e00562d1e8e3f00b0e56b24_5e00592bec575b00b17ada59/scale_1200)

Слайд № 12

Кроме того, очереди представляют собой обычную модель, в которой нет ничего сложного. Из очереди мы берём сообщение путём подключения к брокеру и запроса из очереди либо путём постоянного подключения и запроса из очереди.

## **Какие фишки подразумеваются в очереди и уже реализованы в Rabbit'е**

![Слайд № 13](https://avatars.mds.yandex.net/get-zen_doc/1707291/pub_5e00562d1e8e3f00b0e56b24_5e00594b43863f00b2460ea8/scale_1200)

Слайд № 13

### **1. Durable**

Durable — возможность сохранения состояния при перезагрузке сервера. Например, сервер «уронили» (или он «упал» сам), а очередь нужно не потерять. Для скорости работы очередь хранится в RAM (random-access memory), поэтому, чтобы обеспечить её персистентное состояние, мы должны дополнительно сохранять очередь куда-то на диск. Тут логика работы аналогична любому RAM storage типа Redis и т. п. Мы просто делаем дамп, храним его на диске, в случае «падения» поднимаем дамп с диска — и всё возвращается на круги своя (и никакие сообщения мы не потеряли, кроме периода даунтайма).

Есть несколько режимов создания дампов. Например, в версии 3.9 есть lazyload, который делает полный дамп при каждом запросе, но он значительно сажает производительность. Можно поступить проще: «подрубиться» к RabbitMQ через Redis и использовать хранилище Redis как основное.

Кроме того, нужно логировать, создавать отдельную очередь, которая бы писала всеми любимую реляционную базу данных. Best practice для high-load-проектов, когда мы держим только кеш в состоянии памяти (все новые заказы например). Одно сообщение можно отправить в несколько очередей, и одна из очередей будет использоваться для связи с реляционной базой данных и для постоянного хранения в ней — так же, как у тебя, наверно, сделано и везде с Elastic (или MySQL, или PostgreSQL, или чем-нибудь другим, что у тебя используется на backend'е). В случае с Elastic он используется как кеш и связывается с постоянным хранилищем. В случае «смерти» Elastic'а всё будет нормально, мы не потеряем данные, а вот в случае «смерти» базы данных нормально уже не будет.

### **2. TTL & expiration**

В time to live мы можем указать каждому сообщению или всем сообщениям в очереди (очереди целиком), сколько они будут жить. Например, нам поступает заказ. Мы понимаем, что через 60 минут он уже станет неактуальным (на примере биржи — через час уже значительно изменятся ставки; на примере шаурмы — ни один клиент не будет ждать шаурму час), и мы можем задать TTL, чтобы каждое сообщение, которое пролежит больше 60 минут, исчезало из очереди.

### **3. ACK — acknowledge**

Сообщения могут быть нескольких видов, и самые популярные из них два:

1. сообщение, которое нужно сразу удалить из очереди, как только оно было взято, не дожидаясь ответа от того, кто его забрал (это и есть ACK);
2. сообщение, которое не нужно удалять из очереди, пока не получен нужный ответ. Это сообщение мы помечаем и блокируем, чтобы другие не взяли его. Если нам не вернётся ответ, оно останется у нас, и другие исполнители смогут взять его.

**Кейс: актуальные варианты использования ACK.**

Например, сайт связан с каким-то сторонним сервисом, есть очередь из оплат или трек-номеров посылок. Мы берём одно сообщение, отправляем его в сторонний сервис, а он оказывается (внезапно) под высокой нагрузкой и недоступен. Если бы у нас не было блокировки, это сообщение исчезло бы из очереди, и мы бы потеряли клиента. Чтобы этого избежать, можно вернуть ответ «не получилось» или разделить таймаут по времени таким образом, чтобы, если ответ от поставщика данных задержался более чем на 15 секунд, сообщение возвращалось в очередь.

### **4. Dead lettering**

Dead lettering — когда наше сообщение вернулось с ошибкой (блек-джеком) в очередь и нам нужно обработать его не сразу, а с задержкой 5–10 секунд. Такое часто бывает, когда провайдер данных не доступен (т. е. провайдер возвращает нам ошибку, скажем, 404, 504 или что-то подобное). В этом нет ничего страшного, мы возвращаем сообщение в очередь и при возврате можем указать, через какое время этот элемент будет доступен для повторного просмотра.

В общем и целом это работает примерно таким образом.

![Слайд № 14](https://avatars.mds.yandex.net/get-zen_doc/1591747/pub_5e00562d1e8e3f00b0e56b24_5e0059d6b477bf00af3fd8d9/scale_1200)

Слайд № 14

У нас есть exchanges разных типов. Ниже представлены примеры, в каких случаях они могут быть использованы.

![Слайд № 15](https://avatars.mds.yandex.net/get-zen_doc/1708012/pub_5e00562d1e8e3f00b0e56b24_5e0059e6e6cb9b00b1819590/scale_1200)

Слайд № 15

Допустим, у нас есть разные routing keys, которые состоят из нескольких ключей, и тогда нам будут полезны разные вариации exchange. Если у нас указаны несколько ключей, например europe.weather, то это сообщение нужно поместить и в europe, и в weather. Если usa.weather — и в usa, и в weather. Таким образом, мы можем разроутить все сообщения сразу в несколько очередей.



дефолтные значения. Если достаточно дефолтного значения любого из этих параметров, то его можно опустить

 

Используя коннект можно получить объект для канала

 

На основе полученного канала создаем обменник

 

и, собственно, саму очередь

 

Когда обменник и очередь готовы, их можно связать по ключу

 

Объявлять очередь и связывать ее с обменником можно как на продюсере, так и на консьюмере

 

озможно следует объявить и там и там. При этом имена очередей должны совпадать. Если имена очередей совпадают, то количество объявлений не имеет значения.

 

сообщение не может быть опубликовано напрямую в очередь, оно должно проходить через обменник. Собственно посредством обменника оно и публикуется $result = $exchange->publish(json_encode(“Hello world!”), “foo_key”);

 После того как сообщение отослано, коннект можно разорвать.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:07](https://vk.com/im?sel=2733257&msgid=75237)

 

Получатель также должен выполнить ту же последовательность – приконнектиться к серверу сообщений; – создать канал; – объявить обменник; – объявить очередь; – связать очередь с обменником по ключу Последние два действия, как упоминалось выше, не обязательны. Теперь можно начать прослушивать очередь

 

ARMQ_AUTOACK

 

в случае неудачной обработки сообщения, вернуть повторно его в очередь нельзя.

 

Распределенные очереди

23 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:37](https://vk.com/im?sel=2733257&msgid=75243)

 

о обработать видео файл, чтобы получить на выходе три сконвертированных файла в различные форматы, информацию о метаданных и создать иконки для этого видеофайла. Т.е. получаем 5 задач

 

все эти задачи являются независимыми друг от друга. Таким образом, можно выполнять их одновременно,

 

при объявлении обменника необходимо установить ему тип AMQP_EX_TYPE_FANOUT. Тогда все сообщения, посылаемые в указанный обменник, независимо от имени очереди и ключа роутера, будут прослушиваться всеми запущенными копиями консьюмера. Т.е. каждое следующее сообщение будет отсылаться на следующий свободный консьюмер

 

round-robin dispathing.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:01](https://vk.com/im?sel=2733257&msgid=75259)

 

е оповещение было отключено путем передачи параметра AMQP_AUTOACK в метод get(). В этом случае сообщения удаляются из памяти сразу после выполнения метода get и в случае ошибки, случившейся во время обработки, не вернутся в очередь. Чтобы избежать этого, не будем передавать константу AMQP_AUTOACK в метод get. Вместо этого по завершению обработки вызовем метод ack(), который уведомит брокер о том, что сообщение успешно обработано и его можно удалить из памяти. В противном случае RabbitMQ понимает, что сообщение не обратботано и перенаправляет его другому свободному консьюмеру. О

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [13:11](https://vk.com/im?sel=2733257&msgid=75260)

 

Перенаправленные сообщения не будут обрабатываться до того пока консьюмер не отконнектится и приконнектится заново к брокеру. Если необходимо заново обработать сообщение в рамках того же коннекта к серверу сообщений, то необходимо вызвать метод nack() с флагом AMQP_REQUEUE, который поставит неудачно обработанную задачу обратно в очередь и уведомит брокер о том, что эта задача должна быть вновь обработана.

 

Распростаненная ошибка – при включенном оповещении не подтверждать корректно обработанные задачи(сообщения). В этом случае при каждом новом коннекте, все уже обработанные задачи будут поступать заново на обработку.

 

Отследить такую ситуацию можно путем использования нативного инструмента сервера сообщений rabbitmqctl

 

ь, очередь должна быть создана с флагом AMQP_DURABLE.

 

Установка флага AMQP_DURABLE не гарантирует стопроцентную сохранность сообщений в очереди

 

существует мертвая зона после получения соощения, когда оно уже в памяти, но еще не сохранено на диске. В этот момент, в случае не предвиденной ситуации, оно может быть утеряно из памяти.

 

если необходимо добиться высоких гарантий получения сообщения, то следует использовать транзакции.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [21:40](https://vk.com/im?sel=2733257&msgid=75359)

 

отсылать все сообщения из очереди на все консьюмеры. Такой шаблон известен как “публичная рассылка”(publish subscribe). Такое поведение может быть полезно, к примеру, при создании логирования с одновременным выводом сообщения в терминал. Т.е. один консьюмер получает сообщение и сохраняет его на диска, в то время как другой выводит это сообщение на экране.

 

а обменнике(exchanger). На самом деле продюсер никогда не отправляет сообщения непосредственно в очередь. Он размещает их в обменнике.

 

получает сообщения от продюсера и отправляет(публикует) их в очередь.

 

отправляет сообщение во все очереди с четко заданным именем на все консьюмеры, обрабатывающими эту очередь(direct)отправляет сообщение во все очереди и распределяет сообщение между консьюмерами, обрабатывающими очередь с одинаковым именем(fanout)отправляет сообщение во все очереди с именем, удовлетворяющим шаблону(topic)отклоняет сообщение

25 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:46](https://vk.com/im?sel=2733257&msgid=75419)

 

. Консьюмер же, в свою очередь, создает анонимную очередь, в которую принимает сообщения продюсера. При таком подходе каждый консьюмер будет принимать все сообщения продюсера.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:30](https://vk.com/im?sel=2733257&msgid=75423)

 

Если при объявлении очереди не устанавливать ей имя, то RabbitMQ сам задаст рандомное имя очереди. Для возможности автоматического удаления очереди, при ее создании нужно задать флаги AMQP_IFUNUSED, AMQP_AUTODELETE.

 

. Теперь нужно сказать обменнику, что он должен публиковать сообщения имеено в эту очередь. Это отношение называется связыванием (binding)

 

десь второй параметр – ключ, по которому связывается обменник и очередь. В данном случае он может быть любой строкой, поскольку его значение игнорируется в случае, если обменник имеет тип fanout.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [8:43](https://vk.com/im?sel=2733257&msgid=75426)

 

отсылать сообщения в четко определенные очереди. Такая возможность может понадобиться, к примеру, если мы не хотим сохранять все сообщения на диске, а только критический. В то время как на экран будут выводиться все сообщения.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:31](https://vk.com/im?sel=2733257&msgid=75430)

 

ь. В методе bind() имеется второй параметр – ключ(routingKey), по которому связывается обменник и очередь.

 

ключ напрямую зависит от типа обменника

 

– direct, который отправляет сообщения только тем очередям, routingKey которых совпадает с routingKey сообщения.

 

обменник X с типом direct, который связан с очередью Q1 по ключу failure, и с очередью Q2 по ключам notice и warning.

 

Сообщения, ключи которые не совпадают с выше указанными, будут игнорироваться всеми очередями.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [17:58](https://vk.com/im?sel=2733257&msgid=75435)

 

не возможно несколько очередей связать с обменником по одному и тому же ключу

26 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:49](https://vk.com/im?sel=2733257&msgid=75466)

 

В таком случае сообщения с ключем notice будут отсылаться на обе очереди, т.е. получаем поведение аналогичное обменнику с типом fanout.

 

Для отправки сообщений способом точка-точка обменник должен быть создан с типом direct, который сооветствует константе AMQP_EX_TYPE_DIRECT.

 

После чего возможна публикация сообщений по ключу

27 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [11:44](https://vk.com/im?sel=2733257&msgid=75555)

 

разделить обработаку логирования основываясь не только на важности сообщений, но и по устройствам, вызвавшим эту ошибку

 

AMQP_EX_TYPE_TOPIC. Ключи routingKey составляются из слова, следующих через точку, например, “logs.devices.kernel.notice”, “logs.devices.cron”. Максимальная длина такого ключа может составлять 255 символов. Логика доставки сообщений по ключу схожа с логикой для обменников с типом direct – сообщения с определенным ключем будут доставлены в очереди с соответствующим ключем.

28 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [0:55](https://vk.com/im?sel=2733257&msgid=75559)

 

. Ключи, используемые для связи по шаблону, могут содержать два специальных символа:

 \* , соответствует строго одному слову;# , соответствует любому количеству слов, в том числе и отсутствию слов;

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:33](https://vk.com/im?sel=2733257&msgid=75579)

 

Обменник с типом topic может повторять поведение обменника с типом fanout, если с ним связать очередь по ключу “#”. Если в ключе не испльзовать специальных символов, то такой обменник будет соответствовать обменнику с типом direct.

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [14:40](https://vk.com/im?sel=2733257&msgid=75580)

 

о если нам нужно получить результат от обработчика очереди. Такой подход известен как вызов удаленных процедур или RPC(remote procedure call). В

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [23:10](https://vk.com/im?sel=2733257&msgid=75588)

 

Для обработки ответа сервера, необходимо создать callback очередь. Чтобы узнать какая callback очередь ожидает ответа, мы должны в запросе послать ее имя. Для этого на продюсере создается анонимная очередь и ее имя добавляется в параметры запроса

 

callback очередь создается с флагом AMQP_EXCLUSIVE, что означает, что только один консьюмер может слушать эту очередь.

29 апреля

[     ](https://vk.com/id2733257)

[Павел](https://vk.com/id2733257) [1:11](https://vk.com/im?sel=2733257&msgid=75590)

 

В методе, представленном выше, мы предполагаем создавать callback очередь для каждого RPC запроса. Поскольку нельзя однозначно по имени очереди определить какому запросу принадлежит ответ, в запрос также добавляется параметр correlationId, который имеет уникальное значение для каждого запроса. Позже, когда мы получим ответ, мы сможем сравнить его correlationId со значением, переданным вместе с запросом.