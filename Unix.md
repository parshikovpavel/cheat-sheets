# Теория



## Блочное устройство

Блочное устройство (block device) — вид файла устройств в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, в виде файла в файловой системе.

С блочным устройством обеспечивается обмен данными блоками данных. Типичные примеры блочных устройств: жёсткий диск, CD-ROM, НГМД.

$ ls -l /dev/fd0 

brw-rw--— 1 root floppy 2, 0 Jan 1 11:17 /dev/fd0 

 

Первый символ в расширенном выводе ls (ls -l) для блочных устройств — буква b (block).

## Переменные окружения

Переменная среды, переменная окружения (*environment variable*) – текстовая переменная операционной системы, хранящая какую-либо настройку.

Каждый *process* имеет свой отдельный набор *environment variables*. При создании (через *fork*) *process* получает  дублированное окружение (*environment*) от родительского процесса. Изменение *environment variable* влияет только текущий *process* и дочерние *process*'ы.

*Environment variables* инициализируются во время запуска системы сценариями инициализации системы и, следовательно, наследуются всеми другими процессами в системе.

*Name* и *value* чувствительны к регистру символов. *Name* обычно указывается в верхнем регистре (`NAME`), использование пробелов недопустимо.

Существую неполноценные *environment variables* – переменные оболочки (*shell variables*), т.к. они применяются только к текущему сеансу, не распознаются ядром и не наследуются .

### Получение

Вывести список *environment variables*:

```bash
$ printenv
TERM_PROGRAM=Apple_Terminal
SHELL=/bin/bash
...
```

Вывести список *environment variables* + *shell variables*:

```bash
$ set
BASH=/bin/bash
BASH_ARGC=()
...
```

Получить значение конкретной *environment variables* + *shell variables*:

```bash
echo $<NAME>
echo $PATH
```

### Установка

<u>Сеансовые *variable* с помощью консоли</u>

Созданные с помощью консоли variables доступны только в текущем сеансе, т.к. они влияют только на текущий *process* и дочерние *process*'ы.

Установить значение *shell variable* в текущем сеансе

```bash
<NAME>=<value>
PATH=$PATH:.
```

Установить значение *environment variable* в текущем сеансе

```bash
export <NAME>=<value>
```

<u>Постоянные *environment variables* в файлах конфигурации</u>

Для создания постоянных *environment variables*, нужно определить эти переменные в стартовых скриптах *bash*. В этих скриптах возможна любая *bash* команда, в том числе `export` для установки *environment variables*:

```bash
export JAVA_HOME="/path/to/java/home"
export PATH=$PATH:$JAVA_HOME/bin
export PATH="$HOME/bin:$PATH"
```

Для настройки могут использоваться следующие стартовые скрипты:

- `~/.bash_profile` (в Linux `~/.bashrc`) – скрипт настроек для конкретного пользователя, который загружается каждый раз когда он входит в систему. 

- `/etc/profile`, `/etc/bashrc`, `/etc/bashrc_Apple_Terminal` – скрипты настроек для всех пользователей, которые загружаются при каждом входе в систему. Загружаются в указанном порядке.

Чаще всего постоянные *environment variables* задают в `~/.bash_profile`.

### `PATH`

Содержит список путей к каталогам, разделенных символом `:`. Используется при поиске исполняемых (*executable*) программ.

```bash
/usr:/usr/bin
```

Команды делятся на:

- встроенные (*built-in utility*) – являются частью оболочки и всегда могут быть найдены. Например, `cd`, `echo`, `kill`.
- исполняемые (*executable*) – сторонняя программа, которую *shell* должен найти.

Порядок поиска команды после ввода в *shell*:

- если *command name* не содержит ни одного `/`, то:
  - совпадает ли *command name* с одной из *built-in utility*
  - поиск *utility* в каталогах, указанных в `PATH`.   
- если *command name* содержит хотя бы один `/`, то исполнить *utility* по этому пути

Т.е. текущий каталог не проверяется и поэтому чтобы запустить *utility* в текущем каталоге необходимо использовать формат `./<command>`.

Можно добавить текущий каталог `.` в `PATH`:

```bash
PATH=$PATH:.
```

однако это не рекомендуется по соображения безопасности. Например, можно случайно вместе *built-in utility* запустить *executable utility* в текущем каталоге. 

## tar

**tar** (*tape archive*) – формат битового потока или файла архива, а также название традиционной для *Unix* программы для работы с такими архивами. Используется для хранения нескольких файлов внутри одного файла, например, для создания архива части файловой системы. 

Преимущество: в архив записывается информация о структуре каталогов, о владельце и группе отдельных файлов, а также временны́е метки файлов.

Самостоятельно не создает сжатые архивы, использует для сжатия внешние утилиты (например, gzip).

<u>Синтаксис:</u>

```
tar [-опции] <имя_архива> [файлы или папки, которые необходимо поместить в архив]
```

<u>Опции:</u>

- `-c, --create` — создать архив;
- `-a, --auto-compress` — дополнительно сжать архив с компрессором который автоматически определить по расширению архива. Если имя архива заканчивается на `*.tar.gz` то с помощью *gzip* и т.д. 
- `-x, --extract, --get` — извлечь файлы из архива;
- `-f, --file` — указать имя архива;
- `-v, --verbose` — выводить список обработанных файлов.

<u>Примеры:</u>

Создание архива `archive.tar` из файла `README.txt` и каталога `src`:

```
tar -cvf archive.tar README.txt src
```

Извлечение содержимого `archive.tar` в текущий каталог:

```
tar -xvf archive.tar
```

Создание сжатого *gzip* архива `archive.tar.gz` из файла `README.txt` и каталога `src`:

```
tar -cavf archive.tar.gz README.txt src
```

Извлечение содержимого `archive.tar.gz` в текущий каталог:

```
tar -xvf archive.tar.gz
```

## Команды

### Работа с консолью

#### echo

echo [OPTION]... [STRING]...

Вывести строку текста в stdout.

**Параметры:**

| -n   | не выводить в  конце символ новой строки                 |
| ---- | -------------------------------------------------------- |
| -e   | включить  интерпретацию управляющих символов (в т.ч. \n) |

**Примеры:**

Вывод строки с управляющим символом в stdout

$ echo -e "123\n345"

 

123

345

Отправка HTTP-запроса на yandex.ru:80

$ echo -en "GET / HTTP/1.1\r\nHost: yandex.ru\r\n\r\n" | nc yandex.ru 80

 

HTTP/1.1 302 Found

Date: Thu, 07 Jun 2018 11:50:35 GMT

...

Можно использовать для создания файла:

$ echo "string" > filename

$ cat filename

string

 

### Пакетный менеджер APT

Advanced Packaging Tool (APT) – набор утилит (apt-get, apt-cache...) для управления программными пакетами в операционных системах основанных на Debian. APT предоставляет дружественную надстройку над упаковочной системой DPKG.

Инструмент «dpkg» формирует базовый упаковочный уровень, APT предоставляет удобные интерфейсы и осуществляют обработку зависимостей. 

#### apt-get

Утилита управления пакетами: установка, обновление, удаление.

Требует привелегий суперпользователя.

##### apt-get update

Обновить информацию о пакетах, содержащихся в репозиториях.

sudo apt-get update

##### apt-get upgrade

Обновление в системе пакетов, для которых в репозитории доступны новые версии.

sudo apt-get upgrade

##### apt-get install

Установить пакет.

sudo apt-get install nginx

##### apt-get remove

Удалить пакеты без удаления его конфигурационных файлов:

sudo apt-get remove имя_пакета

##### apt-get purge

Удалить пакет вместе с его конфигурационными файлами:

sudo apt-get purge имя_пакета

Можно использовать маску с символом «*»:

sudo apt purge php7.1*

##### apt-get autoremove

Автоматическое удаления пакетов, которые были установлены как зависимости других пакетов, но сейчас больше не нужны. 

Стоит запускать после удаления пакетов через apt-get remove и apt-get purge.

sudo apt-get autoremove

Также можно указать имя пакета после команды «autoremove», чтобы удалить пакет и его зависимости.

sudo apt-get autoremove php7.1

#### apt-cache

Утилита для запроса информации в базе данных (кеше) пакетов. 

Не требует привелегий суперпользователя

##### apt-cache search

Поиск пакетов по ключевому слову:

apt-cache search ключевое_слово

#### apt-key

apt-key используется для управления списком ключей, используемых apt для аутентификации пакетов. 

##### adv

Передать дополнительные параметры в gpg. С помощью ключа -recv можно загрузить ключ из серверов ключей непосредственно в доверенный набор ключей.

sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com: 80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5

 

#### add-apt-repository

Добавление репозитория

sudo add-apt-repository ppa:ondrej/php

#### dpkg

dpkg - это пакетный менеджер для Debian систем. 

Получение списка пакетов, установленных в системе:

dpkg --list

##### Статусы пакетов

·   r – пакет был отмечен для удаления

·   c – файлы конфигурации в настоящее время присутствуют в системе

·   rc –пакет не полностью удален, файлы конфигурации все еще присутствуют.

 

### Управление сервисом service

#### service start

Старт сервиса:

**sudo service** serviceName **start**

#### service stop

Остановка сервиса:

**sudo servioe** serviceName **stop**

#### service restart

Перезапуск сервиса

**sudo service** serviceName **restart**

#### service reload

Перечитывание конфигурационных файло без перезапуска сервиса

**sudo servi****сe** serviceName **reload**

### Файловые операции

#### `ls`

`ls -l` Вывод информации из inode (куда ведет ссылка, какие права доступа, кто владелец):

```bash
$ ls -l /sphinx.conf
lrwxrwxrwx 1 root root 52 Nov  7 16:57 /sphinx.conf -> /www/sphinx_123.conf

```

`ls -a` показать скрытые файлы

`ls -I` номер *inode*

#### **mkdir**

Создание директории 

**mkdir** dir1

**Создать вложенные друг в друга папки**

**mkdir -p** /tmp/dir1/dir2

#### mv

Перемещение файла и каталога

**mv** id_dsa .ssh/

#### **ln**    

Смотреть Ссылки.

#### `chmod`

Установка прав

```bash
chmod 700 .ssh
```

Критичные файлы с настройками в домашней папке `~` должны иметь права `700` 

#### `chown`

`chown` (*change owner*) – изменяет *owner*'а и/или *group*'у для указанных файлов. 

Если указаны только *owner* или только *group*'а, то только они и изменяются, другой параметр файла не изменяется.  

```bash
chown [-R] [-v] owner[:group] file ...
```

- `-R` – рекурсивное изменение
- `-v` – *verbose*, подробный вывод. 

## Системные команды

### `open`

Открыть каталог в *Finder*.

```bash
open <dir> # явное задание каталога
open /etc
open $(<command>) # открытие каталога, который возвращается командой
open $(bundle info --path minima)
```

### `whoami`

Отображает ваш эффективный идентификатор пользователя (*effective user ID*) в виде имени.

```bash
$ whoami
pavelparshikov
```





### id

### sudo

`-u` – позволяет указать *user*, от которого идет запуск команды

```bash
sudo -u<name> <command>
sudo -upavelparshikov php ...
```

### pbcopy

Выполняет сохранение стандартного вывода в буфер обмена:

- Сохранение содержимого файла в буфер обмена:

  ```bash
  pbcopy < {file}
  ```

- Сохранение вывода программы в буфер обмена:

```
{command} | pbcopy
```



###  which 

Выполняет поиск по переменной окружения PATH и возвращает первый найденный результат, а также путь к нему:

$ which wvdial 

/usr/bin/wvdial

### uname 

информацию о системе.

[pparshikov@cup fishki6.cup.ondu.ru]$ uname

Linux

[pparshikov@cup fishki6.cup.ondu.ru]$ uname -a

Linux cup.relax.ru 2.6.32-573.7.1.el6.x86_64 #1 SMP Tue Sep 22 22:00:00 UTC 2015 x86_64 x86_64 x86_64 GNU/Linux

Для получения информации от ядра о состоянии используются файловая система **proc** и **sys**. Все поддиректории, файлы и хранящаяся в них информация генерируется ядром на лету, как только вы ее запрашиваете. 

### `ps`

Информация о процессах. 

<u>Без параметров</u>

Без параметров выдает список процессов в текущей сессии. 

```bash
$ ps
 PID TTY        TIME CMD
5364 pts/2  00:00:00 bash
5541 pts/2  00:00:00 ps
```

В выводе:

-  `PID` (*Process IDentifier*) – идентификатор процесса; 
- `PPID` (*Parent Process IDentifier*) – идентификатор родительского процесса.

<u>Получить все процессы</u>

```bash
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.4 119848  4496 ?        Ss   17:48   0:03 /sbin/init
root         2  0.0  0.0      0     0 ?        S    17:48   0:00 [kthreadd]
```

Параметры:

- `ax` – вывести все процессы.
- `u` – вывести пользователей, запустивших процесс

<u>Получить конкретный процесс</u>

```bash
$ ps -T -p 5536
  PID  SPID TTY          TIME CMD
 5536  5536 ?        00:00:00 nginx
```

Параметры:

- `-p PID` – вывести информацию о процессе
- `-T` – вывести информацию о потоках процесса.

Вывод:

- `SPID` – идентификатор потока

### top

**top –****H** вывести информацию потоках

**top –****H –****p** **PID** вывести информацию о потоках процесса

### systemctl

Рестарт процесса

systemctl restart serviceName

аналог

service serviceName restart

 

### rm

Удалить файл

\# Удалить файл
 rm ~/file.ext

 \# Удалить директорию dir вместе с файлами и поддиректориями (ключ -R)
 rm -R ~/dir

 \# Удаление без вопросов (ключ -f)
 rm -Rf ~/dir

 \# Запрос на удаление каждого файла (ключ -f)
 rm -Ri ~/dir

### kill

Послать сигнал

kill -SIGUSR1 <PID>

### ipcs

Отображает состояние всех объектов System V IPC.

------ Очереди сообщений --------

ключ  msqid   владелец права исп. байты сообщения

 

------ Сегменты совм. исп. памяти --------

ключ  shmid   владелец права байты nattch   состояние

0x00000000 753664   pavel   600    524288   2     назначение    

 

------ Массивы семафоров --------

ключ  semid   владелец права nsems   

-q: показывать только очереди сообщений 

-s: показывать только семафоры 

-m: показывать только разделяемую память

### ipcrm

Удалить объект IPC из ядра. 

ipcrm {shm|msg|sem} id

### `scp`

Утилита работает по протоколу SSH

Копирование файла из локали на сервер через *ssh*-сессию:

```bash
scp /path/to/file user@8.8.8.8:/path/to/new/location/
```

с сервера на локаль:

```bash
scp user@8.8.8.8:/path/to/file /path/to/new/location/
```

#### Опция `-r`

`-r` – рекурсивное копирование директорий

Важно: у исходной директории слеш `/` в конце не указывается, а у директории назначения обязательно указывается. Иначе директория, которая копируется, будет записана вместо той, в которую нужно скопировать.

Копирование директории из локали на сервер:

```bash
scp -r /path/to/directory user@8.8.8.8:/path/to/new/location/
```

Копирование директории с сервера на локаль:

```bash
scp user@8.8.8.8:/path/to/directory /path/to/new/location/
```



### wget

Консольная программа для загрузки файлов по сети. Поддерживает протоколы HTTP, FTP и HTTPS. Файлы можно скачивать рекурсивно по ссылкам в HTML страницах с определённой глубиной следования по ссылкам. При загрузке по ftp файлы можно скачивать «по маске» имени. Wget поддерживает докачку файла в случае обрыва соединения.

Скачать файл 

wget http://fishki.net

### top

????

Load Average

### `touch`

Используется для того, чтобы:

- Установить время последнего изменения и доступа к файлу. По умолчанию, в текущее время. 
- Создать пустой файл. Если указанный файл не существует, создает пустой файл с указанным именем и устанавливает время последнего изменения и доступа в указанной значение. По умолчанию, в текущее время. 

По умолчанию, ее использование эквивалентно созданию или открытию файла и его сохранению без каких-либо изменений в содержимом файла.

<u>Примеры</u>

Создать файл `<file>` и установить время последнего изменения и доступа в текущее время; если файл существует – обновить время последнего изменения и доступа, не изменяя при этом содержимого файла:

```bash
touch <file>
```

### find

Узначать что это такое? Меняли на фишках права на файлы.

find . -type d -exec chmod 775 \{\} \;

find . -type f -exec chmod 660 \{\} \;

### screen

Позволяет управлять несколькими сессиями из одной консоли или окна терминала. Часто используется для сворачивания в фон программ, которые сами этого не умеют, с возможностью последюущего возврата к ним. 

Преимущества:

- к одному сеансу можно подключиться из нескольких мест одновременно
- можно взаимодействовать с несколькими сессиями. 
- при потере связи по `ssh` можно вернуться в свою сессию и выполняемые в момент разрыва операции не прервутся. 

*Screen* создает отдельные объекты, называемые «скринами». Каждый скрин - это что-то вроде окна, которое можно свернуть-развернуть, если проводить аналогию с графическим интрефейсом. 

Команды:

- создание нового скрина

  ```bash
  screen
  ```

- отключиться от скрина – сочетание клавиш `Ctrl + A`, затем `D`

- список активных скринов:

  ```bash
  screen -ls
  ```

- подключиться к скрину с указанным именем

  ```bash
  screen -r <name>
  ```

  

### Фильтрация текста

#### awk

Инструмент фильтрации текста. Часто используется для выбора одного из полей, разделенных пробелами

awk '{print $2}'

#### wc

wc [OPTION]... [FILE]...

wc (сокращение от word count).

Программа считывает файл и выводит количество переводов строк \n (т.е. количество строк, 1 колонка), количество слов (2 колонка) и количество байт (3 колонка). 

$ wc test

2  4  16 test

Если указан список файлов, то выводится статистика по отдельным файлам и общая статистика.

$ wc test1.txt test2.txt 

 2 4 16 test1.txt

 3 6 37 test2.txt

 5 10 53 итого

Аналогично выводится результат, если использована маска:

$ wc *.txt

 2 4 16 test1.txt

 3 6 37 test2.txt

 5 10 53 итого

Если входной файл не задан, или равен ‘-‘, то данные считываются с stdin. В выводе команды отсутствует название файла.

$ **wc**

123

345

(Ctrl+D)

 2 2 8

 

$ echo -en '123\n345 678\n' | wc

 2  3 12

Параметры:

| -l   | вывести  количество переводов строк \n (т.е. количество строк) |
| ---- | ------------------------------------------------------------ |
| -w   | вывести  количество слов                                     |
| -c   | вывести количество байт. Может применяться к  нетекстовым файлам |
| -m   | вывести количество символов                                  |
| -L   | вывести длину самой длинной строки                           |

 

$ wc -l test1.txt

2 test1.txt

 

$ echo -en '123\n345 678\n' | wc -l

2

Примеры:

Найти количество попыток доступа с определенного IP адреса к nginx:

$ cat /logs/nginx/fishki.net_access.log | grep '171.25.171.101' | wc –l

 

17

Вывести суммарное количество строк в файлах, заданных маской:

$ cat *.txt | wc -l

5 

Вывести количество файлов в директории:

$ ls | wc -l

19

Получить размер двоичного файла:

$ wc -c 2.jpg

213418 2.jpg

 

 

#### grep

#### zgrep

Поиск строки в архиве `xxx.tar.gz`:

```bash
zgrep -a <string> file.tar.gz
```



#### sort

#### uniq

#### sed

#### head

#### xargs

#### cut

#### Задачки

Найти и сгруппировать с подсчетом количества (COUNT GROUP BY) строки в логе, в которых на запрос к странице странице .html возвращалось 404.

Здесь 401095 взято от балды, узнать как найти номер строки и выбрать строки начиная с какой-то даты.

**tail** -n 401095 /var/log/nginx/petpop.cc/nginx_access.log | grep ' 404 ' | grep '.html HTTP' | awk '{print $7}' | sort | uniq -c | sort -rn

## Файловая система

Стандарт иерархии файловой системы (*Filesystem Hierarchy Standard*) определяет структуру каталогов в Linux-системах.

Все файлы и каталоги отображаются в корневом каталоге `/` , даже если они хранятся на разных физических или виртуальных устройствах (в отличии от *Windows*, где у каждого диска есть буква диска, обозначающая корень дерева его файловой системы).

Каталоги Unix не содержат *files*. Вместо этого они содержат *file names* в паре с *inode number*. 

### inode

*inode* (*index node*, *индексный узел*, *а́йнод* или *ино́д*), индексный дескриптор — это структура данных в *Unix-style file system*. Для каждого файла в системе заводится *inode*, которая его описывает. В *inode* хранится:

- метаинформация об объекте файловой системы – принадлежность владельцу (пользователю и группе), режим доступа (чтение, запись, запуск на выполнение) и тип файла.  
- местоположение самих данных.

inode НЕ хранит сами имена файлов, 

*inode* идентифицируется по уникальному *i-number* (*i-номер*). *i-number* уникален в пределах дискового раздела.

<u>Последствия:</u>

- Каталоги Unix не содержат самих *files*. Каждый элемент *directory* это –  (*file name* + *i-number*). 

- Поиск содержимого файлов выполняется в таком порядке: *directory* **→** (*file name* + *i-number*) **→**  *inode* **→** *file location*
- один файл может иметь несколько имен – жестких ссылок (*hard link*) на *inode*, которая его описывает.
- *inode* может не иметь ни одной жесткой ссылки

### Жесткая ссылка

*Жёсткая ссылка* (*hard link*) – привязывает (*directory* + *file name*) → inode. 

<u>Особенности:</u>

- К одной *inode* может быть привязано несколько (*directory* + *file name*). Т.е. на файл может быть несколько *hard link*. В таком случае он будет доступен из разных мест файловой системы. Все *hard link* одного файла равноправны и неотличимы друг от друга, первый созданный *hard link* никаким особым положением не обладает.
- Используется подсчет жестких ссылок. Как только счетчик ссылок становится равным нулю, ОС автоматически освобождает пространство данных файла, если ни один процесс не открыл файл для доступа, 
- Создание жёсткой ссылки на файл в другом раздела невозможно, т.к. она может ссылаться по *i-number* только на *inode* в текущем разделе. Вместо этого можно сделать *symbolic link*.

<u>Создание *hard link*:</u> 

`ln <target_path> <link_path>`

Аналогом команды `rm`, является команда `unlink`, удаляющая из каталога жесткую ссылку.

### Символическая (мягкая) ссылка

Символическая (мягкая) ссылка (*symbolic link*, симлинк) – специальный файл в файловой системе, в котором вместо пользовательских данных содержится текстовая строка, которая автоматически интерпретируется и сопровождается операционной системой как путь к другому файлу или каталогу (*target*). *Symbolic link* и *target* существуют независимо. Если *symbolic link* удаляется, *target* остается неизменной. Если *target* перемещается, переименовывается или удаляется, *symbolic link* не обновляется или не удаляется автоматически, а продолжает указывать на несуществующую *target*. 

<u>Создание *symbolic link*</u>:

`ln -s <target_path> <link_path>`

Если *target* не существует, *symbolic link* всё равно будет создана.

### Основные каталоги

| Каталог                      | Описание                                                     |
| ---------------------------- | ------------------------------------------------------------ |
| `/`                          | Корень *первичной иерархии*                                  |
| `/bin`                       | Папка для исполняемых  файлов, содержит ключевые утилиты, например, `ls`, `cp`, `cat` |
| `/etc`                       | Расшифровывается *et cetera* (и так далее), т.к. содержит файлы, который не могут быть помещены в какой-то другой каталог. Содержит конфигурационные файлы системных утилит и программ (например, `/etc/nginx`). Редактирование этих файлов влечёт за собой изменения для всех пользователей системы, поэтому изменять что-либо в данном каталоге может только *root*. |
| `/home` (`/Users` в *macOS*) | Users' home directories                                      |
| `/usr`                       | Корень *вторичной иерархии* for read-only user data. Расшифровывается как Unix System Resources (системные  ресурсы Unix). В этой папке хранятся данные всех установленных пакетов  программ, т.е. большинство приложений. Управление  папкой осуществляется пакетным менеджером, который ведет учет каждого файла в  этой папке. Приложения непосредственно в `/usr` рассматриваются как часть операционной системы (в отличии от `/usr/local`) |
| `/usr/bin`                   | исполняемые  файлы                                           |
| `/usr/sbin`                  | исполняемые  файлы, которые запускаются с правами администратора |
| `/usr/lib`                   | библиотеки для  исполняемых файлов                           |
| `/usr/local`                 | Корень *третичной иерархии* для локальных (*local*) данных. По стандарту `/usr`  должен быть общим для нескольких компьютеров и смонтирован по сети, а `/usr/local`  должен содержать установленные пакеты программы только на локальной машине. В  реальности, в `/usr/local`  размещают сторонние пакеты (*third party packages)* и несистемные утилиты~~, которые не устанавливаются пакетным  менеджером.~~ |
| `/usr/local/bin`             | исполняемые  файлы сторонних программ                        |
| `/usr/local/etc`             | их конфиги                                                   |
| `/usr/local/sbin`            | исполняемые  файлы посторонних программ, которые запускаются с правами администратора |
| `/var`                       | Переменные (*variable*) файлы - файлы, содержимое которых, как ожидается, будет постоянно изменяться во время нормальной работы системы, такие как *logs*, *databases*. |
| `/var/log`                   | Лог-файлы                                                    |

### /Proc

В этой папке каждому процессу системы соответствует папка с PID.

**/PROC/VERSION** Содержит версию ядра, компилятора, и в некоторых случаях, даже дистрибутива:

[pparshikov@cup fishki6.cup.ondu.ru]$ cat /proc/version

Linux version 2.6.32-573.7.1.el6.x86_64 (mockbuild@c6b8.bsys.dev.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-16) (GCC) ) #1 SMP Tue Sep 22 22:00:00 UTC 2015



## SSH

### Типы ключей

Распространены два типа ключей:

- *DSA*. В *openssh* указаны как *deprecated*. По умолчанию их использование отключено. Их использование нужно явно разрешить в [configuration file](#configuration-file).
- *RSA*. Рекомендуются для использования.

### Генерация ключей

Генерация ключей выполняется командой:

```bash
ssh-keygen 
	-t [rsa | dsa] # тип ключа
	-b 4096        # длина ключа в битах
```

Имя сгенерированных файлов зависит от типа ключа:

- *DSA* – `id_dsa`
- *RSA* – `id_rsa`

В результате выполнения команды получаем в папке `~/.ssh` файлы:

- `id_rsa.pub` — открытый ключ
- `id_rsa` — закрытый ключ.

Открытый ключ (`id_rsa.pub`) необходимо дописать в файл `~/.ssh/authorized_keys` пользователя, которым заходят на сервер (пользователь на сервере). 

Закрытый ключ (`id_rsa`) — необходимо положить в файл (не дописать, один файл - один ключ!!!) в папке `~/.ssh` пользователя, который идёт на удалённый сервер (пользователь на клиенте). 

Для дописывания используем команду:

```bash
cat >> ~/.ssh/authorized_keys
```

Ключ нельзя «украсть», взломав сервер, т.к. он на сервере не находится. 



### Требования к правам

Требования к правам:

- права на директорию `.ssh` – `700`
- права на файлы в папке  `.ssh` (ключ и `config`) – `600`. 
- владелец и группа – сам пользователь. 
- Если кто-то кроме пользователя имеет доступ к ключу – ключ считается небезопасным и не работает.

### Configuration file

Существут 2 *configuration file*'s:

- `~/.ssh/config` – пользователь
- `/etc/ssh/ssh_config` – все пользователи

*Alias* – некоторый текстовый псевдоним, которому можно назначить параметры для подключения.

Формат файла:

```
Host *
 ForwardAgent yes            # пробросить ключ на удаленную машину
 ServerAliveInterval 300
 ServerAliveCountMax 120
 ControlMaster auto
 ControlPersist 60
 ControlPath /tmp/ssh-%r@%h:%p
 Compression yes
 PubkeyAcceptedKeyTypes=+ssh-dss  # разрешить использовать DSA ключи
 User pparshikov

Host <alias_name>
Hostname <host>

Host server1
Hostname 12.34.56.78

Host server2
Hostname abc.servers.com
```

После определения *alias*'а мы можем входить по символьному имени:

```bash
ssh server1
```

### 

### Подключение

Команда на подключение:

```bash
ssh <user>@<host>
ssh pparshikov@server.com
```

По умолчанию используются ключи:

- `~/.ssh/id_dsa`
- `~/.ssh/id_rsa`
- `~/.ssh/id_ecdsa`

Можно указать ключ по другому пути вручную:

```bash
ssh -i </path/to/key> <user>@<host>
```

Также путь к ключу можно указать в [configuration file](#configuration-file). 

### `ssh-agent`

`ssh-agent` – демон для кеширования дешифрованных ключей. 

Возможности: 

- позволяет вводить *passphrase* к ключу только один раз (при подгрузке ключа), а не при каждом логине.
- позволяет пробросить ключ на удалённую машину??? (может и без него)

Можно проверить, что `ssh-agent` запущен, через `ps`.

```bash
ps aux | grep ssh-agent
```

Необходимо добавить ключ в `ssh-agent` (если используется нестандартный путь к файлу): 

```bash
ssh-add ~/.ssh/identity
```

### *SSH*-тунель

*SSH*-туннель — это туннель, создаваемый посредством *SSH* соединения и используемый для шифрования туннелированных данных. 

<u>Приемы:</u>

Переадресовать все соединения на `[<локальный_адрес>]:<локальный_порт]` через SSH-туннель на удаленную машину, которая будет соединяться с `[удаленный_адрес]:[удаленный_порт]` от своего имени. По умолчанию `<локальный_адрес>` соответствует `127.0.0.1`.

```
ssh -L [<локальный_адрес>:]<локальный_порт>:<удаленный_адрес>:<удаленный_порт> [<пользователь>@]<сервер>
```

### Приемы

Выполнить команду на удалённом сервере и тут же закрыть соединение:

```bash
ssh user@server ls /etc/
```

Прочитать удаленный файл и передать на обработку локальному приложению:

```bash
ssh user@server cat /some/file | awk '{print $2}' | local_app
```

Записать вывод удаленной команды в локальный файл:

```bash
ssh user@server command > local_file
```

### Проверка отпечатка

Если клиент производит соединение с данным сервером впервые, то будет задан вопрос о доверии ключу сервера. 

```bash
The authenticity of host ***** can't be established.
RSA key fingerprint is *****.
Are you sure you want to continue connecting (yes/no)?
```

Возможные ответы:

- `no` – соединение закрывается. 
- `yes` – отпечаток ключа (*fingerprint*) сохраняется в файл `~/.ssh/known_hosts`. 

Если соединение с данным сервером уже устанавливалось ранее, то клиент сравнивает присланный ключ с *fingerprint* в `known_hosts`. Если ключи не совпадают, то пользователь получит предупреждение о возможной попытке взлома. 

Чтобы явно удалить старый ключ сервера (например, если ключ на сервер был перегенерирован) можно:

- удалить файл `known_hosts`

- использовать команду:

  ```bash
  ssh-keygen -R server
  ```

  При этом нужно удалить ещё и ключ IP (они хранятся раздельно):

  ```bash
  ssh-keygen -R 127.0.0.1
  ```

  

# Утилиты

## `telnet`, `netcat`

Подключение к серверу:

telnet localhost 80

nc localhost 80

## `curl`

## `top`

### `Load average`

`Load average` (LA) – среднее количество *process*'ов (thread'ов?) в *run queue*.

 *Run queue* – очередь выполнения, включает *process*'ы в состоянии `R` утилиты `ps`, использующие процессор (*using queue*), + ожидающие процессор в очереди (*waiting queue*). Каждый *process*, находящийся в *using queue* и *waiting queue*, увеличивает `Load average` на 1. Каждый завершающийся *process* уменьшает его на 1. 

В *Linux* в `Load average` также учитываются *process*'ы в состоянии `D` (uninterruptible sleep (обычно операции I/O), т.е. находящиеся в состоянии блокировки по I/O. Если сервер активно занят раздачей статики, LA может быть высоким, но при этом CPU не загружен. Необходимо смотреть на величины `b` и `wa` в `vmstat`. Таким образом, `Load average` в Linux вообще не информативен, т.к. смешивает *I/O queue* и *run queue*.

Выводятся три числа – средние значения на трех временных промежутках (одна, пять и пятнадцать минут).

Процессор (или набор ядер процессора) можно представить как мост с одной полосой (или несколькими полосами). Степень загруженности моста показывает – как много машин находятся сейчас на мосту (*using queue*) и ждут в очереди (*waiting queue*). Если *waiting queue* пуста, то машина может сразу проехать по мосту. Иначе она должна ждать своей очереди. 

<u>Одноядерный процессор</u>

Основные точки `Load avarage`:

- значения от `0.00` до `1.00` означают, что *waiting queue* пуста. Очередь отсутствует, запускаемые *process*'ы могут воспользоваться процессором без ожидания
  - `0.00` – также *using queue* пуста. На процессоре не исполняется ни одного *process*'а
  - `1.00` – *using queue* заполнена целиком. Процессор исполняется столько *process*'ов, сколько он может вместить.
- значения `>1.00` означают наличие непустой *waiting queue*.

Практически применимые точки `Load average`:

- `0.7` – загрузка CPU требует анализа
- `1.0` – необходимо разбираться немедленно, система не имеет запаса
- `5.0` – система подвисает и работает медленно.

Следует принимать во внимание на каком временном интервале повышение `Load average`. Особенно критично, если `Load average > 1.0`  на пяти- или 15-минутном интервале.

<u>Многоядерный процессор</u>

Для многоядерной системы с количеством ядер `N`  все числа необходимо доносить на `N`. Т.е. для четырехмерной системы 100% загрузка при `Load average = 4.00`. Т.е. необходимо, чтобы `Load average < N`. 

## `htop`

Продвинутый монитор процессов, написанный для Linux. Он был задуман заменить стандартную программу `top`. 

## `vmstat` 

По умолчанию, команда:

```bash
$ vmstat
```

выдают отчет о средних значениях различных счетчиков с момента запуска сервера. 

Более интересно понаблюдать за значениями в динамике. Для этого указывают в качестве аргумента интервал времени. В этом случае генерируются инкрементные отчеты, показывающие, что сервер делает в настоящий момент. Например, выводить отчет каждые пять секунд: 

```bash
$ vmstat 5 
procs —---memory--------—  —swap— —--io- -system —cpu--—--- 
r b swpd  free  buff  cache si so  bi  bo  in cs us sy id wa 
0 0 2632 25728 23176 740244  0  0 527 521  11  3 10  1 86  3 
0 0 2632 27808 23180 738248  0  0   2 430 222 66  2  0 97  0
```

В первой строке показаны средние значения за время, прошедшее с момента запуска сервера. Значения во второй строке отражают текущие показатели, а последующие строки печатаются с пятисекундным интервалом. 

Все размеры указаны в блоках, блок обычно `1 Кб` (?).

Столбцы:

- `procs`
  - `r` – значение `Load Average` ([1](#load-average))
  - `b` – количество процессов в *waiting queue* в состоянии `D` (uninterruptible sleep (обычно операции I/O), т.е. находящиеся в состоянии блокировки по I/O. 

- `memory` (можно подробней посмотреть утилитой `free`):
  - `swpd` сколько блоков выгружено на диск в *swap*
  - `free` незанятая память.
  - `buffers` – буферы в памяти – страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого. 
  - `cached` – объем памяти под файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай, если вскоре они снова потребуются.

- `swap`
  - `si` (`swap in`) – количество блоков в секунду, которое система считывает из *swap* в память
  - `so` (`swap out`) – количество блоков в секунду, которое система перемещает из памяти в *swap*. Желательно, чтобы значения в столбцах `si` и `so` оставались равными 0, но не более 10. 

- `io`
  - `bi` (`blocks in`) – количество блоков в секунду, считанных с диска;
  - `bo` (`blocks out`) – количество блоков в секунду, записанных на диск;

- `system`
  - `in` (`interrupts`) – количество прерываний в секунду;
  - `cs` (`context switches`) – количество переключений между задачами

- `cpu`
  - `us` (`user time`) – % времени CPU, занятый на выполнение "пользовательских" (не принадлежащих ядру) задач;

  - `sy` (`system time`) – % времени CPU, занятый на выполнение задач ядра (сеть, I/O задачи, прерывания и т.п.);

  - `id` (`idle`) – % времени в бездействии (ожидании задач);

  - `wa` (`io wait`) – доля времени, в течение которого процессор простаивал, ожидая завершения операции ввода-вывода на локальный диск. Чем быстрее выполняется обмен данными с диском, тем больше времени CPU будет тратиться на выполнение процессов, а не на ожидание I/O. Если значение `wa` больше 25 процентов, то можно сделать вывод, что дисковая подсистема плохо сбалансирована, либо в системе выполняется очень много дисковых операций ввода-вывода. Если бы диски могли работать быстрее (`wa` маленький) то и выполнение процессов ускорилось бы также.

    Оптимальное значение `wa` до `0.5%`. Для серверов, отдающих статику скорее всего этот параметр будет выше. Если `iowait > 10 %`, то нужно решать проблемы с I/O. 

## `iostat`

Первый жесткий диск называется `/dev/sda`.

Как и `vmstat` может запускаться с указанием интервала времени для получения инкрементальных отчетов.

<u>Без параметров выдает:</u>

```bash
$ iostat
avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           4,23    4,00    1,76    6,91    0,00   83,11

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda              21,39       553,26       239,01    1759419     760076
```

Столбцы:

- `tps` Количество операций ввода/вывода в секунду (количество переданных данных в секунду)

- `kB_read/s` и `kB_wrtn/s` Скорость чтения и записи

- `kB_read`  `kB_wrtn` Общее количество прочитанного и записанного

<u>С параметрами:</u>

- `–d` убрать использование процессора
- `-x` расширенная статистика

```bash
$ iostat -dx
Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
sda               6,05    17,00   17,34    1,29   481,19   207,56    73,93     1,24   66,60   24,89  626,82   5,11   9,52

```

Столбцы:

- `rrqm/s` и `wrqm/s` Количество сгрупированных (*merged*) запросов на чтение и запись в секунду.

- `r/s` и `w/s` Количество запросов на чтение и запись, отправленных устройству в секунду.

- `rkB/s` и `wkB/s` Количество прочитанных и записанных килобайтов в секунду

- `avgrq-sz` Размер запроса в секторах.

- `avgqu-sz` Количество запросов, стоящих в очереди к устройству.

- `await` Время выполнения запроса от начала до конца (миллисекунд), включая ожидание в очереди

- `r_await` и  `w_await` Время чтения и записи

- `svctm` Время обслуживания запроса на устройстве, т.е. без ожидания.

- `%util` Процент времени, в течении которого запросы направлялись устройству. При 100% происходит исчерпание ресурсов. 

Количество одновременно обслуживаемых запросов считается по формуле:

```
concurrency = (r/s + w/s) * (svctm/1000)
```

Для одного жесткого диска должно быть близко к 1, для RAID должен приближаться к количеству устройств.

## Контроль загруженности системы

Система с загруженным CPU:

- `vmstat`: `r` ­↑, `us`  ↑, `cs` ↑

- `iostat`: `util`<50%

Система с загруженным I/O:

- `vmstat`: `b` ­↑, `wa` ↑­

- `iostat`: `util` =100%

Интенсивный *swapping*:

- `vmstat`: `si` ↑,­ `so` ↑, `swpd` не важно

Простой машины:

- `vmstat`: `r`=0, `b`=0, `idle`=100%

## `iotop`



## `nano`

Открыть файл

```bash
[sudo] nano <file.ext>
```

Сохранить изменения – `Ctrl+X` + `Y` + `Enter`

## `gzip` и `gunzip`

`gzip` (сокращение от *GNU Zip*) — утилита сжатия и восстановления (декомпрессии) файлов. 

В соответствии с философией UNIX, `gzip` выполняет только две функции: сжатие и распаковку одного файла; упаковка нескольких файлов в один архив невозможна. При сжатии к оригинальному расширению файла добавляется суффикс `.gz`. Для упаковки нескольких файлов обычно их сначала архивируют (объединяют) в один файл утилитой `tar`, а потом этот файл сжимают с помощью `gzip`. Таким образом, сжатые архивы обычно имеют двойное расширение `.tar.gz`, либо сокращённое `.tgz`.

С другой стороны, указанная особенность даёт `gzip` возможность работать с непрерывным потоком данных, упаковывая/распаковывая их «на лету». Это широко применяется в UNIX-системах: при помощи перенаправления потоков можно работать с упакованными файлами так же легко, как и с распакованными (распаковывая их в памяти при чтении и упаковывая при записи).

### Compressing

Сжать файл `filename.ext`, удалить его из каталога и поместить в каталог вместо него `filename.ext.gz`:

```
gzip filename.ext
```

Если нужно сохранить исходный файл, то нужно сделать *pipe* вывода `gzip -c` в файл.

```
gzip -c filename.ext > anotherfile.gz
```

Также можно сжимать из стандартного ввода:

```
cat filename.ext | gzip > anotherfile.gz
```

### Decompressing

Сделать *decompressing* файла. При этом удалить файл `filename.ext.gz`, вместо него в папке разместить распакованный `filename.ext`. Можно использовать две команды:

- `gzip -d filename.ext.gz ` 

- команда `gunzip` – обертка для `gzip -d`:

  ```bash
  gunzip filename.ext.gz
  ```

Сделать *decompressing* файла и передать его на стандартный вывод. Также возможны 2 варианта:

```
gzip -cd filename.ext.gz > anotherfile
gunzip -c filename.ext.gz > anotherfile
```