## Apache

### Конфигурация

Выделяют три уровня конфигурации Apache:

- Конфигурация сервера (`/usr/local/etc/httpd/httpd.conf`).


- Конфигурация виртуального хоста (`/usr/local/etc/httpd/extra/httpd-vhosts.conf`).


- Конфигурация уровня директории (.htaccess).


Конфигурационные файлы состоят из блоков директив. 

Директивы:

| MaxClients | Максимальное  количество воркеров |
| ---------- | --------------------------------- |
|            |                                   |

### Командная строка

| httpd –t | Проверить синтаксис конфиг-файлов перед  рестартом |
| -------- | -------------------------------------------------- |
|          |                                                    |

###  Опции

#### `AllowOverride `

**Контекст**: `<Directory>` секция

Указывает, какие директивы в файле `.htaccess` могут переопределять более ранние директивы конфигурации.

Любые директивы в `.htaccess`  будут переопределять более ранние:

```apache
AllowOverride All
```

### Установка

С помощью *Homebrew*:

```bash
brew install httpd
```

Настройки в `http.conf`:

- Включить `rewrite_module`:

  ```apache
  LoadModule rewrite_module lib/httpd/modules/mod_rewrite.so
  ```

- Дописать:

  ```apache
  # Charset
  AddDefaultCharset utf-8
  
  #PHP
  LoadModule php7_module /usr/local/Cellar/php/<version>/lib/httpd/modules/libphp7.so
  ```

- Исправить:

  ```apache
  <IfModule dir_module>
      DirectoryIndex index.php index.html
  </IfModule>
  ```

- Исправить:

  ```apache
  <Directory />
      Options Indexes Includes FollowSymLinks
      AllowOverride All
      Allow from all
  </Directory>
  ```

  

- Включить:

  ```
  Include /usr/local/etc/httpd/extra/httpd-vhosts.conf
  ```

  

### Возможности

·  поддержка FastCGI, что позволяет исполнять скрипты на любом языке за пределами серверами.

·  Server Side Includes (SSI). С помощью модуля mod_include. SSI-инструкции интерпретируются только в файлах с расширением .shtml, .stm или .shtm

Для обозначения стеков ОС, веб-сервера, СУБД и языка программирования используются аббревиатуры:

·  LAMP — Linux, Apache, MySQL, PHP

·  WAMP— Windows, Apache, MySQL, PHP.

·  MAMP – MacOS, Apache, MySQL, PHP.

### Недостатки

Главный недостаток — расточительный расход ресурсов:

·  воркеры Apache потребляют довольно много оперативной памяти. 

·  большое количество потребляемой памяти уменьшает количество процессов, которые можно запустить

·  т.к. один воркер – один запрос, очень мало запросов можно обслужить

Неэффективно отдавать статику

При использовании mod_php, этот модуль встраивается в каждый процесс Apache независимо от того, обрабатывает ли он РНР-скрипт, отдает изображение или CSS-файл. При этом для отдачи изображения или CSS-файла не требуется инициализация РНР-интерпретатора. 

При использовании РНР через FastCGI потребление памяти остается все равно очень большим.

Проблема длинных соединений

Если включен режим keepalive или приходят клиенты с медленным интернетом, то:

·  открывается большое количество долговисящих соединений, 

·  исчерпывается лимит воркеров (директива MaxClients)

·  Apache отказывает в соединении новым клиентам.

### Модели мультипроцессорности

Существует множество моделей мультипроцессорности (MultiProcessing Module, MPM), популярностью пользуются три. Они обладают примерно одинаковой скоростью обработки запросов, основное отличие в потребляемой памяти:

prefork MPM

Каждый поток обрабатывается в отдельном процессе. pre – т.к. заранее запускается множество процессов (это выгодней чем запускать процессы по ходу дела), fork – т.к. на обработку каждого запроса выделяется свой процесс. Используется по умолчанию.

Каждый процесс использует изолированные от других процессов буферы. 

Плюсы:

·  Наиболее стабильный, т.к. воркеры изолированы.

Недостатки:

·  Требуется большое количество памяти, т.к. один воркер в изолированном процессе обрабатывает только один запрос. Т.е. под каждый запрос используются все буферы в полном объеме. Ресурсы расходуются быстро, т.к. требуются отдельные ресурсы каждому воркеру. При «простое» процесса и очереди из большого количества ожидающих запросов может наступить нехватка ресурсов.

worker

Сервер порождает несколько процессов, причем в каждом процессе запускается несколько потоков. Требует меньше памяти, чем prefork, но менее стабилен. 

Как правило, используется в продакшене на высоконагруженных серверах. В worker MPM могут использоваться только потокобезопасные модули (Thread Safe).

event

Используется событийная модель, похожую на ту, что применяется в nginx. Один поток может обрабатывать одновременно несколько запросов. Отлично подходит для клиентов, которые поддерживают долгие keep-alive соединения. Наиболее производительный MPM, но и наименее стабильный (находится в экспериментальной стадии разработки).

- 

## Nginx

### Преимущества

·  меньшее (по сравнению с Apache) потребление памяти

·  отсутствие завязки на медленный жесткий диск

·  может на одном воркере держать до десятков тысяч соединений (apache только 1). Это позволяет эффективно обслуживать запросы медленных клиентов и поддерживать большое количество keep-alive соединений. Изначально проектировался для поддержания огромного количества одновременных соединений (до 10 000).

·  гибкие возможности по настройке сервера. 

### Понятие reverse proxy

Обратный прокси-сервер (англ. reverse proxy) — тип прокси-сервера, который извлекает ресурсы от имени клиента от одного или нескольких серверов-бекендов . При этом для клиента это выглядит так, будто запрашиваемые ресурсы находятся непосредственно на прокси-сервере. В отличие от прямого прокси-сервера (forward proxy), который перенаправляет запросы от связанных с ним клиентов к любым серверам в Интернете и возвращает им результат, обратный прокси-сервер является посредником для ассоциированных с ним бекенд-серверов, с которым должен связаться любой клиент.

Обратный прокси сервер реализует следующие функции:

·  Выполнение функций балансировщика нагрузки между несколькими серверами.

·  Уменьшение нагрузки на основные серверы благодаря кэшированию контента.

·  Реализовывать так называемое «кормление с ложечки» – бекенд быстро отдает ответ реверс-прокси HTML ответ, а уже реверс-прокси взаимодействует с медленным клиентом и постепенно отдает ему ответ, снимая нагрузку по взаимодействию с клиентом с бекенда.

###  Установка

```bash
brew install nginx
```

### Конфигурационные файлы

Конфигурационные файлы *nginx* находятся в папке `[/usr/local]/etc/nginx`. 

Все они состоят из секций, внутри которых размещаются директивы:

```
<секция> {
	<директива> <значение>;
}
```

Директивы внутри секции завершаются обязательной точкой с запятой `;`.

Секции задают разный уровень действия директив: 

- глобальная секция (весь сервер), 
- виртуальный хост (отдельный сайт), 
- папка, 
- файл с определенным расширением и т. п.

Директивы глобальной секции помещаются в начале главного конфигурационного файла, остальные секции заключаются в фигурные скобки. 

Директива include подключает дополнительные конфигурационные файлы. Можно использовать символ * для задания маски файлов. 

Web-сервер nginx подключает главный конфигурационный файл /etc/nginx/nginx.conf, к которому при помощи директив include подключаются остальные вспомогательные конфигурационные файлы.

Основные конфигурационные файлы:

·  nginx.conf — главный конфигурационный файл, задающий настройки для всего сервера;

·  fastcgi_params — передача переменных окружения в FastCGI-приложение;

·  mime.types — MIME-типы, поддерживаемые сервером, и сопоставление их расширениям файлов;

·  sites-available/— папка, в которой хранятся конфигурационные файлы для виртуальных хостов, под каждый виртуальный хост заводится отдельный конфигурационный файл;

·  sites-enabled/— папка со ссылками на конфигурационные файлы из sites-available; к серверу подключаются лишь те конфигурационные файлы, для которых имеется ссылка в этой папке. Таким образом, можно быстро подключать и отключать виртуальные хосты путем создания или удаления ссылки в папке sites-enabled без удаления и создания новых файлов конфигурации в папке sites-available.

Общая структура главного конфигурационного файла:

user www-data;

worker_processes auto;

pid /run/nginx.pid;

 

events {

   worker_connections 768;

}

 

http {

 

   \##

   \# Basic Settings

   \##

 

   sendfile on;

   tcp_nopush on;

   tcp_nodelay on;

   keepalive_timeout 65;

   types_hash_max_size 2048;

 

   include /etc/nginx/mime.types;

   default_type application/octet-stream;

 

   \##

   \# SSL Settings

   \##

 

   ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE

   ssl_prefer_server_ciphers on;

 

   \##

   \# Logging Settings

   \##

 

   access_log /var/log/nginx/access.log;

   error_log /var/log/nginx/error.log;

 

   \##

   \# Gzip Settings

   \##

 

   gzip on;

   gzip_disable "msie6";

 

   \##

   \# Virtual Host Configs

   \##

 

   include /etc/nginx/conf.d/*.conf;

   include /etc/nginx/sites-enabled/*;

}

#### Запись единиц измерения

##### Размер данных

| **Единица измерения** | **Суффикс**        | **Пример** |
| --------------------- | ------------------ | ---------- |
| Байт                  | Без суффикса       | 1024       |
| Килобайт              | Суффиксы `k` и `K` | 8k         |
| Мегабайт              | Суффиксы `m` и `M` | `1m`       |

##### Время

| **Единица измерения** | **Суффикс** |
| --------------------- | ----------- |
| миллисекунды          | ms          |
| секунды               | s           |
| минуты                | m           |
| часы                  | h           |
| дни                   | d           |
| недели                | w           |
| месяцы, 30 дней       | M           |
| годы, 365 дней        | y           |

В одном значении можно комбинировать различные единицы, указывая их в порядке от более к менее значащим, и по желанию отделяя их пробелами. Например, “1h 30m” задаёт то же время, что и “90m” или “5400s”. Значение без суффикса задаёт секунды. Рекомендуется всегда указывать суффикс.

#### Переменные

##### Встроенные переменные

| **Переменная**       | **Описание**                                                 |
| -------------------- | ------------------------------------------------------------ |
| $arg_*name*          | Аргумент *name* в строке запроса                             |
| Sargs                | Аргументы в  строке запроса                                  |
| $binary_remote_addr  | Адрес клиента в  бинарном виде, длина значения всегда 4 байта |
| $body_bytes_sent     | Количество  байтов, переданных клиенту, без учета заголовка ответа |
| $bytes_sent          | Количество  байтов, переданных клиенту                       |
| $connection          | Порядковый  номер соединения                                 |
| $connection_requests | Текущее  количество запросов в соединении                    |
| $content_length      | Содержимое  HTTP-заголовка Content-Length                    |
| $content_type        | Содержимое  HTTP-заголовка Content-Туре                      |
| $cookie_*name*       | Содержимое cookie с именем *name*                            |
| Sdocument_root       | Содержимое  директивы root                                   |
| $document_uri        | Синоним для $uri                                             |
| $host                | Имя хоста из  строки запроса, или имя хоста из НТТР-заголовка Host,  или имя сервера, соответствующего запросу |
| Shostname            | Имя хоста                                                    |
| $http_name           | Содержимое  HTTP-заголовка *name*, полученного от  клиента; последняя часть имени переменной соответствует имени поля,  приведенного к нижнему регистру, с заменой символов тире символами  подчеркивания, например, HTTP-заголовку User-Agent  соответствует переменная $http_user_agent |
| $https               | Принимает  значение "on", если соединение работает в режиме SSL, иначе  переменная содержит пустую строку |
| $is_args             | “?”, если в  строке запроса есть аргументы, и пустая строка, если их нет |
| $limit_rate          | Значение  директивы limit_rate – ограничение скорости ответа |
| Smsec                | Время в  секундах с точностью до миллисекунд                 |
| $nginx_version       | Версия nginx                                                 |
| $pid                 | Идентификатор  (PID) рабочего процесса                       |
| $pipe                | "р",  если запрос был pipelined, иначе ’’."                  |
| $query_string        | Синоним для $args                                            |
| $realpath_root       | Абсолютный  путь, соответствующий значению директивы root для  текущего запроса, в котором все символические ссылки преобразованы в реальные  пути |
| $remote_addr         | IP-адрес  клиента                                            |
| $remote_port         | Порт клиента                                                 |
| $remote_user         | Имя  пользователя, использованное в Basic-аутентификации     |
| $request             | Первоначальная  строка запроса                               |
| $request_body        | Тело запроса                                                 |
| $request_body_file   | Имя временного  файла, в котором хранится тело запроса       |
| $request_completion  | Строка  "ОК", если запрос завершился, либо пустая строка     |
| $request_filename    | Путь к файлу  для текущего запроса, формируемый из директивы root и URI  запроса |
| $request_length      | Длина запроса  (включая строку запроса, заголовок и тело запроса) |
| 5request_method      | Метод запроса: "GET", "POST"...                              |
| Srequest_time        | Время обработки  запроса в секундах с точностью до миллисекунд; время, прошедшее с момента  чтения первых байтов от клиента до момента записи в лог после отправки  последних байтов клиенту |
| $request_uri         | Первоначальный  URI запроса целиком (с аргументами)          |
| $scheme              | Схема запроса:  "http” или "https"                           |
| $sent_http_*name*    | Содержимое  HTTP-заголовка name, отправленного сервером клиенту; последняя часть  имени переменной соответствует имени поля, приведенного к нижнему регистру, с  заменой символов тире символами подчеркивания |
| $server_addr         | IP-адрес сервера,  принявшего запрос                         |
| $server_name         | Имя сервера,  принявшего запрос                              |
| $server_port         | Порт сервера,  принявшего запрос                             |
| $server_protocol     | Версия HTTP  протокола запроса, например "НТТР/1.1"          |
| $status              | Код НТТР-ответа                                              |
| $time_iso8601        | Локальное время  в формате по стандарту ISO 8601             |
| $time_local          | Локальное время  в Common Log Format                         |
| $uri                 | Текущий URI  запроса в нормализованном виде; значение $uri может  изменяться в процессе обработки запроса, например, при внутренних  перенаправлениях или при использовании индексных файлов |

##### Пользовательские переменные

Объявляются командой set (подробнее set)

#### Иерархия секций

Общий алгоритм подбора правил: сначала для запроса подбираются правила из более узкой секции, как правило, location, и двигаясь к более общим

Порядок применения:

\1.      Секция location – отвечает за папки и файлы в рамках виртуального хоста 

\2.      Секция server – отвечает за виртуальный хост 

\3.      Секция http и глобальная секция влияют на весь сервер в целом

#### Секции

##### Глобальная секция

| **Директива**                         | **Описание**                                                 |
| ------------------------------------- | ------------------------------------------------------------ |
| **user** пользователь  [группа]       | Пользователь и группа, от имени которых запускаются  процессы nginx. В Ubuntu для этих целей используется пользователь www-data и  группа www-data В том случае, когда имя пользователя и группы совпадают,  можно указать лишь имя пользователя www-data |
| **worker_processes**  (число \| auto) | Количество рабочих процессов, обрабатывающих  соединения со стороны клиента. Если нагрузка в основном приходится на  процессор, директиве следует выставить значение, равное количеству ядер  процессора. Если нагрузка преимущественно приходится на жесткий диск,  директиве следует выставить значение, равное удвоенному количеству ядер  процессора |
| **pid** путь                          | Путь к файлу, в котором хранится идентификатор  главного процесса nginx |
| **worker_connections**                | Директива задает максимальное количество соединений  для рабочего процесса |

##### Секция events

Определяет директивы, влияющие на обработку соединений.

| **Директива**          | **Описание**                                                 |
| ---------------------- | ------------------------------------------------------------ |
| **worker_connections** | Директива задает максимальное количество соединений  для рабочего процесса |

Максимальное количество одновременно обрабатываемых соединений равно worker_processes*стрworker_connections.

##### Секция http

Определяет параметры HTTP-протокола. 

| **Директива**                    | Умолчание | **Описание**                                                 |
| -------------------------------- | --------- | ------------------------------------------------------------ |
| `client_max_body_size`           | `1m`      | Максимальный  размер тела запроса клиента. В случае превышения nginx выдает HTTP-код ответа  "413 Request Entity Too Large". Для загрузки файлов требуется увеличить. Для *developer* лучше поставить `0` – проверка размера отключена. |
| **default_type** mimeType        |           | MIME-тип no  умолчанию, если сервер не может определить его, используя секцию type |
| **keepalive_requests** число     |           | Задаёт  максимальное число запросов, которые можно сделать по одному keep-alive  соединению. После этого соединение закрывается. |
| **keepa****live_timeout** время  |           | Cколько времени соединение  типа keep-alive  может оставаться открытым |
| **aio**                          |           | Разрешает  использование асинхронного файлового ввода/вывода. Доступно во всех  современных UNIX-подобных операционных системах |
| **sendfile** (on \| off)         |           | Включает  использование системного вызова sendfile, что позволяет отправить данные в  сеть, минуя этап их копирования в адресное пространство приложения, что существенно  повышает производительность |
| **gzip** (on \| off)             |           | Разрешает  сжатие ответа методом gzip                        |
| **limit_rate**                   |           | Ограничивает  скорость передачи ответа клиенту в байтах в секунду, значение 0 отключает ограничение  скорости |
| **tcp_****nodelay** (on  \| off) |           | Разрешает  использование параметра TCP_NODELAY для соединения типа keep-alive |
| **tcp_nopush** (on \| off)       |           | Разрешает nginx  отправлять HTTP-заголовки одним пакетом, а также передавать файл полными  пакетами |

###### Директива types

**types** {

   mimeType ext ...

   ...

}

Задаёт соответствие расширений имён файлов и MIME-типов ответов. Таблица соответствий находится в отдельном файле mime.types.

types {

  text/html               html htm shtml;

  text/css               css;

  image/gif               gif;

  image/jpeg              jpeg jpg;

  application/javascript        js;

  ...

}

Файл mime.types подключается с помощью директивы include в главном конфигурационном файле. MIME-тип по умолчанию назначается директивой defauit type:

**include** /etc/nginx/mime.types;

**default_type** application/octet-stream;

##### Секция server (виртуальные хосты)

Отвечает за управление виртуальным хостом.

Типичная структура секции server:

server {

   listen 80;

   root /var/www/example.com/www;

   access_log /var/www/example.com/log/access.log;

   error_log /var/www/example.com/log/error.log;

 

   index index.html;

 

   error_page 404 /404.html; 

   error_page 500 /500.html;

 

   server_name example.com www.example.com; 

 

   client_max_body_size 32m;

}

Файл виртуального хоста размещается в папке /etc/nginx/sites-avaiiable/. Для того чтобы активировать конфигурационный файл, в папке /etc/nginx/sites-enabled/ необходимо создать символическую ссылку с помощью команды ln –s (подробнее Ссылки). 

Основные директивы:

###### listen

**listen** адрес[:порт] [default_server]

Задаёт адрес и порт для IP или путь для UNIX-сокета, на которых сервер будет принимать запросы. Можно указать адрес и порт, либо только адрес или только порт.

**listen** 127.0.0.1:80;

**listen** 127.0.0.1;

**listen** 80;

**listen** *:80;

**listen** localhost:80;

IPv6-адреса задаются в квадратных скобках:

**listen** [::]:8000;

**listen** [::1];

UNIX-сокеты задаются при помощи префикса “unix:”:

**listen** unix:/var/run/nginx.sock;

Если указан только адрес, то используется порт 80.

Виртхост с параметром default_server выбирается по умолчанию для указанной пары адрес:порт. 

###### server_name

**server_name** имя ...;

Задаёт доменные имена, относящиеся к текущему виртуальному хосту

**server_name** example.com www.example.com;

В именах серверов можно использовать звёздочку (“*”) для замены первой или последней части имени:

**server_name** example.com *.example.com www.example.*;

В качестве шаблона можно использовать регулярные выражения, для этого перед именем следует указать знак тильды

**server_name** www.example.com ~^www\d+\.example\.com$;

###### root

```nginx
root путь;
```

Задаёт корневой каталог для запросов. Например, для

```nginx
root /data/w3;
```

в ответ на запрос `/i/top.gif` будет отдан файл `/data/w3/i/top.gif`. Путь к файлу формируется путём простого добавления URI к значению директивы `root`.

Homebrew по умолчанию указывает директиву:

```nginx
root   html;
```

Здесь `html` – это *symlink*:

```
/usr/local/Cellar/nginx/<version>/html -> /usr/local/var/www
```







###### error_page

**Синтаксис****:** **error_page** `код` ... [`=`[`ответ`]] `uri`;

Задаёт URI, который будет показываться при передаче определенного HTTP-кода состояния. 

error_page 404       /404.html;

error_page 500 502 503 504 /50x.html;

При этом делается внутреннее перенаправление на указанный uri, а метод запроса клиента меняется на GET.

Если при внутреннем перенаправлении обработка передается на проксированный сервер или FastCGI-сервер, и этот сервер может вернуть разные коды ответов, например, 200, 302, 401 или 404, то можно выдавать возвращаемый им код:

error_page 404 = /404.php;

Можно передать обработку ошибки в именованный location:

location / {

  error_page 404 = @fallback;

}

 

location @fallback {

  proxy_pass http://backend;

}

##### Секция location (местоположение)

Синтаксис: **location** `[ = | ~ | ~* | ^~] uri { ... }`
      **location** `@``имя`` { ... }`
 Контекст: server, location

###### Location по URI запроса

Секция location позволяют применять директивы в зависимости от URI запроса. Это дает возможность изменять поведение в отдельных папках, файлах, файлах с определенным расширением. Например, файлы изображений можно отдавать как есть и кэшировать на длительное время, в то время как файлы с расширением РНР можно выполнять каждый раз, не кэшируя результат.

Cекция location может быть расположена либо на уровне виртуального хоста, либо вложена в другую секцию location. 

Описание модификаторов:

| **=**         | Точное  совпадение строки locationURI и URI запроса.  Самый высокий приоритет |
| ------------- | ------------------------------------------------------------ |
| **(****нет)** | Префиксный location. Строка locationURI будет сравниваться с началом URI запроса |
| **^~**        | Приоритетный  префиксный location. Как  и в предыдущем, строка locationURI будет  сравниваться с началом URI запроса. Однако  наличие этого модификатора повышает приоритет location над регулярными location. |
| **~**         | Сопоставление с  регулярным выражением с учетом регистра     |
| **~\***       | Сопоставление с  регулярным выражением без учета регистра    |

Примеры:

Для ускорения поиска при большом количестве запросов на корневой URI /

location = / {

   ...

}

Базовый location. Совпадает с URI всех запросов, но если будут найдены более точные соответствия, то будут использованы они:

location / {

   ...

}

Проксирование статики:

location ~* \.(jpeg|jpg|gif|png|css|js|mkv|iso|avi|mp4|swf)$ {

   root /www/new.fishki.net/htdocs;

   expires 1w;

   access_log off;

}

Проксирование на Apache:

server {

   listen 80;

   server_name fishki.net;

 

   proxy_set_header Host $host;

   proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

   proxy_set_header X-Forwarded-Proto $scheme;

   proxy_set_header X-Real-IP $remote_addr;

 

   location / {

​    proxy_pass http://dynamic;

  }

}

###### Именованный location

Префикс @ перед секцией location определяет именованное местоположение. Попасть в секцию location@ можно только в результате внутреннего перенаправления. 

Ниже записан пример  проксирования запросов к файлам с расширением php на сервис PHP-FMP, расположенный на локальной машине на 9000-м порту. Директива try_file проверяет наличие файла по пути $uri, затем пытается найти папку $uri/, иначе делает внутреннее перенаправление на именованное местоположение @php.

location ~* \.phpS {

   try_file $uri $uri/ @php;

}

 

location @php {

   fastcgi_pass http://localhost:9000; 

   include fastcgi_params; 

   fastcgi_index index.php;

)

### Директивы

#### Все остальные модули

##### index

Синтаксис: **index** файл ...;
 Контекст: http, server, location

Определяет имена файлов индексных файлов, которые будет «отдавать» клиентам, если был запрошен доступ к каталогу. Наличие файлов проверяется в порядке их перечисления.

Если был запрошен доступ к каталогу и индексный файл был найден, то производится внутреннее перенаправление и блок location для обработки запроса выбирается заново, с учетом присоединенного к запросу имени индексного файла.

Пусть обрабатывается запрос /exact.  Первый location совпадает с URI запроса, но директива index, унаследованная блоком, инициирует внутреннее перенаправление ко второму блоку, где запрос будет фактически обработан, как /exact/index.html:

**index** index.html;

**location** = /exact {

   ...

}

**location** / {

   ... # Запрос будет обработан здесь как /exact/index.html
 }

##### try_files

Синтаксис: **try_files**` `файл ... uri`;```

`      `**try_files**` `файл ... =код`;```

`Контекст:`` `server, location``

Проверяет существование файлов в заданном порядке и использует для обработки запроса первый найденный файл, причём обработка делается в контексте этого же location’а. Путь к файлу строится из параметра файл в соответствии с директивами root (смотреть root) и alias. С помощью слэша в конце имени можно проверить существование каталога, например, “$uri/”. В случае, если ни один файл не найден, то делается внутреннее перенаправление на uri, заданный последним параметром. Например:

location /images/ {

  try_files $uri /images/default.gif;

}

Последний параметр может также указывать на именованный location@. Может использоваться:

·   для проксирования на бекенд, как здесь Секция location (местоположение)). 

·  для генерации TN, т.е. проверка существования файла, а если его нет, то проксирование на бекенд:

location ~* \.(jpg|gif|png)$ {

   try_files $uri @gen;

}

 

location @gen {

   proxy_pass http://127.0.0.1:81/tn$request_uri;

}

Последний параметр может также быть кодом:

location / {

   try_files $uri =404;

}

##### map

Создаёт новую переменную, значение которой зависит от значений одной или более исходных переменных, указанных в первом параметре.

map $arg_one $var_two { 

   "one" "two"; 

   "three" "four"; 

}

то же самое что

if **($arg_one =** "one"**) {** 

   set $var_two "two"; 

} 

if ($arg_one = "three") { 

   set $var_two "four"; 

}

##### charset

Синтаксис: charset кодировка | off;

Контекст: http, server, location, if в location

Добавляет указанную кодировку в поле “Content-Type” заголовка ответа. 

##### ssi

Синтаксис: ssi on | off;

Умолчание: ssi off

Контекст: http, server, location, if в location

Разрешает обработку команд SSI в проходящих через nginx ответах. 

##### add_header

Синтаксис: add_header имя значение [always];

Контекст: http, server, location, if в location

Добавляет указанное поле в заголовок ответа при условии, что код ответа равен 2XX, 3XX. Директив add_header может быть несколько.

#### Модуль логирования

В MacOS псевдоним `logs` = папка `/usr/local/var/log/nginx`.

##### `error_log`

<u>Синтаксис</u>: `error_log <файл> [<уровень>];`

<u>Умолчание</u>: `error_log logs/error.log error;`. Для MacOS соответственно `error_log /usr/local/var/log/nginx/error.log error;`

<u>Контекст</u>: `main`, `http`, `server`, `location`

Указывает куда пишутся сообщения об ошибках. Может использовать несколько

Параметры:

- `<файл>` – файл, для хранения лога. 
- `<уровень>` – уровень лога. Возможные значения: `debug`, `info`, `notice`, `warn`, `error`, `crit`, `alert` или `emerg`. Уровни лога перечислены в порядке возрастания важности. При установке определённого уровня в лог попадают все сообщения указанного уровня и уровней большей важности.

Если директивы указана на уровне `http` и на уровне `server`, то в глобальный журнальный файл помещаются ошибки только уровня сервера (например, проблемы с запуском виртуального хоста), а проблемы на уровне виртуального хоста, например, то что не интерпретируются файлы РНР,  пишутся в журнальный файл конкретного виртуального хоста.

Если на уровне конфигурации `main` запись лога в файл явно не задана, то используется <u>умолчание</u> (как написано выше).

###### Отладочный режим

Для отладки полного жизненного цикла необходимо использовать `error_log` с уровнем `debug`:

```nginx
error_log /path/to/log debug;
```

В него помещаются:

- Запрос к *nginx*:

  ```nginx
  2020/04/05 14:46:19 [debug] 1410#0: *1 http header: "Host: fishki.pp"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http header: "Connection: keep-alive"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http header: "Pragma: no-cache"
  ```

- шаги подбора URL-паттерна из `location` и выбор подходящего:

  ```nginx
  2020/04/05 14:46:19 [debug] 1410#0: *1 test location: "/"
  2020/04/05 14:46:19 [debug] 1410#0: *1 test location: ~ ".(jpeg|jpg|webm)$"
  2020/04/05 14:46:19 [debug] 1410#0: *1 using configuration "/"
  ```

- запрос к `http_proxy`:

  ```nginx
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header: "Pragma: no-cache"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header: "Cache-Control: no-cache"
  ....
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header:
  "OPTIONS /editor/upload/ HTTP/1.0
  X-URI: /editor/upload/
  X-Forwarded-For: 127.0.0.1
  Host: fishki.pp
  ....
  ```

- ответ от `http_proxy`:

  ```nginx
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy status 200 "200 OK"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header: "Date: Sun, 05 Apr 2020 11:46:19 GMT"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header: "Server: Apache/2.4.41 (Unix) PHP/7.4.2"
  2020/04/05 14:46:19 [debug] 1410#0: *1 http proxy header: "X-Powered-By: PHP/7.4.2"
  
  ```

- ответ самого *nginx*:

  ```nginx
  2020/04/05 14:46:19 [debug] 1410#0: *1 HTTP/1.1 200 OK
  Server: nginx/1.17.9
  Date: Sun, 05 Apr 2020 11:46:19 GMT
  Content-Type: text/html; charset=UTF-8
  Content-Length: 0
  Connection: keep-alive
  
  ```

  





##### `access_log`

Синтаксис: `access_log <путь> [<формат>]`

Умолчание: `access_log logs/access.log combined;`

Контекст: `http`, `server`, `location`, `if` в `location`

Лог для всех обращений (не только ошибочных). Каждая строка в файле соответствует одному обращению. Если формат не указан, то используется предопределённый формат “combined”.

Если на уровне конфигурации `main` запись лога в файл явно не задана, то используется <u>умолчание</u> (как написано выше) ???

Пример:

**access_log** /var/log/nginx/access.log combined;

###### log_format

Синтаксис: **log****_format** названиеФормата строка;

Контекст: http

Задает формат строки в access_log. В параметрах указывается название формата и строка с самим форматом. Использование директивы допускается только на уровне секции http, однако формат с указанным названием может испольховаться в качестве параметра директивы access_log на уровне виртуальных хостов.

По умолчанию формат:

**log_format** combined '$remote_addr - $remote_user [$time_local] "$request" $status $body_bytes_sent "$http_referer" "$http_user_agent"';

В строке форматирования используются серверные переменные (подробнее Переменные).

#### Модуль upstream

Синтаксис: **upstream** название { ... }

Контекст: http

Описывает группу серверов, которые могут слушать на TCP- и UNIX-сокетах, разных портах. 

Эта группа может быть использована в директивах [proxy_pass](http://nginx.org/ru/docs/http/ngx_http_proxy_module.html#proxy_pass), [fastcgi_pass](http://nginx.org/ru/docs/http/ngx_http_fastcgi_module.html#fastcgi_pass), [memcached_pass](http://nginx.org/ru/docs/http/ngx_http_memcached_module.html#memcached_pass).

Пример:

upstream backend {

  server backend1.example.com weight=5;

  server 127.0.0.1:8080    max_fails=3 fail_timeout=30s;

  server unix:/tmp/backend3;

 

  keepalive 16;

}

 

server {

  location / {

​    proxy_pass http://backend;

  }

}

По умолчанию запросы распределяются по серверам циклически (в режиме round-robin) с учётом весов серверов. В вышеприведённом примере каждые 7 запросов будут распределены так: 5 запросов на backend1.example.com и по одному запросу на второй и третий серверы. Если при попытке работы с сервером происходит ошибка, то запрос передаётся следующему серверу, и так далее до тех пор, пока не будут опробованы все работающие серверы. Если не удастся получить успешный ответ ни от одного из серверов, то клиенту будет возвращён результат работы с последним сервером.

Подробней про балансировку нагрузки Методы балансировки.

##### server

Синтаксис: **server**` ``адрес`` ``[параметры];`

Контекст: `upstream`

Задаёт адрес и другие параметры сервера. 

Возможные параметры:

```
weight`=`число
```

Задаёт вес сервера, по умолчанию 1.

max_conns=число

максимальное число одновременных активных соединений к проксируемому серверу. Значение по умолчанию равно 0 и означает, что ограничения нет. 

```
max``_``fails`=`число
```

число неудачных попыток работы с сервером, которые должны произойти в течение времени, заданного параметром fail_timeout, чтобы сервер считался недоступным на период времени, также заданный параметром fail_timeout. По умолчанию число попыток устанавливается равным 1. Нулевое значение отключает учёт попыток. 

fail_timeout=время

задаёт 

·  время, в течение которого должно произойти заданное число неудачных попыток работы с сервером для того, чтобы сервер считался недоступным; 

·  и время, в течение которого сервер будет считаться недоступным.

По умолчанию параметр равен 10 секундам.

```
slow``_``start`=`время
```

задаёт время, в течение которого вес сервера восстановится от нуля до своего номинального значения в ситуации, когда неработоспособный сервер вновь становится работоспособным.

 

##### keepalive

Синтаксис: **keepalive** соединения;

Контекст: `upstream`

Задействует кэш соединений для группы серверов. 

Параметр соединения устанавливает максимальное число неактивных постоянных соединений с серверами группы, которые будут сохраняться в кэше каждого рабочего процесса. При превышении этого числа наиболее давно не используемые соединения закрываются.

#### Модуль fastcgi

Позволяет передавать запросы FastCGI-серверу.

##### fastcgi_pass

Синтаксис: fastcgi_pass` ``адрес;`

```
Контекст: ``location
```

Задаёт адрес FastCGI-сервера. Адрес может быть указан в виде доменного имени или IP-адреса, и порта:

fastcgi_pass localhost:9000;

или в виде UNIX-сокета:

fastcgi_pass unix:/tmp/fastcgi.socket;

Также адрес может быть группой серверов (upstream).

##### fastcgi_index

Синтаксис: fastcgi_index имя;

Контекст: http, server, location

Имя файла, который будет добавлен после URI в переменную $fastcgi_script_name, если URI заканчивается слэшом. Например, при таких настройках

fastcgi_index index.php;

fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;

и запросе “/page.php” параметр SCRIPT_FILENAME будет равен “/home/www/scripts/php/page.php”, а при запросе “/info/” - “/home/www/scripts/php/info/index.php”.

##### fastcgi_param

Синтаксис: fastcgi_param параметр значение [if_not_empty];

Контекст: http, server, location

Задаёт параметр, который будет передаваться FastCGI-серверу. 

Минимально необходимые для PHP:

fastcgi_param SCRIPT_FILENAME /home/www/scripts/php$fastcgi_script_name;

fastcgi_param QUERY_STRING  $query_string;

Параметр SCRIPT_FILENAME используется в PHP для определения имени скрипта, а в параметре QUERY_STRING передаются параметры запроса.

Если директива указана с if_not_empty, то такой параметр с пустым значением передаваться на сервер не будет.

##### Переменная $fastcgi_script_name

Содержит URI запроса или же, если URI заканчивается слэшом, то URI запроса, дополненное именем индексного файла, задаваемого директивой fastcgi_index. 

##### Кеширование ответов fastcgi в nginx

В модуле fastcgi есть группа директив fastcgi_cache_* для кеширования ответов FastCGI-сервера в nginx. При использовании связки nginx+apache+mod_php и директивы proxy_pass, для кеширования нужно использовать группу директив proxy_cache_*.

###### **fastcgi_cache_path**

Синтаксис: fastcgi_cache_path путь [levels=уровни] keys_zone=имя:размер``

`Контекст: `http

Задаёт путь и другие параметры кэша. Данные кэша хранятся в файлах. Ключом и именем файла в кэше является результат функции MD5 от проксированного URL. Параметр levels задаёт уровни иерархии кэша: можно задать от 1 до 3 уровней, на каждом уровне допускаются значения 1 или 2. Например, при использовании

fastcgi_cache_path /data/nginx/cache levels=1:2 keys_zone=one:10m;

имена файлов в кэше будут такого вида:

/data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c

Кроме того, все активные ключи и информация о данных хранятся в зоне разделяемой памяти, *имя* и *размер* которой задаются параметром keys_zone. Зоны размером в 1 мегабайт достаточно для хранения около 8 тысяч ключей.

###### fastcgi_cache

Синтаксис: fastcgi_cache *зона* | off;``

`Контекст: `http, server, location

Включает кеширование и задаёт зону разделяемой памяти, используемой для кэширования. Одна и та же зона может использоваться в нескольких местах. Параметр off запрещает кэширование, унаследованное с предыдущего уровня конфигурации.

###### fastcgi_cache_valid

Синтаксис: fastcgi_cache_valid [код ...] время;``

`Контекст: `http, server, location

Задаёт код, ответы с которыми кэшируются, и время кэширования для разных кодов ответа. Например, директивы

fastcgi_cache_valid 200 302 10m;

fastcgi_cache_valid 404   1m;

задают время кэширования 10 минут для ответов с кодами 200 и 302 и 1 минуту для ответов с кодом 404.

Если указано только время кэширования и не указан ни один код, то кэшируются только ответы 200, 301 и 302.

###### fastcgi_cache_key

Синтаксис: fastcgi_cache_key строка;``

`Контекст: `http, server, location

Задаёт ключ для кэширования, например, ниже в качестве ключа используется строка с названием хоста "localhost:9000" и URI запроса:

fastcgi_cache_key localhost:9000$request_uri;

###### fastcgi_hide_header

Синтаксис: fastcgi_hide_header строка;``

`Контекст: `http, server, location

Указывает заголовки, которые не передаются клиенту из ответа FastCGI сервера. 

###### fastcgi_ignore_headers

Синтаксис: fastcgi_ignore_headers *поле* ...;``

`Контекст: `http, server, location

Не учитывает при обработке указанные заголовки из ответа FastCGI-сервера. Например, можно отключить обработку заголовокв “Expires”, “Cache-Control”, “Set-Cookie” и “Vary”, которые задают параметры кэшированияответа.

###### Пример конфигурации

Пример кеширования главной страницы на 5 минут:

\# Указываем папку для кеша, отключаем разбиение по папкам, указываем название зоны

fastcgi_cache_path /var/cache/nginx levels= keys_zone=wholepage:50m;

...

server {

 ...

 location / {

  ...

  fastcgi_pass 127.0.0.1:9000;

  ...

  \# Включаем кэширование, указываем название зоны

  fastcgi_cache wholepage;

  

  \# Кешируем ответы, с указанными кодами

  \# В том числе с 304 Not Modified –с пустым телом, если страница не изменилась

  fastcgi_cache_valid 200 301 302 304 5m;

  

  \# Ключ кеширования. Включает метод запроса (например, ответы GET и HEAD отличаются), содержание заголовком кеширования, хост, URI запроса

  fastcgi_cache_key "$request_method|$http_if_modified_since|$http_if_none_match|$host|$request_uri";

 

  \# Отключаем выдачу заголовка на устновку сессионной куки из кеша для главной страницы, чтобы пользователю не была отдана кука другого пользователя из кеша 

  fastcgi_hide_header "Set-Cookie";

 

  \# Заставляем кэшировать страницу в любом случае, независимо от

  \# заголовков кэширования, выставляемых в PHP.

  fastcgi_ignore_headers "Cache-Control" "Expires";

 }

}

Также существует продвинутый вариант кеширования нескольких вариантов страницы со случайной отдачей одного из них. Для этого директивой perl_set генерируем случайной число в переменную $rand, эту переменную вставляем в ключ через fastcgi_cache_key.

perl_set $rand 'sub { return int rand 10 }';

fastcgi_cache_key "$rand|$request_method|...";

Также, если необходимо иметь несколько вариантов страницы и разным пользователям показывать разные варианты из кеша (например, разные страницы мужчинам и женщинам), то можно польователям поставить куку 'gender' и включить эту куку в ключ кеширования:

fastcgi_cache_key "**$cookie_gender**|$request_method|...";

Если в статической закэшированной странице присутствует динамический блок можно использовать модуль SSI. В статическую закешированную страницу нужно вставить команду:

 <!--#include virtual="/get_dynamic_block/" —> 

 

 

 

#### Модуль rewrite

##### set

Синтаксис: set $переменная значение;

Контекст: server, location, if

Устанавливает значение указанной переменной. 

Пример объявления переменной для хранения корневой директории:

set $www_root "/data/myserver/root";

...

location /i/ {
   root $www_root/static/;
 }

##### return

Синтаксис:   return` код [текст];`

​       return` код URL;`

​       return` URL;`

Контекст: server, location, if

Завершает обработку и возвращает клиенту указанный код. 

После кода может быть указан URL перенаправления (для кодов 301, 302, 303, 307 и 308) или текст` `тела ответа (для остальных кодов). Кроме того, в качестве единственного параметра можно указать URL для временного перенаправления с кодом 302.

#### Методы балансировки

Поддерживаются следующие методы балансировки:

·  round-robin

·  least_conn

·  ip_hash

·  hash

·   least_time

·  stiky

Разработчики Nginx считают наиболее оптимальными методы least_conn и least_time.

Если метод балансировки не указан, то испольуется Round robin. Для остальных методов балансировки необходимо указать соответствующую директиву (hash, ip_hash, least_conn, least_time) вначале блока upstream.

upstream backend {

   ip_hash;

   ...

}

Балансировка может выполняться по любым протоколам, которые можно использовать для проксирования запросов (HTTP, HTTPS, FastCGI, memcached)

##### Round-robin

Данный метод используется по-умолчанию, никаких директив в блоке upstream указывать не нужно. Запросы распределяются между серверами группы равномерно. 

Для этого алгоритма особенно важно правильное указание веса сервера (по-умолчанию вес равен 1). Если веса не будут указаны, то на каждый бекенд отправляется одинаковое количество запросов, это приведет к том, что менее мощный сервер будет перегружен, а более мощный - частично бездействовать.

Учитывается 

Имеет смысл применять если:

·  Все сервера одинаковой мощности. Либо различия между серверами точно представлены server weights.

·  На всех серверах размещен один и тот же контент.

·  Все запросы примерно одинаковы по сложности обработки.

Недостаток:

·  все сервера обрабатывают одни и те же данные, поэтому вынуждены хранить большой ассортимент данных в кеше. Разные сервера хранят в кеше одни и те же данные.

##### Hash 

Синтаксис: hash ключ [consistent];

Контекст: upstream

При помощи этого метода можно создать своего рода постоянные соединения между данным типом клиентского запроса (тип определяется хеш-значением ключа) и бэкендом. Как будто сохраняется сессия – все запросы с заданным хэш-значением всегда идут на один и тот же сервер.

В качестве ключа может использоваться текст, переменные и их комбинации. По умолчанию, изменение серверов в группе приводит к перераспределению большинства ключей на другие серверы. Если задан параметр consistent, то вместо вышеописанного метода будет использоваться метод консистентного хэширования [ketama](http://www.last.fm/user/RJ/journal/2007/04/10/392555/).

Имеет смысл использовать, когда преимущество поддержания сессий перевешивает возможные негативные последствия несбалансированной нагрузки.

Недостатки:

·  не гарантирует равномерное распределение запросов по бекендам и соответственно равномерное распределение нагрузки.

Примеры использования:

IP адрес на один бекенд

Если требуется, чтобы клиент с одним IP адресом направлялся на один бэкенд можно использовать hash с переменной $remote_addr:

hash $remote_addr;

URI на один бекенд

Если требуется, чтобы запрос на определенный URL-адрес направлялся на один и тот же сервер, необходимо использовать hash с переменной $request_uri 

hash $request_uri;

Это удобно для кеширования различных результатов промежуточной обработки и страницы целиком. Т.к. в этом случае закешированные данные хранятся только на одном сервере, а не на всем пуле из upstream. 

##### IP Hash

Синтаксис: ip_hash;

Контекст: upstream

Предопределенный вариант метода Hash, в котором хэш основан на IP-адресе клиента.

Если один из серверов нужно убрать на некоторое время, то для сохранения текущего распределения хэш-ключей этот сервер нужно пометить параметром down.

upstream backend {

  ip_hash;

 

  server web1;

  server web2 down;

  server web3;

}

 

##### Least Connections

Синтаксис: least_conn;

Контекст: upstream

Балансировщик нагрузки сравнивает текущее количество активных соединений с каждым из бекендов, и отправляет запрос бекенду с наименьшим количеством соединений.

Этот алгоритм автоматически эффективно распределяет нагрузку по серверам в зависимости от их мощности, т.к. наверняка больше запросов будет отправляться на более мощные сервера, которые имеют меньшее количество текущих подключений. 

##### Least Time

Синтаксис: least_time;

Контекст: upstream

Доступно только в коммерческой версии. Балансировщик нагрузки складывает два показателя - текущее количество активных соединений и время отклика для прошлых запросов - и отправляет запрос на сервер с наименьшим стоимостью.

Этот алгоритм имеет преимущество перед Least Connections , если бекенды имеют отличающееся среднее время отклика, например, это сервера в разных дата-центрах. В этом случае данный алгоритм будетстремится отправлять больше запросов на близкие сервера, потому что они быстрее реагируют.

##### Sticky

Доступно в коммерческой версии. Доступны несколько вариантов работы. Самый понятный – с сохранением состояния в куке.

Синтаксис: sticky cookie имя [expires=время] [domain=домен] [httponly] [secure] [path=путь];

Контекст: upstream

Информация о назначенном сервере сохраняется в HTTP-куке. При первом запросе выбирается случайный сервер, дальнейшие запросы от этого клиента передаются на тот же сервер. Обязательно нужно указать имя куки. Также опционально можно указать параметры куки.

##### Учет веса сервера

Сильно на процесс балансировки влияет указание server weight:

upstream backend {

  server web1 weight=6;

  server web2 weight=3;

  server web3;

}

Веса учитываются во всех алгоритмах балансировки. Наиболее понятным является поведение сервера для Round-robin алгоритма – каждый сервер получает процент входящих запросов, равный его весу, деленному на сумму весов. В примере выше из каждых десяти запросов web1 получает шесть запросов (60%), web2 – три (30%), а web3 – один (10%).

В алгоритмах Hash/IP Hash сервера с большим weight получают на обработку большее количество хешей и соответственно большее количество запросов с этими хэшами.

В алгоритмах Least Connections / Least Time вес сервера пропорционально повышает его оценку (снижает количество активных подключений / снижает время отклика).

### Алгоритм поиска блока

#### Поиск блока server

##### Директива listen

Сначала Nginx попробует выбрать блок на основе директивы listen, используя следующие правила:

·  Nginx переводит все «неполные» директивы listen, заменяя отсутствующие значения значениями по умолчанию. А именно:

·   Если в блоке нет директивы listen, блоку будет присвоено значение 0.0.0.0:80.

·   Если в блоке указан только IP-адрес 111.111.111.111, ему будет присвоен стандартный порт: 111.111.111.111:80.

·   Если в блоке указан только порт 8888, ему будет присвоен стандартный IP-адрес: 0.0.0.0:8888.

·  Определяется IP-адрес и порт в HTTP запросе. Производится поиск блоков server, у которых точно совпадает порт и указан точно такой же IP адрес или IP-адрес 0.0.0.0. При этом блоки с точным IP адресом имеют более высокий приоритет. 

·  Если в результате выбран один блок server, то он используется для обслуживания запроса и поиск прекращается. Если найдено несколько блоков server, Nginx переходит к анализу директивы server_name.

##### Директива server_name

·  Ищется блок с точным совпадением server_name со значением в заголовке Host запроса. 

·  Иначе ищется соответствующий блок, директива server_name которого содержит маску с символами *. 

·  Иначе ищется соответствующий блок, с регулярным выражением в директиве server_name (с символом тильда ~ перед именем). 

·  Иначе выбирается блок server по умолчанию для этого IP-адреса и порта. Это тот у которого в директиве listen опция default_server или, если такого нет, то первый по порядку блок server.

#### Поиск блока location

·  Если есть блок location с модификатором = и строки locationURI и URI запроса точно совпадают, то выбирается этот блок и поиск прекращается. Например, если запрос “/” случается часто, то указав “location = /”, можно ускорить обработку этих запросов, так как поиск прекратится после первого же сравнения.

·  Среди префиксных location (т.е. с модификатором (нет) или ^~) ищется тот, у которого совпадающий префикс URI имеет максимальную длину. Если найденный location c префиксом максимальной длины содержит модификатор ^~, то поиск прекращается и найденный блок выбирается для обслуживания запроса. Иначе, если у найденного location префикс (нет), то этот location запоминается и дальше проверяются регулярные выражения.

·  Проверяются регулярные выражения (с модификаторами (~) и (~*)) сверху вниз. При совпадении будет будет использован первый совпавший блок location.

·  Иначе для обуслуживания запроса выбирается префиксный location, который был найден на 2 шаге.

С того момента, как блок location выбран для обслуживания запроса, запрос обрабатывается целиком в этом контексте и соседние блоки location не могут вмешиваться в этот процесс.

##### Важные моменты:

·  регулярные location имеют более высокий приоритет, чем префиксные location без модификатора. 

·  для префиксных location важна длина совпавшего префикса, для регулярных location важно расположение в конфигурационном файле.

·  При выборе location не учитывается строка запроса, которая начинается со знака "?".

##### Внутренние перенаправления

Ряд директив при обслуживании запроса в location вызвают внутреннее перенаправление и поиск нового location для обработки запроса:

·  index (смотреть тут Все остальные модули

·  index)

·  try_files (смотреть тут try_files)

·  error_page (смотреть тут error_page)

·  rewrite

### Выделения (карманы) в регулярных выражениях

В директивах if, server_name, location могут использоваться регулярные выражения PCRE, внутри которых скобками можно обозначать выделения (карманы).

Результаты выделения затем доступны в виде переменных $1..$9 (позиционные выделения).

location ~ ^(/.*\.html)/$ { 

   return 301 $1$is_args$args; 

}

Можно использовать именованные выделения (карманы), к которым впоследствии можно обратиться через переменную:

server {

  server_name ~^(www\.)?(**?**.+)$;

 

  location / {

​    root /sites/**$domain**;

  }

}

 

 

## PHP-FPM

FPM (*FastCGI Process Manager*) – *FastCGI*-сервер, который позволяет организовать группу РНР-процессов, обрабатывающих запросы с Web-сервера, например *nginx*. Один мастер-процесс, запускающийся с привилегиями суперпользователя *root*, управляет дочерними процессами, работающими под управлением учетных записей пользователей с меньшими привилегиями. Мастер-процесс создает дополнительные процессы при их недостатке, уничтожает старые процессы, чтобы предотвратить утечки памяти. Каждый дочерний PHP-FPM-процесс успевает обслужить от нескольких десятков до нескольких сотен запросов от сервера. В задачу мастер-процесса входит поддержание в системе определенного количества готовых к работе дочерних PHPFPM-процессов.

Устанавливается вместе с пакетом `php` с помощью Homebrew.

### Конфигурация

#### `php.ini`

В папке: `/usr/local/etc/php/<version>/` .  

По умолчанию, PHP CLI и PHP-FPM используют вместе файл `php.ini`. Можно сделать копию `php.ini`, которая будет использоваться только PHP-FPM (название `php-fpm-fcgi.ini`, `php-fpm.ini`???).

#### `php-fpm.conf`

Путь: `/usr/local/etc/php/<version>/php-fpm.conf`

Конфигурационный файл глобальных настроек PHP-FPM.

```nginx
pid = /var/run/php7-fpm.pid      # Путь к файлу с PID мастер-процесса PHP-FPM
error_log = /var/log/php7-fpm.log          # Путь к файлу журнала ошибок
include = /etc/php7/fpm/pool.d/*.conf      # Подключение конфигурации пула 
                                           # процессов PHP-FPM
```

#### `php-fpm.d/*.conf`

Путь: `/usr/local/etc/php/7.4/php-fpm.d/*.conf`.

Набор конфигурационных файлов *pool*'ов PHP-FPM. 

*Pool* – это группа процессов, выделенная для обработки запросов.  Конфигурация каждого *pool*'а задается отдельным файлом. По умолчанию, создается файл конфигурации для *pool*'а `www`. 

Посмотреть запущенные процессы для каждого *pool*'а можно командой `ps`:

```bash
$ ps aux | grep php-fpm
root ... php-fpm: master process
www-data ... php-fpm: pool www
www-data ... php-fpm: pool www
www-data ... php-fpm: pool zzz
www-data ... php-fpm: pool zzz
```

Основная настройка, позволяющая использовать *pool*'ы по отдельности из *web-server*'а – директива `listen`. Для создания дополнительных *pool*'ов необходимо скопировать файл `www.conf` и изменить директиву `listen`.  

Отдельный `.conf` файл может обслуживать:

- несколько *host*'ов
- каждый `.conf`-файл на свой *host*. `.conf`-файл называется в соответствии с именем *host*'а (например, `test.my.conf`). 

##### Директива listen

Директива listen позволяет задать способ обмена PHP-FPM с другими серверами, например, в Web-сервером nginx. Варианты определения:

·  IP-адрес и порт, к которому будет привязан PHP-FPM:

listen « 127.0.0.1:9000 ; на конкретном IP

listen « 0.0.0.0:9000 ; на всех IP

·  Только порт, что эквивалентно указанию 0.0.0.0:

listen = 9000

Если один сервер обслуживает сразу несколько сайтов, и для каждого из сайтов необходимо запустить собственный набор рабочих процессов PHP-FPM, придется использовать несколько портов. 

·  Unix-сокеты. Реализованы в виде файлов на жестком диске, поэтому их невозможно исчерпать. Чтобы разделить Unix-сокеты разных пулов можно включить в путь к к сокетупеременную $pool (название пула – описано ниже). 

listen = /var/www/$pool/fastcgi.sock

##### Директива pm

Директива pm определяет как менеджер процессов управляет числом дочерних рабочими процессами PHP-FPM из пула. 

Воможные значения:

·  static— фиксированное количество рабочих процессов, определяемое директивой pm.max_children;

·  dynamic — динамическое количество рабочих процессов. Каким образом будет выбираться это количество определяется набором директив pm.* (описаны ниже в примере),

·  ondemand — изначально рабочие процессы отсутствуют и создаются только при обращении к PHP-FPM.

##### Пример конфигурации

; Название пула (как правило – доменное имя, которое пул обслуживает. 

; Далее на это имя можно ссылаться, используя переменную Spool, 

; например, для формирования путей к файлу сокетов и журнальным файлам.

[localhost]

 

; Имя пользователя и его группа, с привилегиями которых будут 

; выполняться рабочие процессы PHP-FPM.

user = www-data

group = www-data

 

; Способ взаимодействия с web-сервером (см. выше)

listen = /run/php/php7.2-fpm.sock

 

; Владелец и группа для файла сокета

listen.owner = www-data

listen.group = www-data

 

 

; Как менеджер процессов управляет числом рабочих процессов (см. выше)

pm = dynamic

 

; Число дочерних процессов, создаваемых в режиме static, и максимальное

; число рабочих процессов в режиме dynamic.

pm.max_children = 5

 

; Количество рабочих процессов, которые создаются сразу после старта PHP-FPM

pm.start_servers = 2

 

; Желательное минимальное количество незанятых 

; и готовых к приему запросов рабочих процессов 

pm.min_spare_servers = 1

 

; Желательное максимальное количество незанятых 

; и готовых к приему запросов рабочих процессов 

pm.max_spare_servers = 3

 

 

; Файлы с какими расширения разрешено исполнять

; По умолчанию: .php

; security.limit_extensions = .php .php3 .php4 .php5 .php7

 

; Переопределение параметров в php.ini, специфичными для этого пула 

; настройками

; php_value/php_flag – настройки, которые можно переписать через PHP-вызов 

;           'ini_set'.

; php_admin_value/php_admin_flag - настройки, которые нельзя переписать 

​            через PHP-вызов 'ini_set'.

; php_flag[display_errors] = off

; php_admin_value[error_log] = /var/log/fpm-php.www.log

; php_admin_flag[log_errors] = on

; php_admin_value[memory_limit] = 32M

### Подключение к nginx

Если *PHP-FPM* расположен удаленно от *nginx*, то передача запросов от *nginx* к *PHP-FPM* должна производится через директиву `fastcgi_pass` как написано в описании директивы [`location`](#секция-location-местоположение)).

Если *nginx* и *PHP-FPM* находятся на одном узле, то взаимодействие лучше организовать через сокеты.

Проксирование напрямую:

```nginx
location - \.php$ { 
	try_files $uri =404;
	fastcgi_pass unix:/var/www/localhost/fastcgi.sock; 
	fastcgi_index index.php; 
	include fastcgi_params;
	fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
}
```

Через `upstream`:

```nginx
upstream dynamic {
	server unix:/var/www/localhost/fastcgi.sock fail_timeout=0;
}

server {
	...
	location ~* \.php$ {
		fastcgi_pass dynamic; 
		include fastcgi_params; 
		fastcgi_index index.php;
		fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
	}
}
```

## Технологии

### SSI

[https://ru.m.wikipedia.org/wiki/SSI_(программирование)](https://vk.com/away.php?to=https%3A%2F%2Fru.m.wikipedia.org%2Fwiki%2FSSI_%28%EF%F0%EE%E3%F0%E0%EC%EC%E8%F0%EE%E2%E0%ED%E8%E5%29&cc_key=)

SSI (Server Side Includes, включения на стороне сервера) — язык для динамической «сборки» веб-страниц на сервере из отдельных составных частей и выдачи клиенту полученного HTML-документа. 

Технология поддерживается Apache и Nginx (директива ssi on).

Благодаря крайней простоте языка сборка SSI-страниц происходит очень быстро, однако, многие возможности полноценных языков программирования, например, работа с файлами, в SSI отсутствуют.

#### Переменные окружения

Доступен для использования набор инициализированных переменных окружения:

·  DOCUMENT_ROOT – название корневой папки для вебстраниц на сервере

·  USER_AGENT и HTTP_USER_AGENT – заголовок User-Agent

и др.

#### Команды SSI

Общий формат команд:

<!--#команда параметр1=значение1 параметр2=значение2 ... -->

##### include

Включает в ответ содержимое файла или результат другого запроса.

Способы указать расположение того, что включается:

·  Атрибут file указывает путь, относительно сканируемого документа. Путь не может содержать ../ и не может быть абсолютным путём

<!--#include file="footer.html" -->

·  Атрибут virtual содержит относительный или абсолютный URL. URL не может содержать имя протокола или имя хоста, но может содержать запрос (query) после символа ?.

<!--#include virtual="/remote/body.php?argument=value" -->

##### set

Присваивает значение переменной. После этого переменная доступна как $name.

<!--#set var="name" value="value" --> 

var

Имя переменной.

value

Значение переменной. Если в присваиваемом значении есть переменные, то производится подстановка их значений.

##### echo

Выводит значение переменной. 

<!--#echo var="name"-->

var

имя переменной.

Пример: выводятся переменные окружения HTTP_HOST и DOCUMENT_URI:

http://<!--#echo var="HTTP_HOST"--><!--#echo var="DOCUMENT_URI"-->

в результате будет выдано в браузер: 

http://fishki.net/profile/?user_id=1

##### if

Выполняет условное включение. 

<!--#if expr="..." -->

...

<!--#elif expr="..." -->

...

<!--#else -->

...

<!--#endif -->

Параметр команды:

expr

Проверяемое выражение. Возможные варианты выражений:

·  проверка существования переменной:

<!--#if expr="$name" -->

·  сравнение переменной с текстом:

<!--#if expr="$name = text" -->

<!--#if expr="$name != text" -->

·  сравнение переменной с регулярным выражением:

<!--#if expr="$name = /text/" -->

<!--#if expr="$name != /text/" -->

### CGI

#### CGI

CGI (Common Gateway Interface — «общий интерфейс шлюза») — стандарт интерфейса, используемого для связи внешней программы с веб-сервером. Программу, которая работает по такому интерфейсу совместно с веб-сервером, принято называть шлюзом, хотя многие предпочитают названия «скрипт» (сценарий) или «CGI-программа». 

Cкрипт CGI выполняется во время обработки запроса и должен сгенеририровать HTML. Тело запроса (например, в котором находятся параметры POST) передается скрипту CGI через консоль ввода. Другие данные, такие как пути URL и заголовки HTTP помещаются в переменные окружения. 

Пример некоторых из переменных окружения для запроса с URL http://example.com/cgi-bin/printenv.pl/foo/bar?var1=value1&var2=with%20percent%20encoding:

HTTP_HOST="example.com"

HTTP_USER_AGENT="Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0) Gecko/20100101 Firefox/5.0"

PATH_INFO="/foo/bar"

QUERY_STRING="var1=value1&var2=with%20percent%20encoding"

REMOTE_ADDR="127.0.0.1"

REMOTE_PORT="63555"

REQUEST_METHOD="GET"

REQUEST_URI="/cgi-bin/printenv.pl/foo/bar?var1=value1&var2=with%20percent%20encoding"

SCRIPT_FILENAME="C:/Program Files (x86)/Apache Software Foundation/Apache2.2/cgi-bin/printenv.pl"

Скрипт должен возвращать результат в виде стандартного вывода на консоль вывода (printf()). Вывод соответствует стандартному ответу по протоколу HTTP без стартовой строки. Т.е. ответ начинается с заголовков, пустой строки, за которой идет HTML.

##### Конфигурирование веб-сервера

Веб-сервер необходимо сконфигурировать, чтобы указать каким URL-адресам соответствуют скрипты CGI. Все скрипты, как правило, помещают в каталог cgi (или cgi-bin) сервера в целях безопасности. Если браузер запрашивает URL-адрес, указывающий на файл в каталоге CGI (например, http://example.com/cgi-bin/printenv.pl/with/additional/path?and=a&query=string), вместо того, чтобы просто отправлять этот файл ( /usr/local/apache/htdocs/cgi-bin/printenv.pl) в браузер, HTTP-сервер запускает указанный скрипт и передает выходные данные сценария в браузер. 

Также популярностью пользуется конфигурирование веб-сервера таким образом, чтобы все CGI скрипты имели одинаковое расширение, например, .cgi. Однако такой подход уязвим для атак злоумышленника, который сможет загрузить исполняемый код с соответствующим расширением.

Для написания таких скриптов может быть использован любой язык программирования, который имеет возможности ввода/вывода на консоль.

Пример программы Hello World на языке C:

\#include <stdio.h> 

int main(void) { 

   printf("Content-Type: text/plain;charset=us-ascii\n\n"); 

   printf("Hello, world!\n\n"); 

   return 0; 

}

##### Недостатки и альтернативы

Запрос к скрипту означает создание нового процесса на сервере. Запуск процесса может потреблять гораздо больше времени и памяти, чем фактическая работа по генерации вывода, особенно если используется запуск интерпретатора PHP, а не скомпилированный файл. 

Альтернативные варианты исполнения динамических скриптов:

·  Встроить обработку в веб-сервер, путем подключения расширения, такого как модули Apache, плагины NSAPI и плагины ISAPI,.

·  Использовать [FastCGI](https://en.wikipedia.org/wiki/FastCGI). Эта технология уменьшает накладные расходы, позволяя долгоживущему процессу обрабатывать множество запросов. При этом FastCGI-процессы находятся за пределами веб-серверами и не зависят от него.

·  Simple Common Gateway Interface (SCGI) — протокол для взаимодействия приложений с веб-сервером, разработанный как альтернатива CGI. Похож на [FastCGI](https://ru.wikipedia.org/wiki/FastCGI), но проще в реализации.

#### FastCGI

Клиент-серверный протокол взаимодействия веб-сервера (клиент) и приложения (сервер), дальнейшее развитие технологии CGI. По сравнению с CGI является более производительным и безопасным.

Недостаток CGI-скриптов в том, что они запускаются в отдельных процессах , которые создаются в начале каждого запроса и завершаются в конце, что значительно снижает производительность. FastCGI, вместо этого использует постоянно запущенные процессы для обработки множества запросов, тем самым избегая накладных расходов на создание и завершение процесса запроса. Эти процессы принадлежат серверу FastCGI, а не веб-серверу.

В то время как CGI-программы взаимодействуют с сервером через STDIN и STDOUT запущенного CGI-процесса, FastCGI-процессы используют Unix Sockets или TCP/IP для связи с сервером. Это даёт следующее преимущество над обычными CGI-программами: 

·  FastCGI-программы могут быть запущены не только на этом же сервере, но и где угодно в сети. 

·  Также возможна обработка запросов несколькими FastCGI-процессами или даже несколькими FastCGI-серверами, работающими параллельно. Это повышает стабильность и масштабируемость.

Дополнительная безопасность заключается в следующем:

·  возможен запуск FastCGI-процесса под учётной записью непривилегированного пользователя, отличного от пользователя веб-сервера

·  FastCGI-процесс может находиться в chroot'е, отличном от chroot'а веб-сервера.